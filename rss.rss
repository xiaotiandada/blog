<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>xiaotiandada/blog Issues</title>
        <link>http://example.com/</link>
        <description>xiaotiandada/blog Issues</description>
        <lastBuildDate>Wed, 29 Jun 2022 10:57:05 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh-CN</language>
        <copyright>All rights reserved 2022, xiaotian</copyright>
        <item>
            <title><![CDATA[[NodeJS] TypeError: string.replaceAll is not a function]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/116</link>
            <guid>https://github.com/xiaotiandada/blog/issues/116</guid>
            <pubDate>Wed, 29 Jun 2022 04:19:50 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://yongjinkim.com/nodejstypeerror-string-replaceall-is-not-a-function-%E3%81%AE%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95/">https://yongjinkim.com/nodejstypeerror-string-replaceall-is-not-a-function-の解決方法/</a></li>
</ul>
<p><code>String.prototype.replaceAll()</code></p>
<p>错误环境</p>
<ol>
<li>Github Actions 14x 测试报错</li>
<li>vercel 14x 环境运行报错</li>
</ol>
<p>解决方案</p>
<ol>
<li>升级 v15+</li>
<li>替换为 replace</li>
</ol>
]]></description>
        </item>
        <item>
            <title><![CDATA[Webpack]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/115</link>
            <guid>https://github.com/xiaotiandada/blog/issues/115</guid>
            <pubDate>Sat, 25 Jun 2022 09:56:37 GMT</pubDate>
            <description><![CDATA[<p>Babel 7 不需要 ts-loader。从 Babel 7 开始，ts-loader 是不必要的，因为 Babel 7 支持 TypeScript</p>
<ul>
<li><a href="https://github.com/Microsoft/TypeScript-Babel-Starter">https://github.com/Microsoft/TypeScript-Babel-Starter</a></li>
<li><a href="https://stackoverflow.com/questions/38320220/how-to-setup-typescript-babel-webpack">https://stackoverflow.com/questions/38320220/how-to-setup-typescript-babel-webpack</a></li>
<li><a href="https://babeljs.io/docs/en/babel-preset-typescript">https://babeljs.io/docs/en/babel-preset-typescript</a></li>
<li><a href="https://devblogs.microsoft.com/typescript/typescript-and-babel-7/">https://devblogs.microsoft.com/typescript/typescript-and-babel-7/</a></li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[Jest]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/114</link>
            <guid>https://github.com/xiaotiandada/blog/issues/114</guid>
            <pubDate>Mon, 27 Jun 2022 15:29:45 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://jestjs.io/">https://jestjs.io/</a></li>
<li><a href="https://www.jianshu.com/p/c1b5676c1edd">https://www.jianshu.com/p/c1b5676c1edd</a></li>
</ul>
<h2>Next + TypeScript + Jest</h2>
<pre><code>    /node_modules/parse-domain/build/main.js:3
    export { parseDomain, ParseResultType, } from &quot;./parse-domain.js&quot;;
    ^^^^^^

    SyntaxError: Unexpected token 'export'

      1 | import assert from 'assert'
    &gt; 2 | import { fromUrl, parseDomain, ParseResultType } from 'parse-domain'
        | ^
      3 | import { toUnicode } from 'punycode'
      4 |
</code></pre>
<p>忽略转换模式, 不起作用，直接删除 node_modules 反而生效. 但是会变慢...</p>
<pre><code class="language-js">  transformIgnorePatterns: [
    '!node_modules/',
   // '/node_modules/',
  ],
</code></pre>
<p>新的解决方案, 忽略一些报错的包</p>
<pre><code class="language-js">  transformIgnorePatterns: [
    '/node_modules/(?!parse-domain|is-ip|ip-regex|uuid)', // SyntaxError: Unexpected token 'export'
  ],
</code></pre>
<pre><code>  ● Test suite failed to run

    ReferenceError: TextEncoder is not defined

      1 | import assert from 'assert'
    &gt; 2 | import { fromUrl, parseDomain, ParseResultType } from 'parse-domain'
        | ^
      3 | import { toUnicode } from 'punycode'
</code></pre>
<p>设置 <code>TextEncoder</code></p>
<ul>
<li><a href="https://github.com/inrupt/solid-client-authn-js/issues/1676#issuecomment-917016646">https://github.com/inrupt/solid-client-authn-js/issues/1676#issuecomment-917016646</a></li>
<li><a href="https://stackoverflow.com/questions/57712235/referenceerror-textencoder-is-not-defined-when-running-react-scripts-test/72734315#72734315">https://stackoverflow.com/questions/57712235/referenceerror-textencoder-is-not-defined-when-running-react-scripts-test/72734315#72734315</a></li>
<li><a href="https://github.com/microsoft/accessibility-insights-web/pull/5421#issuecomment-1109168149">https://github.com/microsoft/accessibility-insights-web/pull/5421#issuecomment-1109168149</a></li>
<li><a href="https://github.com/microsoft/accessibility-insights-web/pull/5421/commits/9ad4e618019298d82732d49d00aafb846fb6bac7#diff-c4f1d9c9d7b982f26536dbd6bf8c0804c1c0011fba8bc6df6e937363acfffa1f">https://github.com/microsoft/accessibility-insights-web/pull/5421/commits/9ad4e618019298d82732d49d00aafb846fb6bac7#diff-c4f1d9c9d7b982f26536dbd6bf8c0804c1c0011fba8bc6df6e937363acfffa1f</a></li>
<li><a href="https://blog.csdn.net/weixin_42429288/article/details/124590185">https://blog.csdn.net/weixin_42429288/article/details/124590185</a></li>
<li><a href="https://github.com/vercel/next.js/blob/canary/examples/with-jest/jest.config.js">https://github.com/vercel/next.js/blob/canary/examples/with-jest/jest.config.js</a></li>
<li><a href="https://github.com/vercel/next.js/blob/canary/examples/with-jest-babel/jest.config.js">https://github.com/vercel/next.js/blob/canary/examples/with-jest-babel/jest.config.js</a></li>
<li><a href="https://juejin.cn/post/6844903942023823367#heading-8">https://juejin.cn/post/6844903942023823367#heading-8</a></li>
</ul>
<pre><code class="language-js">// ...
setupFiles: [`&lt;rootDir&gt;/jest-shim.js`],
testEnvironment: 'jest-environment-jsdom',
// ...
</code></pre>
<pre><code class="language-js">import { TextDecoder, TextEncoder } from 'util'

global.TextEncoder = TextEncoder
global.TextDecoder = TextDecoder
</code></pre>
<h2>decorators-legacy</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/52262084/syntax-error-support-for-the-experimental-syntax-decorators-legacy-isnt-cur">https://stackoverflow.com/questions/52262084/syntax-error-support-for-the-experimental-syntax-decorators-legacy-isnt-cur</a></li>
<li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators">https://babeljs.io/docs/en/babel-plugin-proposal-decorators</a></li>
</ul>
<pre><code>Support for the experimental syntax 'decorators-legacy' isn't currently enabled (23:3):
</code></pre>
<h2>Env</h2>
<ul>
<li><a href="https://blog.shinki.net/posts/nextjs-jest-environment-variable">https://blog.shinki.net/posts/nextjs-jest-environment-variable</a></li>
<li><a href="https://nextjs.org/docs/basic-features/environment-variables">https://nextjs.org/docs/basic-features/environment-variables</a></li>
</ul>
<pre><code class="language-js">import { loadEnvConfig } from '@next/env'

const projectDir = process.cwd()
loadEnvConfig(projectDir)
</code></pre>
<h2>baseUrl paths</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/50171412/jest-typescript-absolute-paths-baseurl-gives-error-cannot-find-module">https://stackoverflow.com/questions/50171412/jest-typescript-absolute-paths-baseurl-gives-error-cannot-find-module</a></li>
<li><a href="https://jestjs.io/zh-Hans/docs/configuration#moduledirectories-arraystring">https://jestjs.io/zh-Hans/docs/configuration#moduledirectories-arraystring</a></li>
</ul>
<pre><code class="language-js">  moduleDirectories: ['&lt;rootDir&gt;/node_modules', '&lt;rootDir&gt;'],
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[Cross-Origin-Embedder-Policy]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/113</link>
            <guid>https://github.com/xiaotiandada/blog/issues/113</guid>
            <pubDate>Wed, 15 Jun 2022 13:52:08 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy</a></li>
<li><a href="https://developer.chrome.com/blog/coep-credentialless-origin-trial/">https://developer.chrome.com/blog/coep-credentialless-origin-trial/</a></li>
<li><a href="https://web.dev/coop-coep/?utm_source=devtools">https://web.dev/coop-coep/?utm_source=devtools</a></li>
<li><a href="https://github.com/WICG/credentiallessness">https://github.com/WICG/credentiallessness</a></li>
<li><a href="https://github.com/WICG/proposals/issues/31">https://github.com/WICG/proposals/issues/31</a></li>
<li><a href="https://web.dev/i18n/zh/why-coop-coep/">https://web.dev/i18n/zh/why-coop-coep/</a></li>
</ul>
<pre><code class="language-ts">Cross-Origin-Embedder-Policy: unsafe-none | require-corp
</code></pre>
<p>相关信息 #111</p>
<img width="748" alt="image" src="https://user-images.githubusercontent.com/24250627/173811159-804ede52-80fc-4519-af82-8270deb3b63f.png">
]]></description>
        </item>
        <item>
            <title><![CDATA[Cross-Origin-Opener-Policy]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/112</link>
            <guid>https://github.com/xiaotiandada/blog/issues/112</guid>
            <pubDate>Mon, 13 Jun 2022 17:10:53 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy</a></li>
</ul>
<pre><code class="language-ts">[
  {
    key: 'Cross-Origin-Embedder-Policy',
    value: 'require-corp',
  },
  {
    key: 'Cross-Origin-Opener-Policy',
    value: 'same-origin',
  },
]
</code></pre>
<p>如果需要浏览器支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer">SharedArrayBuffer</a> 需要设置 header <code>same-origin</code></p>
<pre><code class="language-ts">Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp
</code></pre>
<ul>
<li><a href="https://web.dev/why-coop-coep/?utm_source=devtools">https://web.dev/why-coop-coep/?utm_source=devtools</a></li>
<li><a href="https://developer.chrome.com/docs/extensions/mv3/cross-origin-isolation/">https://developer.chrome.com/docs/extensions/mv3/cross-origin-isolation/</a></li>
<li><a href="https://github.com/camillelamy/explainers/blob/main/anonymous_iframes.md">https://github.com/camillelamy/explainers/blob/main/anonymous_iframes.md</a></li>
<li><a href="https://developer.chrome.com/origintrials/#/register_trial/303992974847508481">https://developer.chrome.com/origintrials/#/register_trial/303992974847508481</a></li>
<li><a href="https://blog.agektmr.com/2021/11/cross-origin-isolation.html">https://blog.agektmr.com/2021/11/cross-origin-isolation.html</a></li>
<li><a href="https://first-party-test.glitch.me/">https://first-party-test.glitch.me/</a></li>
<li><a href="https://stackoverflow.com/questions/70535752/enable-sharedarraybuffer-on-localhost">https://stackoverflow.com/questions/70535752/enable-sharedarraybuffer-on-localhost</a></li>
</ul>
<p>相关信息 #111</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Cross-Origin Resource Policy (CORP)]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/111</link>
            <guid>https://github.com/xiaotiandada/blog/issues/111</guid>
            <pubDate>Mon, 13 Jun 2022 17:10:58 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cross-Origin_Resource_Policy_(CORP)">https://developer.mozilla.org/en-US/docs/Web/HTTP/Cross-Origin_Resource_Policy_(CORP)</a></li>
<li><a href="https://web.dev/coop-coep/?utm_source=devtools">https://web.dev/coop-coep/?utm_source=devtools</a></li>
<li><a href="https://web.dev/same-site-same-origin/?utm_source=devtools">https://web.dev/same-site-same-origin/?utm_source=devtools</a></li>
</ul>
<p>如果父级设置了 <code>Cross-Origin-Opener-Policy</code></p>
<pre><code class="language-ts">[
  {
    key: 'Cross-Origin-Embedder-Policy',
    value: 'require-corp',
  },
  {
    key: 'Cross-Origin-Opener-Policy',
    value: 'same-origin',
  },
]
</code></pre>
<p>引用外部链接会无法工作，比如说 s3 img 资源。需要设置 header</p>
<p>example: <code>cross-origin-resource-policy: cross-origin</code></p>
<p><img src="https://user-images.githubusercontent.com/24250627/172420995-8a5a81ea-007d-4c42-b09e-38a241014389.png" alt="image"></p>
<pre><code class="language-ts">Cross-Origin-Resource-Policy: same-site | same-origin | cross-origin
</code></pre>
<p>引入 iframe easyRPG player 也会被阻止</p>
<p><img src="https://user-images.githubusercontent.com/24250627/173024097-faef9f19-b027-4a7a-94b8-5c18a4446c85.png" alt="image"></p>
<p>还会出现 <code>cross-origin-embedder-policy</code> 警告</p>
<p><img src="https://user-images.githubusercontent.com/24250627/173173791-2c74eede-75c5-420a-a2e3-480889e41197.png" alt="image"></p>
<pre><code>Cross-Origin-Embedder-Policy: require-corp
Cross-Origin-Resource-Policy: cross-origin
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[FileReader API]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/110</link>
            <guid>https://github.com/xiaotiandada/blog/issues/110</guid>
            <pubDate>Wed, 29 Jun 2022 04:10:47 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader">https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader</a></li>
<li><a href="https://dev.to/j471n/preview-file-before-uploading-in-react-27kn">https://dev.to/j471n/preview-file-before-uploading-in-react-27kn</a></li>
</ul>
<hr>
<ul>
<li><a href="https://ant.design/components/upload-cn/">https://ant.design/components/upload-cn/</a></li>
</ul>
<pre><code class="language-tsx">const getBase64 = (img: RcFile, callback: (url: string) =&gt; void) =&gt; {
  const reader = new FileReader();
  reader.addEventListener('load', () =&gt; callback(reader.result as string));
  reader.readAsDataURL(img);
};
</code></pre>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL">https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL</a>  也可以做图片预览</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[theme]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/109</link>
            <guid>https://github.com/xiaotiandada/blog/issues/109</guid>
            <pubDate>Thu, 16 Jun 2022 11:51:28 GMT</pubDate>
            <description><![CDATA[<h3>Next.js</h3>
<ul>
<li><a href="https://github.com/xiaotiandada/next-theme">https://github.com/xiaotiandada/next-theme</a></li>
<li><a href="https://github.com/xiaotiandada/next-theme/blob/main/pages/_app.tsx">https://github.com/xiaotiandada/next-theme/blob/main/pages/_app.tsx</a></li>
</ul>
<p>如果需要 可以考虑用 cookie 传递服务端的主题，因为 next-themes 使用的是 localstore 存储
大部分情况 不需要
可供参考：<a href="https://github.com/xeoneux/next-dark-mode/blob/main/src/index.tsx">https://github.com/xeoneux/next-dark-mode/blob/main/src/index.tsx</a>
使用 cookies 不是一个好主意 <a href="https://github.com/pacocoursey/next-themes/issues/17">https://github.com/pacocoursey/next-themes/issues/17</a></p>
<p>使用 localstore 结合 MUI UI 库可能会有闪烁的情况，需要更能多的实践</p>
<h3>MUI</h3>
<pre><code class="language-ts">import { createTheme, ThemeOptions } from '@mui/material/styles'

// https://mui.com/material-ui/customization/default-theme/
// https://material.io/resources/color

const defaultTheme: ThemeOptions = {
  typography: {
    button: {
      textTransform: 'none',
    },
  },
}

export const lightTheme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: '#ff2449',
      light: '#ff6675',
      dark: '#c40022',
    },
  },
  ...defaultTheme,
})
export const darkTheme = createTheme({
  palette: {
    mode: 'dark',
    primary: {
      main: '#f93c5b',
      light: '#ff7588',
      dark: '#bf0032',
    },
  },
  ...defaultTheme,
})
</code></pre>
<h3>Disqus</h3>
<p>-<a href="https://stackoverflow.com/questions/65260505/disqus-iframe-transparency-wont-work-on-chrome-87">https://stackoverflow.com/questions/65260505/disqus-iframe-transparency-wont-work-on-chrome-87</a>
-<a href="https://github.com/w3c/csswg-drafts/issues/4772">https://github.com/w3c/csswg-drafts/issues/4772</a></p>
<h3>Algolia</h3>
<ul>
<li><a href="https://github.com/algolia/autocomplete/blob/next/packages/autocomplete-theme-classic/src/theme.scss#L107">https://github.com/algolia/autocomplete/blob/next/packages/autocomplete-theme-classic/src/theme.scss#L107</a></li>
<li><a href="https://dev.to/algolia/creating-an-omnibar-with-autocomplete-3jgh">https://dev.to/algolia/creating-an-omnibar-with-autocomplete-3jgh</a></li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[React Hook Form + MUI 构建表单]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/108</link>
            <guid>https://github.com/xiaotiandada/blog/issues/108</guid>
            <pubDate>Mon, 20 Jun 2022 16:00:00 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://react-hook-form.com/">https://react-hook-form.com/</a></li>
<li><a href="https://mui.com/zh/">https://mui.com/zh/</a></li>
<li><a href="https://codesandbox.io/u/bluebill1049">https://codesandbox.io/u/bluebill1049</a></li>
<li><a href="https://github.com/react-hook-form/react-hook-form/tree/master/examples">https://github.com/react-hook-form/react-hook-form/tree/master/examples</a></li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[seo]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/107</link>
            <guid>https://github.com/xiaotiandada/blog/issues/107</guid>
            <pubDate>Fri, 20 May 2022 03:33:29 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://search.google.com/search-console/about">https://search.google.com/search-console/about</a></li>
<li><a href="https://analytics.google.com/analytics/web/">https://analytics.google.com/analytics/web/</a></li>
<li><a href="https://ziyuan.baidu.com/linksubmit/url?sitename=">https://ziyuan.baidu.com/linksubmit/url?sitename=</a></li>
<li><a href="https://tongji.baidu.com/web/welcome/login">https://tongji.baidu.com/web/welcome/login</a></li>
<li><a href="https://github.com/w3itch-crafter/w3itch-frontend/issues/129">https://github.com/w3itch-crafter/w3itch-frontend/issues/129</a></li>
</ul>
<hr>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/150718629">google search console 终极教程</a></li>
<li><a href="https://ahrefs.com/blog/zh/robots-txt/">关于Robots.txt和SEO: 你所需要知道的一切</a></li>
<li><a href="https://github.com/iamvishnusankar/next-sitemap#building-sitemaps">https://github.com/iamvishnusankar/next-sitemap#building-sitemaps</a></li>
</ul>
<p>Next 使用 next-sitemap</p>
<h3>Server side index-sitemaps (getServerSideSitemapIndex)</h3>
<p>生成 sitemaps 索引，在大文件拆分应该可以用到</p>
<ul>
<li><a href="https://github.com/iamvishnusankar/next-sitemap#server-side-index-sitemaps-getserversidesitemapindex">https://github.com/iamvishnusankar/next-sitemap#server-side-index-sitemaps-getserversidesitemapindex</a></li>
</ul>
<pre><code class="language-tsx">// pages/server-sitemap-index.xml/index.tsx
import { getServerSideSitemapIndex } from 'next-sitemap'
import { GetServerSideProps } from 'next'

export const getServerSideProps: GetServerSideProps = async (ctx) =&gt; {
  // Method to source urls from cms
  // const urls = await fetch('https//example.com/api')

  return getServerSideSitemapIndex(ctx, [
    'https://example.com/path-1.xml',
    'https://example.com/path-2.xml',
  ])
}

// Default export to prevent next.js errors
export default function SitemapIndex() {}
</code></pre>
<pre><code class="language-xml">&lt;sitemapindex xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;
&lt;sitemap&gt;
&lt;loc&gt;https://example.com/path-1.xml&lt;/loc&gt;
&lt;/sitemap&gt;
&lt;sitemap&gt;
&lt;/sitemapindex&gt;
</code></pre>
<h3>server side sitemap (getServerSideSitemap)</h3>
<p>生成 sitemaps</p>
<ul>
<li><a href="https://github.com/iamvishnusankar/next-sitemap#server-side-sitemap-getserversidesitemap">https://github.com/iamvishnusankar/next-sitemap#server-side-sitemap-getserversidesitemap</a></li>
</ul>
<pre><code class="language-tsx">// pages/server-sitemap.xml/index.tsx

import { getServerSideSitemap } from 'next-sitemap'
import { GetServerSideProps } from 'next'

export const getServerSideProps: GetServerSideProps = async (ctx) =&gt; {
  // Method to source urls from cms
  // const urls = await fetch('https//example.com/api')

  const fields = [
    {
      loc: 'https://example.com', // Absolute url
      lastmod: new Date().toISOString(),
      // changefreq
      // priority
    },
    {
      loc: 'https://example.com/dynamic-path-2', // Absolute url
      lastmod: new Date().toISOString(),
      // changefreq
      // priority
    },
  ]

  return getServerSideSitemap(ctx, fields)
}

// Default export to prevent next.js errors
export default function Sitemap() {}
</code></pre>
<p><code>fields</code> TS is <code>ISitemapField[]</code></p>
<pre><code class="language-xml">&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot; xmlns:news=&quot;http://www.google.com/schemas/sitemap-news/0.9&quot; xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:mobile=&quot;http://www.google.com/schemas/sitemap-mobile/1.0&quot; xmlns:image=&quot;http://www.google.com/schemas/sitemap-image/1.1&quot; xmlns:video=&quot;http://www.google.com/schemas/sitemap-video/1.1&quot;&gt;
&lt;url&gt;
&lt;loc&gt;https://demo.io/game/65&lt;/loc&gt;
&lt;lastmod&gt;2022-05-12T16:35:07.696Z&lt;/lastmod&gt;
&lt;changefreq&gt;daily&lt;/changefreq&gt;
&lt;priority&gt;0.7&lt;/priority&gt;
&lt;/url&gt;
&lt;/urlset&gt;
</code></pre>
<h3>JSON-LD</h3>
<ul>
<li><a href="https://github.com/garmeeh/next-seo#json-ld">https://github.com/garmeeh/next-seo#json-ld</a></li>
<li><a href="https://search.google.com/test/rich-results">https://search.google.com/test/rich-results</a></li>
<li><a href="https://developers.google.com/search/docs/advanced/robots/robots_meta_tag?hl=zh-cn">https://developers.google.com/search/docs/advanced/robots/robots_meta_tag?hl=zh-cn</a></li>
</ul>
<img width="791" alt="image" src="https://user-images.githubusercontent.com/24250627/168475174-bc6729eb-1d65-4791-9f59-c16b5aba4c20.png">
]]></description>
        </item>
        <item>
            <title><![CDATA[npm, yarn scripts 使用指南]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/106</link>
            <guid>https://github.com/xiaotiandada/blog/issues/106</guid>
            <pubDate>Wed, 29 Jun 2022 03:58:23 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html">npm scripts 使用指南</a></li>
<li><a href="https://yarnpkg.com/advanced/lifecycle-scripts">https://yarnpkg.com/advanced/lifecycle-scripts</a></li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[Yarn]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/105</link>
            <guid>https://github.com/xiaotiandada/blog/issues/105</guid>
            <pubDate>Sun, 29 May 2022 10:05:39 GMT</pubDate>
            <description><![CDATA[<pre><code>➤ YN0000: └ Completed in 0s 488ms
➤ YN0000: ┌ Fetch step
➤ YN0013: │ ethereumjs-abi@https://github.com/ethereumjs/ethereumjs-abi.git#commit=ee3994657fa7a427238e6ba92a84d0b529bbcde0 ca
➤ YN0013: │ ethereumjs-abi@https://github.com/ethereumjs/ethereumjs-abi.git#commit=ee3994657fa7a427238e6ba92a84d0b529bbcde0 ca
➤ YN0018: │ ethereumjs-abi@https://github.com/ethereumjs/ethereumjs-abi.git#commit=ee3994657fa7a427238e6ba92a84d0b529bbcde0: The remote archive doesn't match the expected checksum
➤ YN0000: └ Completed in 6s 167ms
➤ YN0000: Failed with errors in 6s 661ms
</code></pre>
<ul>
<li><a href="https://yarnpkg.com/advanced/error-codes#yn0018---cache_checksum_mismatch">https://yarnpkg.com/advanced/error-codes#yn0018---cache_checksum_mismatch</a></li>
<li><a href="https://github.com/yarnpkg/berry/issues/1142#issuecomment-607272809">https://github.com/yarnpkg/berry/issues/1142#issuecomment-607272809</a></li>
</ul>
<pre><code>yarn cache clean --all
YARN_CHECKSUM_BEHAVIOR=update yarn
</code></pre>
<h3>Github Actions</h3>
<ul>
<li><a href="https://yarnpkg.com/cli/install">https://yarnpkg.com/cli/install</a></li>
<li><a href="https://classic.yarnpkg.com/lang/en/docs/cli/install/">https://classic.yarnpkg.com/lang/en/docs/cli/install/</a></li>
<li><a href="https://stackoverflow.com/questions/58482655/what-is-the-closest-to-npm-ci-in-yarn">https://stackoverflow.com/questions/58482655/what-is-the-closest-to-npm-ci-in-yarn</a></li>
<li><a href="https://yarnpkg.com/getting-started/migration#step-by-step">https://yarnpkg.com/getting-started/migration#step-by-step</a></li>
<li><a href="https://github.com/actions/setup-node/pull/495">https://github.com/actions/setup-node/pull/495</a></li>
<li><a href="https://stackoverflow.com/questions/52630404/how-to-install-packages-based-on-the-lock-file-with-yarn">https://stackoverflow.com/questions/52630404/how-to-install-packages-based-on-the-lock-file-with-yarn</a>
<code>YN0050: The --frozen-lockfile option is deprecated; use --immutable and/or --immutable-cache instead</code></li>
</ul>
<pre><code class="language-yml">steps:
- uses: actions/checkout@v3
- uses: actions/setup-node@v3
  with:
    node-version: '14'
    cache: 'yarn'
- run: yarn install --frozen-lockfile
- run: yarn test
</code></pre>
<pre><code class="language-yml"> - run: yarn install --immutable
</code></pre>
<h3>npm/yarn scripts 使用指南</h3>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html">npm scripts 使用指南</a></li>
<li><a href="https://yarnpkg.com/advanced/lifecycle-scripts">https://yarnpkg.com/advanced/lifecycle-scripts</a></li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[Animation case]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/104</link>
            <guid>https://github.com/xiaotiandada/blog/issues/104</guid>
            <pubDate>Thu, 28 Apr 2022 10:45:24 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://codesandbox.io/s/swap-swap-rotate-bieux9">swap swap-rotate</a></li>
<li><a href="https://codesandbox.io/s/logo-showcase-l9t8e7?file=/src/App.tsx">logo-showcase</a></li>
<li><a href="https://codesandbox.io/s/showcase-g9j1j2">showcase</a></li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[iPhoneX 安全区域]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/103</link>
            <guid>https://github.com/xiaotiandada/blog/issues/103</guid>
            <pubDate>Wed, 27 Apr 2022 09:01:33 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://segmentfault.com/a/1190000022191869">https://segmentfault.com/a/1190000022191869</a></li>
<li><a href="https://www.shouxicto.com/article/1558.html">https://www.shouxicto.com/article/1558.html</a></li>
<li><a href="https://www.zcool.com.cn/article/ZNTU1MTUy.html">https://www.zcool.com.cn/article/ZNTU1MTUy.html</a></li>
</ul>
<pre><code class="language-css">padding-bottom: constant(safe-area-inset-bottom); /*兼容 IOS&lt;11.2*/
padding-bottom: env(safe-area-inset-bottom); /*兼容 IOS&gt;11.2*/
</code></pre>
<p>今天又写到了底部导航，顺带记录一下吧。</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[为什么a标签中使用img后的高度多了几个像素？]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/102</link>
            <guid>https://github.com/xiaotiandada/blog/issues/102</guid>
            <pubDate>Tue, 26 Apr 2022 12:13:46 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://www.zhihu.com/question/26821863">https://www.zhihu.com/question/26821863</a></li>
<li><a href="https://segmentfault.com/q/1010000008659208/a-1020000008659599">https://segmentfault.com/q/1010000008659208/a-1020000008659599</a></li>
<li><a href="https://codeantenna.com/a/kOggMTb8Y0">https://codeantenna.com/a/kOggMTb8Y0</a></li>
</ul>
<p>部分安卓机器 img 没有设置高度，会使用默认长度拉伸。</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[PixiJS]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/101</link>
            <guid>https://github.com/xiaotiandada/blog/issues/101</guid>
            <pubDate>Tue, 26 Apr 2022 05:10:19 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://pixijs.com/">https://pixijs.com/</a></li>
<li><a href="https://reactpixi.org/">https://reactpixi.org/</a></li>
</ul>
<p>一些 Graphics、Sprite，React-Spring 使用。拖动 点击 填充素材等 。</p>
<p>之前项目 SVG 绘制的由于 DOM 太多导致体验不太好。</p>
<p><a href="https://github.com/xiaotiandada/hexagon">https://github.com/xiaotiandada/hexagon</a></p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Next]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/100</link>
            <guid>https://github.com/xiaotiandada/blog/issues/100</guid>
            <pubDate>Fri, 24 Jun 2022 03:27:36 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://nextjs.org/learn/foundations/about-nextjs">https://nextjs.org/learn/foundations/about-nextjs</a></li>
</ul>
<h3>next/image</h3>
<ul>
<li><a href="https://nextjs.org/docs/messages/sharp-missing-in-production">https://nextjs.org/docs/messages/sharp-missing-in-production</a></li>
<li><a href="https://www.npmjs.com/package/sharp">https://www.npmjs.com/package/sharp</a></li>
<li><a href="https://www.npmjs.com/package/@squoosh/lib">https://www.npmjs.com/package/@squoosh/lib</a></li>
</ul>
<h3>SEO</h3>
<ul>
<li><a href="https://nextjs.org/learn/seo/introduction-to-seo">https://nextjs.org/learn/seo/introduction-to-seo</a> （TODO）</li>
<li><a href="https://github.com/garmeeh/next-seo">https://github.com/garmeeh/next-seo</a></li>
<li><a href="https://nextjs.org/docs/advanced-features/measuring-performance">https://nextjs.org/docs/advanced-features/measuring-performance</a></li>
</ul>
<p>next-seo images 参数是一个数组，大部分情况都是使用最后一张作为封面。如果需要特定图片作为封面可只设置一张。</p>
<ul>
<li><a href="https://github.com/xiaotiandada/blog/issues/107">https://github.com/xiaotiandada/blog/issues/107</a> seo 部分可以参考</li>
</ul>
<h3>PWA</h3>
<ul>
<li><a href="https://github.com/shadowwalker/next-pwa">https://github.com/shadowwalker/next-pwa</a></li>
<li><a href="https://lavas-project.github.io/pwa-book/chapter06/1-manifest-json.html">https://lavas-project.github.io/pwa-book/chapter06/1-manifest-json.html</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Add_to_home_screen">https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Add_to_home_screen</a></li>
</ul>
<blockquote>
<p>Tip: Put the viewport head meta tag into _app.js rather than in _document.js if you need it.</p>
</blockquote>
<ul>
<li><a href="https://github.com/shadowwalker/next-pwa/issues/99">https://github.com/shadowwalker/next-pwa/issues/99</a></li>
</ul>
<h3>Layout</h3>
<ul>
<li><a href="https://nextjs.org/docs/basic-features/layouts">https://nextjs.org/docs/basic-features/layouts</a></li>
<li><a href="https://github.com/vercel/next.js/tree/canary/examples/layout-component">https://github.com/vercel/next.js/tree/canary/examples/layout-component</a></li>
<li><a href="https://adamwathan.me/2019/10/17/persistent-layout-patterns-in-nextjs/">https://adamwathan.me/2019/10/17/persistent-layout-patterns-in-nextjs/</a></li>
</ul>
<h3>Vercel</h3>
<p>λ  (Server)  server-side renders at runtime (uses getInitialProps or getServerSideProps)
○  (Static)  automatically rendered as static HTML (uses no initial props)
●  (SSG)     automatically generated as static HTML + JSON (uses getStaticProps)</p>
<blockquote>
<p>Error: No more than 12 Serverless Functions can be added to a Deployment on the Hobby plan. Create a team (Pro plan) to deploy more. Learn More: <a href="https://vercel.link/function-count-limit">https://vercel.link/function-count-limit</a></p>
</blockquote>
<p><a href="https://cant-xt.vercel.app/docs/folder-structure/next">https://cant-xt.vercel.app/docs/folder-structure/next</a> 一些 serverless limit 规则</p>
<h3>Header</h3>
<h4>SharedArrayBuffer</h4>
<ul>
<li><a href="https://nextjs.org/docs/advanced-features/security-headers">https://nextjs.org/docs/advanced-features/security-headers</a></li>
</ul>
<p>嵌入 iframe 需要支持 <code>SharedArrayBuffer</code>, 父级需要定义 header. 一些相关记录</p>
<p>#111
#112
#113</p>
<pre><code class="language-js">[
  {
    key: 'Cross-Origin-Embedder-Policy',
    value: 'require-corp',
  },
  {
    key: 'Cross-Origin-Opener-Policy',
    value: 'same-origin',
  },
]
</code></pre>
<p>iframe 源也开启了会被拒绝链接</p>
<img width="1388" alt="image" src="https://user-images.githubusercontent.com/24250627/172151602-4adaaf23-49c2-410c-bb2e-43b887e68371.png">
<h3>页面</h3>
<img width="612" alt="image" src="https://user-images.githubusercontent.com/24250627/173767739-048b3ce2-7ae8-4f3e-8b98-72aa2beb9877.png">
<p>第一次进入页面会 <code>SSG</code> 渲染页面。但是只在 /game 页面下定义了 header 参数，故首页无参数。</p>
<pre><code>[.   
    {
        source: '/game/:path*',
        headers: COEPHeaders,
      },
      {
        source: '/zh-CN/game/:path*',
        headers: COEPHeaders,
      }
]
</code></pre>
<ul>
<li>如果直接从 /game 路由下进入响应 header</li>
<li>如果从首页/其他页面 进入 /game 路由则不会响应 header</li>
<li>切换页面返回数据 应该是客户端渲染 <code>CSR</code> <a href="https://juejin.cn/post/6925308376976982029">https://juejin.cn/post/6925308376976982029</a>
<ul>
<li><code>/_next/static/chunks/pages/game/%5Bid%5D.js</code> <code>Content-Type: application/javascript; charset=UTF-8</code></li>
<li><code>/_next/data/development/en-US/game/177.json?id=177</code> <code>Content-Type: application/json</code></li>
</ul>
</li>
</ul>
<img width="611" alt="image" src="https://user-images.githubusercontent.com/24250627/173768975-0b53bf95-83bb-42ed-8abd-e4fd22eb3692.png">
<img width="716" alt="image" src="https://user-images.githubusercontent.com/24250627/173769773-b1ba3f05-62d4-4cd9-8e62-172d03ea17b4.png">
<img width="714" alt="image" src="https://user-images.githubusercontent.com/24250627/173769801-8ad794f0-45a6-4402-b233-494fc08886f9.png">
<h2>getStaticProps</h2>
<p><a href="https://nextjs.org/docs/api-reference/data-fetching/get-static-props">https://nextjs.org/docs/api-reference/data-fetching/get-static-props</a></p>
<p>getStaticProps context locale 参数，默认定义为 <code>locale?: string</code>。大概看了一下源码的定义</p>
<p><a href="https://github.com/vercel/next.js/blob/39302141b5ea3a1e9a55af906129a44675337cf9/packages/next/export/index.ts#L375">https://github.com/vercel/next.js/blob/39302141b5ea3a1e9a55af906129a44675337cf9/packages/next/export/index.ts#L375</a></p>
<pre><code class="language-ts">locales: i18n?.locales,
locale: i18n?.defaultLocale,
defaultLocale: i18n?.defaultLocale,
domainLocales: i18n?.domains,
</code></pre>
<p>猜测应该是这里处理的。因为我们定义了 i18n config，locale 使用了 <code>i18n?.defaultLocale</code>  配置。然后会根据 cookie 或 url 路径处理好当前语言环境。</p>
<p>可能返回 <code>en-US | zh-CN</code></p>
<p>可以修改类型消除错误 <code>...(await serverSideTranslations(ctx.locale as string, ['common'])),</code></p>
<h3>webassembly</h3>
<p><a href="https://github.com/vercel/next.js/issues/25852">https://github.com/vercel/next.js/issues/25852</a></p>
<h3>Jest</h3>
<ul>
<li><a href="https://github.com/xiaotiandada/blog/issues/114">https://github.com/xiaotiandada/blog/issues/114</a></li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[Nest]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/99</link>
            <guid>https://github.com/xiaotiandada/blog/issues/99</guid>
            <pubDate>Tue, 21 Jun 2022 10:36:53 GMT</pubDate>
            <description><![CDATA[<h2>class-validator</h2>
<ul>
<li><a href="https://juejin.cn/post/7083505497021612068">class-validator 校验器的使用</a></li>
</ul>
<h2>ValidationPipe</h2>
<blockquote>
<p><a href="https://docs.nestjs.com/techniques/validation#stripping-properties">https://docs.nestjs.com/techniques/validation#stripping-properties</a>
<a href="http://static.kancloud.cn/juukee/nestjs/2675355">http://static.kancloud.cn/juukee/nestjs/2675355</a>
<a href="https://juejin.cn/post/7064595876680826910">https://juejin.cn/post/7064595876680826910</a></p>
</blockquote>
<h3>transform</h3>
<pre><code class="language-ts">app.useGlobalPipes(
    new ValidationPipe({
      transform: true,
    }),
);
</code></pre>
<pre><code class="language-ts">@Get(':id')
findOne(@Param('id') id: number) {
 console.log(typeof id === 'number'); // true
 return 'This action returns a user';
}
</code></pre>
<p>id 会自动从 string 转换成 number</p>
<h3>whitelist</h3>
<pre><code class="language-ts">app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
    }),
);
</code></pre>
<p>true 时，自动删除非白名单属性(在验证类中没有任何修饰符的属性)。</p>
<pre><code class="language-ts">// Bad
// 所有参数都将被过滤
export class CreateCatDto {
  public name: string;

  public age: number;
  
  public breed: string;
}


// Good
import { IsNumber, IsString } from 'class-validator';

export class CreateCatDto {
  @IsString()
  public name: string;

  @IsNumber()
  public age: number;

  @IsString()
  public breed: string;
}
</code></pre>
<h3>typeorm</h3>
<pre><code class="language-bash">    &quot;typeorm&quot;: &quot;^0.3.6&quot;,
    &quot;typeorm&quot;: &quot;0.2.45&quot;,
</code></pre>
<p>0.3.x 按照文档无法工作
0.2.x 按照文档正常工作</p>
<ul>
<li><a href="https://blog.csdn.net/qq_27868061/article/details/79315985">typeorm删除之remove与delete</a></li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[Keyboard API]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/98</link>
            <guid>https://github.com/xiaotiandada/blog/issues/98</guid>
            <pubDate>Mon, 11 Apr 2022 16:34:09 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Keyboard/lock">https://developer.mozilla.org/en-US/docs/Web/API/Keyboard/lock</a></li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[Fullscreen API]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/97</link>
            <guid>https://github.com/xiaotiandada/blog/issues/97</guid>
            <pubDate>Fri, 22 Apr 2022 11:18:18 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API">https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API</a></li>
<li><a href="https://github.com/rafgraph/fscreen/blob/main/src/fscreen.js">https://github.com/rafgraph/fscreen/blob/main/src/fscreen.js</a></li>
<li><a href="https://web.dev/native-hardware-fullscreen/#let-the-user-choose-when-to-go-fullscreen">https://web.dev/native-hardware-fullscreen/#let-the-user-choose-when-to-go-fullscreen</a></li>
</ul>
<p>全屏 IOS 不支持，可以通过 CSS Fixed + PWA 实现比较好的体验</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[React]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/96</link>
            <guid>https://github.com/xiaotiandada/blog/issues/96</guid>
            <pubDate>Wed, 29 Jun 2022 04:06:46 GMT</pubDate>
            <description><![CDATA[<h2>useEffect 在组件挂载时运行两次（StrictMode，NODE_ENV=development）</h2>
<pre><code>...
在严格模式下使用 React 18，`useEffect() that should run only on the initial mount, runs twice!`
...

---

...
React 18 为严格模式引入了一个新的仅限开发的检查。每当第一次安装组件时，此新检查将自动卸载并重新安装每个组件，并在第二次安装时恢复先前的状态。
...
</code></pre>
<h3>Before this change</h3>
<pre><code>* React mounts the component.
    * Layout effects are created.
    * Effect effects are created.
</code></pre>
<h3>With Strict Mode in React 18</h3>
<pre><code>* React mounts the component.
    * Layout effects are created.
    * Effect effects are created.
* React simulates unmounting the component.
    * Layout effects are destroyed.
    * Effects are destroyed.
* React simulates mounting the component with the previous state.
    * Layout effect setup code runs
    * Effect setup code runs
</code></pre>
<p>-<a href="https://github.com/facebook/react/issues/24502">https://github.com/facebook/react/issues/24502</a>
-<a href="https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html#updates-to-strict-mode">https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html#updates-to-strict-mode</a>
-<a href="https://levelup.gitconnected.com/react-18-the-trickiness-of-useeffect-fadfa65fa4b4">https://levelup.gitconnected.com/react-18-the-trickiness-of-useeffect-fadfa65fa4b4</a>
-<a href="https://stackoverflow.com/questions/72238175/react-18-useeffect-is-getting-called-two-times-on-mount">https://stackoverflow.com/questions/72238175/react-18-useeffect-is-getting-called-two-times-on-mount</a></p>
<h2>源码</h2>
<p>介绍全新的 JSX 转换 v17.0 RC</p>
<p><a href="https://zh-hans.reactjs.org/blog/2020/08/10/react-v17-rc.html">https://zh-hans.reactjs.org/blog/2020/08/10/react-v17-rc.html</a>
<a href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html">https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html</a></p>
<p>旧的 JSX 转换将 JSX 转换为React.createElement(...)调用，
新的 JSX 转换不是将 JSX 转换为React.createElement，而是自动从 React 包中的这些新入口点导入特殊函数并调用它们。</p>
<pre><code class="language-tsx">// Inserted by a compiler (don't import it yourself!)
import {jsx as _jsx} from 'react/jsx-runtime';

function App() {
  return _jsx('h1', { children: 'Hello world' });
}
</code></pre>
<pre><code class="language-tsx">&lt;h1 id=&quot;title&quot; key=&quot;title&quot; style={{ width: 100 }} onClick={() =&gt; console.log('onClick')}&gt;hello&lt;span data=&quot;d&quot;&gt;12313&lt;/span&gt;&lt;/h1&gt;
</code></pre>
<pre><code class="language-js">&quot;use strict&quot;;

/*#__PURE__*/
React.createElement(&quot;h1&quot;, {
  id: &quot;title&quot;,
  key: &quot;title&quot;,
  style: {
    width: 100
  },
  onClick: () =&gt; console.log('onClick')
}, &quot;hello&quot;, /*#__PURE__*/React.createElement(&quot;span&quot;, {
  data: &quot;d&quot;
}, &quot;12313&quot;));
</code></pre>
<ul>
<li><a href="https://astexplorer.net/">https://astexplorer.net/</a></li>
<li><a href="https://babeljs.io">https://babeljs.io</a></li>
</ul>
<pre><code class="language-js">export const REACT_ELEMENT_TYPE = Symbol.for(&quot;react.element&quot;);

import { REACT_ELEMENT_TYPE } from &quot;./shared/ReactSymbols&quot;;

const RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true,
};

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */
const ReactElement = function (type, key, ref, self, source, owner, props) {
  const element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner,
    _store: {},
    _self: self,
    _source: source,
  };

  return element;
};

export function createElement(type, config, children) {
  // Reserved names are extracted
  const props = {};

  let key = null;
  let ref = null;
  let self = null;
  let source = null;

  if (config != null) {
    key = &quot;&quot; + config.key;

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (const proName in config) {
      if (
        Object.hasOwnProperty.call(config, proName) &amp;&amp;
        !RESERVED_PROPS.hasOwnProperty(proName)
      ) {
        props[proName] = config[proName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  const childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength &gt; 1) {
    const childArray = Array(childrenLength);
    for (let i = 0; i &lt; childArray.length; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  const _owner = null;
  return ReactElement(type, key, ref, self, source, _owner, props);
}

</code></pre>
<pre><code class="language-js">const emptyObject = {};

/**
 * Base class helpers for the updating state of a component.
 */
export function Component(props) {
  this.props = props;
  this.refs = emptyObject;
}

Component.prototype.isReactComponent = {};
</code></pre>
<pre><code class="language-jsx">class PureComponents extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    console.log(&quot;nextProps&quot;, nextProps, nextState);
    return (
      shallowEqual(nextProps, this.props) &amp;&amp; shallowEqual(nextState, this.state)
    );
  }
}

function shallowEqual(object1, object2) {
  if (object1 === object2) {
    return true;
  }

  if (
    typeof object1 !== &quot;object&quot; ||
    object1 === null ||
    object2 !== &quot;object&quot; ||
    object2 === null
  ) {
    return false;
  }

  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);

  if (keys1.length !== keys2.length) {
    return false;
  }

  for (let i = 0; i &lt; keys1.length; i++) {
    if (
      !hasOwnProperty.call(object2, keys1[i]) ||
      object1[keys1[i]] !== object2[keys1[i]]
    ) {
      return false;
    }
  }

  return true;
}
</code></pre>
<h3>React16废弃了哪些生命周期？为什么？</h3>
<ul>
<li><a href="https://blog.csdn.net/weixin_43392489/article/details/121438376">https://blog.csdn.net/weixin_43392489/article/details/121438376</a></li>
</ul>
<p>React16废弃的生命周期有3个will：
componentWillMount
componentWillReceiveProps
componentWillUpdate</p>
<h2>v16.13.1</h2>
<h3>createElement</h3>
<pre><code class="language-tsx">import { REACT_ELEMENT_TYPE } from '../../shared/ReactSymbols';

const hasOwnProperty = Object.prototype.hasOwnProperty;

const RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true,
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
export function createElement(type: any, config: any, children: any) {
  /**
   * propName -&gt; 属性名称
   * 用于后面的 for 循环
   */
  let propName: any;

  /**
   * 存储 React Element 中的普通元素属性 即不包含 key ref self source
   */
  // Reserved names are extracted
  const props: { [key: string]: any } = {};

  /**
   * 待提取属性
   * React 内部为了实现某些功能而存在的属性
   */
  let key = null;
  let ref = null;
  let self = null;
  let source = null;

  // 如果 config 不为 null
  if (config !== null) {
    // 如果 config 对象中有合法的 ref 属性
    if (hasValidRef(config)) {
      // 将 config.ref 属性提取到 ref 变量中
      ref = config.ref;
    }
    // 如果在 config 对象中拥有合法的 key 属性
    if (hasValidKey(config)) {
      // 将 config.key 属性中的值提取到 key 变量中
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;

    // 遍历 config 对象
    // Remaining properties are added to a new props object
    for (propName in config) {
      // 如果当前遍历到的属性是对象自身属性
      // 并且在 RESERVED_PROPS 对象中不存在该属性
      if (
        hasOwnProperty.call(config, propName) &amp;&amp;
        !RESERVED_PROPS.hasOwnProperty(propName)
      ) {
        // 将满足条件的属性添加到 props 对象中 (普通属性)
        props[propName] = config[propName];
      }
    }
  }

  /**
   * 将第三个及之后的参数挂载到 props.children 属性中
   * 如果子元素是多个 props.children 是数组
   * 如果子元素是一个 props.children 是对象
   */

  // 由于从第三个参数开始及以后都表示子元素
  // 所以减去前两个参数的结果就是子元素的数量

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  const childrenLength = arguments.length - 2;
  // 如果子元素的数量是 1
  if (childrenLength === 1) {
    // 直接将子元素挂载到到 props.children 属性上
    // 此时 children 是对象类型
    props.children = children;
    // 如果子元素的数量大于 1
  } else if (childrenLength &gt; 1) {
    // 创建数组, 数组中元素的数量等于子元素的数量
    const childArray = Array(childrenLength);
    // 开启循环 循环次匹配子元素的数量
    for (let i = 0; i &lt; childrenLength; i++) {
      // 将子元素添加到 childArray 数组中
      // i + 2 的原因是实参集合的前两个参数不是子元素
      childArray[i] = arguments[i + 2];
    }

    // 将子元素数组挂载到 props.children 属性中
    props.children = childArray;
  }

  /**
   * 如果当前处理是组件
   * 看组件身上是否有 defaultProps 属性
   * 这个属性中存储的是 props 对象中属性的默认值
   * 遍历 defaultProps 对象 查看对应的 props 属性的值是否为 undefined
   * 如果为undefined 就将默认值赋值给对应的 props 属性值
   */

  // Resolve default props
  if (type &amp;&amp; type.defaultProps) {
    const defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    null, // ReactCurrentOwner.current,
    props
  );
}
</code></pre>
<h3>ReactElement</h3>
<pre><code class="language-tsx">// 接收参数 返回 ReactElement
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */
const ReactElement = function (
  type: any,
  key: any,
  ref: any,
  self: any,
  source: any,
  owner: any,
  props: any
) {
  const element = {
    /**
     * 组件的类型, 十六进制数值或者 Symbol 值
     * React 在最终在渲染 DOM 的时候, 需要确保元素的类型是 REACT_ELEMENT_TYPE
     * 需要此属性作为判断的依据
     */
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    /**
     * 元素具体的类型值 如果是元素节点 type 属性中存储的就是 div span 等等
     * 如果元素是组件 type 属性中存储的就是组件的构造函数
     */
    // Built-in properties that belong on the element
    type: type,
    /**
     * 元素的唯一标识
     * 用作内部 vdom 比对 提升 DOM 操作性能
     */
    key: key,
    /**
     * 存储元素 DOM 对象或者组件 实例对象
     */
    ref: ref,
    /**
     * 存储向组件内部传递的数据
     */
    props: props,

    /**
     * 记录当前元素所属组件 (记录当前元素是哪个组件创建的)
     */
    // Record the component responsible for creating this element.
    _owner: owner,
  };

  // 返回 ReactElement
  return element;
};
</code></pre>
<h3>hasValidRef</h3>
<pre><code class="language-tsx">/**
 * 查看参数对象中是否有合法的 ref 属性
 * 返回布尔值
 */
function hasValidRef(config: any) {
  return config.ref !== undefined;
}
</code></pre>
<h3>hasValidKey</h3>
<pre><code class="language-tsx">/**
 * 查看参数对象中是否有合法的 key 属性
 * 返回布尔值
 */
function hasValidKey(config: any) {
  return config.key !== undefined;
}
</code></pre>
<h3>isValidElement</h3>
<pre><code class="language-tsx">/**
 * 验证 object 参数是否是 ReactElement. 返回布尔值
 * 验证成功的条件:
 * object 是对象
 * object 不为null
 * object对象中的 $$typeof 属性值为 REACT_ELEMENT_TYPE
 *
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */
export function isValidElement(object: { [key: string]: any }) {
  return (
    typeof object === 'object' &amp;&amp;
    object !== null &amp;&amp;
    object.$$typeof === REACT_ELEMENT_TYPE
  );
}
</code></pre>
<h3>defineKeyPropWarningGetter</h3>
<h3>defineRefPropWarningGetter</h3>
<pre><code class="language-tsx">let specialPropKeyWarningShown: boolean;
let specialPropRefWarningShown: boolean;

/**
 *  指定当通过 props 对象获取 key 属性时报错
 *  props        组件中的 props 对象
 *  displayName  组件名称标识
 */
function defineKeyPropWarningGetter(
  props: { [key: string]: any },
  displayName: string
) {
  // 通过 props 对象获取 key 属性报错
  const warnAboutAccessingKey = function () {
    // 在开发环境中
    if (__DEV__) {
      // specialPropKeyWarningShown 控制错误只输出一次的变量
      if (!specialPropKeyWarningShown) {
        // 通过 specialPropKeyWarningShown 变量锁住判断条件
        specialPropKeyWarningShown = true;
        // 指定报错信息和组件名称
        console.error(
          '%s: `key` is not a prop. Trying to access it will result ' +
            'in `undefined` being returned. If you need to access the same ' +
            'value within the child component, you should pass it as a different ' +
            'prop. (https://fb.me/react-special-props)',
          displayName
        );
      }
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  // 为 props 对象添加 key 属性
  Object.defineProperty(props, 'key', {
    // 当获取 key 属性时调用 warnAboutAccessingKey 方法进行报错
    get: warnAboutAccessingKey,
    configurable: true,
  });
}

/**
 *  指定当通过 props 对象获取 ref 属性时报错
 *  props        组件中的 props 对象
 *  displayName  组件名称标识
 */
function defineRefPropWarningGetter(
  props: { [key: string]: any },
  displayName: string
) {
  // 通过 props 对象获取 ref 属性报错
  const warnAboutAccessingRef = function () {
    if (__DEV__) {
      // specialPropRefWarningShown 控制错误只输出一次的变量
      if (!specialPropRefWarningShown) {
        // 通过 specialPropRefWarningShown 变量锁住判断条件
        specialPropRefWarningShown = true;
        // 指定报错信息和组件名称
        console.error(
          '%s: `ref` is not a prop. Trying to access it will result ' +
            'in `undefined` being returned. If you need to access the same ' +
            'value within the child component, you should pass it as a different ' +
            'prop. (https://fb.me/react-special-props)',
          displayName
        );
      }
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  // 为 props 对象添加 key 属性
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true,
  });
}

const props = { ref: 'ref', key: 'key' };
defineKeyPropWarningGetter(props, 'key');
defineRefPropWarningGetter(props, 'ref');

props.key;
props.ref;

// key: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop.

// ref: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. 
</code></pre>
<h3>Render</h3>
<pre><code class="language-tsx">/**
 * 渲染入口
 * element 要进行渲染的 ReactElement, createElement 方法的返回值
 * container 渲染容器 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
 * callback 渲染完成后执行的回调函数
 */
export function render(
  element: any,
  container: Container,
  callback?: Function
) {
  console.log('render', element, container, callback);

  // 检测 container 是否是符合要求的渲染容器
  // 即检测 container 是否是真实的DOM对象
  // 如果不符合要求就报错
  invariant(
    isValidContainer(container),
    'Target container is not a DOM element.'
  );

  return legacyRenderSubtreeIntoContainer(
    // 父组件 初始渲染没有父组件 传递 null 占位
    null,
    element,
    container,
    // 是否为服务器端渲染 false 不是服务器端渲染 true 是服务器端渲染
    false,
    callback
  );
}
</code></pre>
<h3>isValidContainer</h3>
<pre><code class="language-tsx">/**
 * 判断 node 是否是符合要求的 DOM 节点
 * 1. node 可以是元素节点
 * 2. node 可以是 document 节点
 * 3. node 可以是 文档碎片节点
 * 4. node 可以是注释节点但注释内容必须是 react-mount-point-unstable
 * 		react 内部会找到注释节点的父级 通过调用父级元素的 insertBefore 方法, 将 element 插入到注释节点的前面
 *
 * https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType
 */
export function isValidContainer(node: any): boolean {
  return !!(
    node &amp;&amp;
    (node.nodeType === ELEMENT_NODE ||
      node.nodeType === DOCUMENT_NODE ||
      node.nodeType === DOCUMENT_FRAGMENT_NODE ||
      (node.nodeType === COMMENT_NODE &amp;&amp;
        (node as any).nodeValue === ' react-mount-point-unstable '))
  );
}
</code></pre>
<h3>react-mount-point-unstable</h3>
<ul>
<li>
<p><a href="https://github.com/facebook/react/issues/17547">https://github.com/facebook/react/issues/17547</a></p>
</li>
<li>
<p><a href="https://codesandbox.io/s/react-comment-node-as-root-element-2bqz8?file=/src/index.js:179-197">https://codesandbox.io/s/react-comment-node-as-root-element-2bqz8?file=/src/index.js:179-197</a></p>
</li>
</ul>
<img width="1280" alt="image" src="https://user-images.githubusercontent.com/24250627/172046543-d4279aff-7979-4552-b731-f31297fdbd9b.png">
<h3>isValidContainer</h3>
<pre><code class="language-tsx">/**
 *
 * @param node mixed
 *
 * 判断 node 是否是符合要求的 DOM 节点
 * 1. node 可以是元素节点
 * 2. node 可以是 document 节点
 * 3. node 可以是 文档碎片节点
 * 4. node 可以是注释节点但注释内容必须是 react-mount-point-unstable
 * 		react 内部会找到注释节点的父级 通过调用父级元素的 insertBefore 方法, 将 element 插入到注释节点的前面
 *
 * https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType
 */
export function isValidContainer(node: any): boolean {
  return !!(
    node &amp;&amp;
    (node.nodeType === ELEMENT_NODE ||
      node.nodeType === DOCUMENT_NODE ||
      node.nodeType === DOCUMENT_FRAGMENT_NODE ||
      (node.nodeType === COMMENT_NODE &amp;&amp;
        (node as any).nodeValue === ' react-mount-point-unstable '))
  );
}
</code></pre>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1916681">https://cloud.tencent.com/developer/article/1916681</a></li>
</ul>
<blockquote>
<h4><strong>react启动的模式</strong></h4>
<p>react有3种模式进入主体函数的入口，我们可以从 react官方文档 <a href="https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#feature-comparison"><strong>使用 Concurrent 模式（实验性）</strong></a>中对比三种模式：</p>
<ul>
<li><strong>legacy 模式：</strong> <code>ReactDOM.render(&lt;App /&gt;, rootNode)</code>。这是当前 React app 使用的方式。当前没有计划删除本模式，但是这个模式可能不支持这些新功能。</li>
<li><strong>blocking 模式：</strong> <code>ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code>。目前正在实验中。作为迁移到 concurrent 模式的第一个步骤。</li>
<li><strong>concurrent 模式：</strong> <code>ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code>。目前在实验中，未来稳定之后，打算作为 React 的默认开发模式。这个模式开启了<em>所有的</em>新功能。</li>
</ul>
</blockquote>
<h3>render</h3>
<pre><code class="language-tsx">/**
 * 渲染入口
 * element 要进行渲染的 ReactElement, createElement 方法的返回值
 * container 渲染容器 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
 * callback 渲染完成后执行的回调函数
 */
export function render(
  element: any,
  container: Container,
  callback?: Function
) {
  console.log('render', element, container, callback);

  // 检测 container 是否是符合要求的渲染容器
  // 即检测 container 是否是真实的DOM对象
  // 如果不符合要求就报错
  invariant(
    isValidContainer(container),
    'Target container is not a DOM element.'
  );

  return legacyRenderSubtreeIntoContainer(
    // 父组件 初始渲染没有父组件 传递 null 占位
    null,
    element,
    container,
    // 是否为服务器端渲染 false 不是服务器端渲染 true 是服务器端渲染
    false,
    callback
  );
}
</code></pre>
<h3>legacyCreateRootFromDOMContainer</h3>
<pre><code class="language-tsx">/**
 * 判断是否为服务器端渲染 如果不是服务器端渲染
 * 清空 container 容器中的节点
 */
function legacyCreateRootFromDOMContainer(
  container: Container,
  forceHydrate: boolean
): RootType {
  // container =&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
  // 检测是否为服务器端渲染
  const shouldHydrate =
    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);

  console.log('shouldHydrate', shouldHydrate);
  console.log('container', container);

  // First clear any existing content.
  // 如果不是服务器端渲染
  if (!shouldHydrate) {
    let warned = false;
    let rootSibling;
    // 开启循环 删除 container 容器中的节点
    while ((rootSibling = container.lastChild)) {
      if (__DEV__) {
        if (
          !warned &amp;&amp;
          rootSibling.nodeType === ELEMENT_NODE &amp;&amp;
          (rootSibling as any).hasAttribute(ROOT_ATTRIBUTE_NAME)
        ) {
          warned = true;
          console.error(
            'render(): Target node has markup rendered by React, but there ' +
              'are unrelated nodes as well. This is most commonly caused by ' +
              'white-space inserted around server-rendered markup.'
          );
        }
      }
      // 删除 container 容器中的节点
      container.removeChild(rootSibling);
      /**
       * 为什么要清除 container 中的元素 ?
       * 为提供首屏加载的用户体验, 有时需要在 container 中放置一些占位图或者 loading 图
       * 就无可避免的要向 container 中加入 html 标记.
       * 在将 ReactElement 渲染到 container 之前, 必然要先清空 container
       * 因为占位图和 ReactElement 不能同时显示
       *
       * 在加入占位代码时, 最好只有一个父级元素, 可以减少内部代码的循环次数以提高性能
       * &lt;div&gt;
       *  &lt;p&gt;placement&lt;p&gt;
       *  &lt;p&gt;placement&lt;p&gt;
       *  &lt;p&gt;placement&lt;p&gt;
       * &lt;/div&gt;
       */
    }
  }

  if (__DEV__) {
    if (shouldHydrate &amp;&amp; !forceHydrate &amp;&amp; !warnedAboutHydrateAPI) {
      warnedAboutHydrateAPI = true;
      console.warn(
        'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +
          'will stop working in React v17. Replace the ReactDOM.render() call ' +
          'with ReactDOM.hydrate() if you want React to attach to the server HTML.'
      );
    }
  }

  return createLegacyRoot(
    container,
    shouldHydrate
      ? {
          hydrate: true,
        }
      : undefined
  );
}
</code></pre>
<h3>createLegacyRoot</h3>
<pre><code class="language-tsx">export function createLegacyRoot(
  container: Container,
  options?: RootOptions
): RootType {
  // container =&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
  // LegacyRoot 常量, 值为 0,
  // 通过 render 方法创建的 container 就是 LegacyRoot
  return new (ReactDOMBlockingRoot as any)(container, LegacyRoot, options);
}
</code></pre>
<h3>ReactDOMBlockingRoot</h3>
<pre><code class="language-ts">/**
 * 类, 通过它可以创建 LegacyRoot 的 Fiber 数据结构
 */
function ReactDOMBlockingRoot(
  container: Container,
  tag: RootTag,
  options: void | RootOptions
) {
  // tag =&gt; 0 =&gt; legacyRoot
  // container =&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
  // container._reactRootContainer = {_internalRoot: {}}
  this._internalRoot = createRootImpl(container, tag, options);
}
</code></pre>
<h3>createRootImpl</h3>
<pre><code class="language-ts">function createRootImpl(
  container: Container,
  tag: RootTag,
  options: void | RootOptions
) {
  console.log('createRootImpl', container, tag, options);
  const hydrate = false;
  const hydrationCallbacks: any = null;

  // container =&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
  // tag =&gt; 0
  // options =&gt; undefined
  const root = createContainer(container, tag, hydrate, hydrationCallbacks);
  // markContainerAsRoot(root.current, container);
  return root;
}
</code></pre>
<h3>createContainer</h3>
<pre><code class="language-ts">export function createContainer(
  containerInfo: Container,
  tag: RootTag,
  hydrate: boolean,
  hydrationCallbacks: null
): OpaqueRoot {
  // containerInfo =&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
  // tag: 0
  // hydrate: false
  // hydrationCallbacks: null
  // 忽略了和服务器端渲染相关的内容
  return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);
}
</code></pre>
<h3>createFiberRoot</h3>
<pre><code class="language-ts">// 创建根节点对应的 fiber 对象
export function createFiberRoot(
  containerInfo: any,
  tag: RootTag,
  hydrate: boolean,
  hydrationCallbacks: null
): FiberRoot {
  // 创建 FiberRoot
  const root: FiberRoot = new (FiberRootNode as any)(
    containerInfo,
    tag,
    hydrate
  ) as any;

  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  // 创建根节点对应的 rootFiber
  const uninitializedFiber = createHostRootFiber(tag);
  // 为 fiberRoot 添加 current 属性 值为 rootFiber
  root.current = uninitializedFiber;
  // 为 rootFiber 添加 stateNode 属性 值为 fiberRoot
  uninitializedFiber.stateNode = root;

  // 返回 root
  return root;
}
</code></pre>
<h3>FiberRootNode</h3>
<pre><code class="language-ts">function FiberRootNode(containerInfo: any, tag: RootTag, hydrate: boolean) {
  this.tag = tag;
  this.current = null;
  this.containerInfo = containerInfo;
  this.pendingChildren = null;
  this.pingCache = null;
  this.finishedExpirationTime = NoWork;
  this.finishedWork = null;
  this.timeoutHandle = noTimeout;
  this.context = null;
  this.pendingContext = null;
  this.hydrate = hydrate;
  this.callbackNode = null;
  this.callbackPriority = NoPriority;
  this.firstPendingTime = NoWork;
  this.firstSuspendedTime = NoWork;
  this.lastSuspendedTime = NoWork;
  this.nextKnownPendingLevel = NoWork;
  this.lastPingedTime = NoWork;
  this.lastExpiredTime = NoWork;

  if (enableSchedulerTracing) {
    // this.interactionThreadID = unstable_getThreadID();
    this.interactionThreadID = 0;
    this.memoizedInteractions = new Set();
    this.pendingInteractionMap = new Map();
  }
  if (enableSuspenseCallback) {
    this.hydrationCallbacks = null;
  }
}
</code></pre>
<h3>createHostRootFiber</h3>
<pre><code class="language-ts">export function createHostRootFiber(tag: RootTag): Fiber {
  let mode = NoMode;
  return createFiber(HostRoot, null, null, mode);
}
</code></pre>
<h3>createFiber</h3>
<pre><code class="language-ts">const createFiber = function(
  tag: WorkTag,
  pendingProps: any,
  key: null | string,
  mode: TypeOfMode,
): Fiber {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new (FiberNode as any)(tag, pendingProps, key, mode);
};
</code></pre>
<h3>FiberNode</h3>
<pre><code class="language-ts">function FiberNode(
  tag: WorkTag,
  pendingProps: any,
  key: null | string,
  mode: TypeOfMode,
) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;
	...
}
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[TypeScript]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/95</link>
            <guid>https://github.com/xiaotiandada/blog/issues/95</guid>
            <pubDate>Wed, 29 Jun 2022 10:51:34 GMT</pubDate>
            <description><![CDATA[<h2>映射类型</h2>
<h3>只读 冻结</h3>
<ul>
<li><a href="https://github.com/remix-run/history/blob/dev/packages/history/index.ts#L320-L322">https://github.com/remix-run/history/blob/dev/packages/history/index.ts#L320-L322</a></li>
<li><a href="https://github.com/Microsoft/TypeScript/blob/0a535f0bf7193741e6b4acf5b7dfea88e2d4beca/lib/lib.d.ts#L1379-L1405">https://github.com/Microsoft/TypeScript/blob/0a535f0bf7193741e6b4acf5b7dfea88e2d4beca/lib/lib.d.ts#L1379-L1405</a></li>
<li><a href="https://mariusschulz.com/blog/mapped-types-in-typescript">https://mariusschulz.com/blog/mapped-types-in-typescript</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/mapped-types.html">https://www.typescriptlang.org/docs/handbook/2/mapped-types.html</a></li>
<li><a href="https://www.fullstackbb.com/typescript/readonly-in-typescript/">https://www.fullstackbb.com/typescript/readonly-in-typescript/</a></li>
</ul>
<pre><code class="language-ts">/**
 * Make all properties in T readonly
 */
type Readonly&lt;T&gt; = {
    readonly [P in keyof T]: T[P];
};

const readOnly: &lt;T&gt;(obj: T) =&gt; Readonly&lt;T&gt; = __DEV__
  ? (obj) =&gt; Object.freeze(obj)
  : (obj) =&gt; obj;

readOnly&lt;Location&gt;({ })

</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[UI Swap]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/94</link>
            <guid>https://github.com/xiaotiandada/blog/issues/94</guid>
            <pubDate>Thu, 24 Mar 2022 09:39:08 GMT</pubDate>
            <description><![CDATA[<p>Swap allows you to toggle the visibility of two elements using a checkbox or a class name.</p>
<h3>Swap icons with rotate effect</h3>
<p><a href="https://codesandbox.io/embed/swap-swap-rotate-bieux9?fontsize=14&amp;hidenavigation=1&amp;theme=dark">https://codesandbox.io/embed/swap-swap-rotate-bieux9?fontsize=14&amp;hidenavigation=1&amp;theme=dark</a></p>
<img width="520" alt="image" src="https://user-images.githubusercontent.com/24250627/159887410-b8f39a91-bedb-4cc2-855b-753554e63cfd.png">
<pre><code class="language-TSX">import &quot;./styles.css&quot;;

export default function App() {
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;h1&gt;Hello CodeSandbox&lt;/h1&gt;
      &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt;
      &lt;div&gt;
        &lt;label className=&quot;swap swap-rotate&quot;&gt;
          &lt;input type=&quot;checkbox&quot; /&gt;
          &lt;svg
            className=&quot;w-6 h-6 fill-current swap-on&quot;
            style={{ width: 28, height: 28 }}
            xmlns=&quot;http://www.w3.org/2000/svg&quot;
            viewBox=&quot;0 0 24 24&quot;
          &gt;
            &lt;path d=&quot;M5.64,17l-.71.71a1,1,0,0,0,0,1.41,1,1,0,0,0,1.41,0l.71-.71A1,1,0,0,0,5.64,17ZM5,12a1,1,0,0,0-1-1H3a1,1,0,0,0,0,2H4A1,1,0,0,0,5,12Zm7-7a1,1,0,0,0,1-1V3a1,1,0,0,0-2,0V4A1,1,0,0,0,12,5ZM5.64,7.05a1,1,0,0,0,.7.29,1,1,0,0,0,.71-.29,1,1,0,0,0,0-1.41l-.71-.71A1,1,0,0,0,4.93,6.34Zm12,.29a1,1,0,0,0,.7-.29l.71-.71a1,1,0,1,0-1.41-1.41L17,5.64a1,1,0,0,0,0,1.41A1,1,0,0,0,17.66,7.34ZM21,11H20a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2Zm-9,8a1,1,0,0,0-1,1v1a1,1,0,0,0,2,0V20A1,1,0,0,0,12,19ZM18.36,17A1,1,0,0,0,17,18.36l.71.71a1,1,0,0,0,1.41,0,1,1,0,0,0,0-1.41ZM12,6.5A5.5,5.5,0,1,0,17.5,12,5.51,5.51,0,0,0,12,6.5Zm0,9A3.5,3.5,0,1,1,15.5,12,3.5,3.5,0,0,1,12,15.5Z&quot; /&gt;
          &lt;/svg&gt;
          &lt;svg
            className=&quot;w-6 h-6 fill-current swap-off&quot;
            style={{ width: 28, height: 28 }}
            xmlns=&quot;http://www.w3.org/2000/svg&quot;
            viewBox=&quot;0 0 24 24&quot;
          &gt;
            &lt;path d=&quot;M21.64,13a1,1,0,0,0-1.05-.14,8.05,8.05,0,0,1-3.37.73A8.15,8.15,0,0,1,9.08,5.49a8.59,8.59,0,0,1,.25-2A1,1,0,0,0,8,2.36,10.14,10.14,0,1,0,22,14.05,1,1,0,0,0,21.64,13Zm-9.5,6.69A8.14,8.14,0,0,1,7.08,5.22v.27A10.15,10.15,0,0,0,17.22,15.63a9.79,9.79,0,0,0,2.1-.22A8.11,8.11,0,0,1,12.14,19.73Z&quot; /&gt;
          &lt;/svg&gt;
        &lt;/label&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

</code></pre>
<pre><code class="language-css">.swap {
  position: relative;
  display: inline-grid;
  user-select: none;
  place-content: center;
  cursor: pointer;
}
.swap &gt; * {
  grid-column-start: 1;
  grid-row-start: 1;
  transition-property: all;
  transition-duration: 0.3s;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}
.swap input {
  appearance: none;
}

.swap input[type=&quot;checkbox&quot;] ~ .swap-on,
.swap input[type=&quot;checkbox&quot;]:checked ~ .swap-off {
  opacity: 0;
}

.swap input[type=&quot;checkbox&quot;] ~ .swap-off,
.swap input[type=&quot;checkbox&quot;]:checked ~ .swap-on {
  opacity: 1;
}

.swap-rotate input[type=&quot;checkbox&quot;]:checked ~ .swap-on {
  transform: rotate(0deg);
}
.swap-rotate input[type=&quot;checkbox&quot;]:checked ~ .swap-off {
  transform: rotate(-45deg);
}

.swap-rotate input[type=&quot;checkbox&quot;] ~ .swap-on {
  transform: rotate(45deg);
}

</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[Git 删除敏感数据]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/93</link>
            <guid>https://github.com/xiaotiandada/blog/issues/93</guid>
            <pubDate>Tue, 22 Mar 2022 10:39:01 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://docs.github.com/cn/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository">https://docs.github.com/cn/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository</a></li>
<li><a href="https://rtyley.github.io/bfg-repo-cleaner/">https://rtyley.github.io/bfg-repo-cleaner/</a></li>
<li><a href="https://dev.to/toureholder/removing-sensitive-data-from-your-git-history-with-bfg-4ni4">https://dev.to/toureholder/removing-sensitive-data-from-your-git-history-with-bfg-4ni4</a></li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[Uniswap Info 学习]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/92</link>
            <guid>https://github.com/xiaotiandada/blog/issues/92</guid>
            <pubDate>Mon, 21 Mar 2022 14:33:19 GMT</pubDate>
            <description><![CDATA[<ul>
<li>
<p><a href="https://info.uniswap.org">https://info.uniswap.org</a></p>
</li>
<li>
<p><a href="https://github.com/Uniswap/v3-info">https://github.com/Uniswap/v3-info</a></p>
</li>
<li>
<p><a href="https://github.com/xiaotiandada/vv-info">https://github.com/xiaotiandada/vv-info</a></p>
</li>
<li>
<p>uniswap/uniswap-v3/graphql - <a href="https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3/graphql">https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3/graphql</a></p>
</li>
<li>
<p>blocklytics/ethereum-blocks - <a href="https://api.thegraph.com/subgraphs/name/blocklytics/ethereum-blocks">https://api.thegraph.com/subgraphs/name/blocklytics/ethereum-blocks</a></p>
</li>
</ul>
<h3>查询 Tokens</h3>
<p>/uniswap/uniswap-v3/graphql</p>
<pre><code>{
  tokens {
    id,
    symbol,
    name
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;tokens&quot;: [
      {
        &quot;id&quot;: &quot;0x00000000000045166c45af0fc6e4cf31d9e14b9a&quot;,
        &quot;symbol&quot;: &quot;BID&quot;,
        &quot;name&quot;: &quot;TopBidder&quot;
      },
			// ...
    ]
  }
}
</code></pre>
<h3>查询 topPools</h3>
<pre><code>query topPools {
  tokens(
    first: 50
    orderBy: totalValueLockedUSD
    orderDirection: desc
    subgraphError: allow
  ) {
    id
    name
    symbol
    __typename
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;tokens&quot;: [
      {
        &quot;id&quot;: &quot;0x12b32f10a499bf40db334efe04226cca00bf2d9b&quot;,
        &quot;name&quot;: &quot;UMIIE COIN&quot;,
        &quot;symbol&quot;: &quot;UMIIE&quot;,
        &quot;__typename&quot;: &quot;Token&quot;
      },
      {
        &quot;id&quot;: &quot;0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2&quot;,
        &quot;name&quot;: &quot;Wrapped Ether&quot;,
        &quot;symbol&quot;: &quot;WETH&quot;,
        &quot;__typename&quot;: &quot;Token&quot;
      },
      // ...
    ]
  }
}
</code></pre>
<h3>查询 Tokens</h3>
<pre><code>query tokens {
  tokens(
    where: {id_in: [&quot;0x12b32f10a499bf40db334efe04226cca00bf2d9b&quot;, &quot;0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2&quot;, &quot;0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48&quot;]}
    block: {number: 14423607}
    orderBy: totalValueLockedUSD
    orderDirection: desc
    subgraphError: allow
  ) {
    id
    symbol
    name
    derivedETH
    volumeUSD
    volume
    txCount
    totalValueLocked
    feesUSD
    totalValueLockedUSD
    __typename
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;tokens&quot;: [
      {
        &quot;id&quot;: &quot;0x12b32f10a499bf40db334efe04226cca00bf2d9b&quot;,
        &quot;symbol&quot;: &quot;UMIIE&quot;,
        &quot;name&quot;: &quot;UMIIE COIN&quot;,
        &quot;derivedETH&quot;: &quot;0.1003902793538328620619869326124331&quot;,
        &quot;volumeUSD&quot;: &quot;1511.56963205356389982056338569223&quot;,
        &quot;volume&quot;: &quot;1000108.86838829453580011&quot;,
        &quot;txCount&quot;: &quot;56&quot;,
        &quot;totalValueLocked&quot;: &quot;4060050843.47631394922014061&quot;,
        &quot;feesUSD&quot;: &quot;4.103789417232335009489830669286369&quot;,
        &quot;totalValueLockedUSD&quot;: &quot;1197081242711.1943889376370393552&quot;,
        &quot;__typename&quot;: &quot;Token&quot;
      },
      {
        &quot;id&quot;: &quot;0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2&quot;,
        &quot;symbol&quot;: &quot;WETH&quot;,
        &quot;name&quot;: &quot;Wrapped Ether&quot;,
        &quot;derivedETH&quot;: &quot;1&quot;,
        &quot;volumeUSD&quot;: &quot;394329036941.5623654027733304210331&quot;,
        &quot;volume&quot;: &quot;125103787.712591104192372425&quot;,
        &quot;txCount&quot;: &quot;10826685&quot;,
        &quot;totalValueLocked&quot;: &quot;441402.825574432888969787&quot;,
        &quot;feesUSD&quot;: &quot;766412514.4017064014764513833224189&quot;,
        &quot;totalValueLockedUSD&quot;: &quot;1271992049.856639541792290053439463&quot;,
        &quot;__typename&quot;: &quot;Token&quot;
      },
      {
        &quot;id&quot;: &quot;0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48&quot;,
        &quot;symbol&quot;: &quot;USDC&quot;,
        &quot;name&quot;: &quot;USD Coin&quot;,
        &quot;derivedETH&quot;: &quot;0.00034701696887506600425180887192684&quot;,
        &quot;volumeUSD&quot;: &quot;277035127783.0198627557171409059903&quot;,
        &quot;volume&quot;: &quot;277026881311.261403&quot;,
        &quot;txCount&quot;: &quot;3156306&quot;,
        &quot;totalValueLocked&quot;: &quot;1006710296.623717&quot;,
        &quot;feesUSD&quot;: &quot;305659059.6247657073983772200408159&quot;,
        &quot;totalValueLockedUSD&quot;: &quot;1006710296.623717&quot;,
        &quot;__typename&quot;: &quot;Token&quot;
      }
    ]
  }
}
</code></pre>
<h3>查询 blocks</h3>
<pre><code>query blocks {
  t1647783480: blocks(
    first: 1
    orderBy: timestamp
    orderDirection: desc
    where: {timestamp_gt: 1647783480, timestamp_lt: 1647784080}
  ) {
    number
    __typename
  }
  t1647697080: blocks(
    first: 1
    orderBy: timestamp
    orderDirection: desc
    where: {timestamp_gt: 1647697080, timestamp_lt: 1647697680}
  ) {
    number
    __typename
  }
  t1647265080: blocks(
    first: 1
    orderBy: timestamp
    orderDirection: desc
    where: {timestamp_gt: 1647265080, timestamp_lt: 1647265680}
  ) {
    number
    __typename
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;t1647783480&quot;: [
      {
        &quot;number&quot;: &quot;14423607&quot;,
        &quot;__typename&quot;: &quot;Block&quot;
      }
    ],
    &quot;t1647697080&quot;: [
      {
        &quot;number&quot;: &quot;14417197&quot;,
        &quot;__typename&quot;: &quot;Block&quot;
      }
    ],
    &quot;t1647265080&quot;: [
      {
        &quot;number&quot;: &quot;14385081&quot;,
        &quot;__typename&quot;: &quot;Block&quot;
      }
    ]
  }
}
</code></pre>
<h3>查询 pools</h3>
<pre><code>query pools {
  pools(
    where: {id_in: [&quot;0xa850478adaace4c08fc61de44d8cf3b64f359bec&quot;, &quot;0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8&quot;]}
    orderBy: totalValueLockedUSD
    orderDirection: desc
    subgraphError: allow
  ) {
    id
    feeTier
    liquidity
    sqrtPrice
    tick
    token0 {
      id
      symbol
      name
      decimals
      derivedETH
      __typename
    }
    token1 {
      id
      symbol
      name
      decimals
      derivedETH
      __typename
    }
    token0Price
    token1Price
    volumeUSD
    txCount
    totalValueLockedToken0
    totalValueLockedToken1
    totalValueLockedUSD
    __typename
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;pools&quot;: [
      {
        &quot;id&quot;: &quot;0xa850478adaace4c08fc61de44d8cf3b64f359bec&quot;,
        &quot;feeTier&quot;: &quot;500&quot;,
        &quot;liquidity&quot;: &quot;1706245281880037395956227425&quot;,
        &quot;sqrtPrice&quot;: &quot;792049440195001924670217089101&quot;,
        &quot;tick&quot;: &quot;46048&quot;,
        &quot;token0&quot;: {
          &quot;id&quot;: &quot;0x12b32f10a499bf40db334efe04226cca00bf2d9b&quot;,
          &quot;symbol&quot;: &quot;UMIIE&quot;,
          &quot;name&quot;: &quot;UMIIE COIN&quot;,
          &quot;decimals&quot;: &quot;18&quot;,
          &quot;derivedETH&quot;: &quot;0.1003902793538328620619869326124331&quot;,
          &quot;__typename&quot;: &quot;Token&quot;
        },
        &quot;token1&quot;: {
          &quot;id&quot;: &quot;0x5ed60a121159481675bad3e648ba4c89753e056f&quot;,
          &quot;symbol&quot;: &quot;UMIIE2&quot;,
          &quot;name&quot;: &quot;Umiie 2&quot;,
          &quot;decimals&quot;: &quot;18&quot;,
          &quot;derivedETH&quot;: &quot;0&quot;,
          &quot;__typename&quot;: &quot;Token&quot;
        },
        &quot;token0Price&quot;: &quot;0.01000586374960270227477201921193648&quot;,
        &quot;token1Price&quot;: &quot;99.94139686738253752770898237370869&quot;,
        &quot;volumeUSD&quot;: &quot;0&quot;,
        &quot;txCount&quot;: &quot;9&quot;,
        &quot;totalValueLockedToken0&quot;: &quot;50050480.103497613002904654&quot;,
        &quot;totalValueLockedToken1&quot;: &quot;14644676667.240849617715772909&quot;,
        &quot;totalValueLockedUSD&quot;: &quot;12887625156.60443191907094774602519&quot;,
        &quot;__typename&quot;: &quot;Pool&quot;
      },
      {
        &quot;id&quot;: &quot;0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8&quot;,
        &quot;feeTier&quot;: &quot;3000&quot;,
        &quot;liquidity&quot;: &quot;13757788412751061547&quot;,
        &quot;sqrtPrice&quot;: &quot;1465022049799761266689268933073649&quot;,
        &quot;tick&quot;: &quot;196510&quot;,
        &quot;token0&quot;: {
          &quot;id&quot;: &quot;0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48&quot;,
          &quot;symbol&quot;: &quot;USDC&quot;,
          &quot;name&quot;: &quot;USD Coin&quot;,
          &quot;decimals&quot;: &quot;6&quot;,
          &quot;derivedETH&quot;: &quot;0.0003419236610902688830990355549810135&quot;,
          &quot;__typename&quot;: &quot;Token&quot;
        },
        &quot;token1&quot;: {
          &quot;id&quot;: &quot;0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2&quot;,
          &quot;symbol&quot;: &quot;WETH&quot;,
          &quot;name&quot;: &quot;Wrapped Ether&quot;,
          &quot;decimals&quot;: &quot;18&quot;,
          &quot;derivedETH&quot;: &quot;1&quot;,
          &quot;__typename&quot;: &quot;Token&quot;
        },
        &quot;token0Price&quot;: &quot;2924.629424039762397178342690644415&quot;,
        &quot;token1Price&quot;: &quot;0.0003419236610902688830990355549810135&quot;,
        &quot;volumeUSD&quot;: &quot;46675235734.17557247596178718271208&quot;,
        &quot;txCount&quot;: &quot;300573&quot;,
        &quot;totalValueLockedToken0&quot;: &quot;184459973.048114&quot;,
        &quot;totalValueLockedToken1&quot;: &quot;76505.849041123104288281&quot;,
        &quot;totalValueLockedUSD&quot;: &quot;408211230.2649268727637666561467565&quot;,
        &quot;__typename&quot;: &quot;Pool&quot;
      }
    ]
  }
}
</code></pre>
<h3>查询 prices</h3>
<pre><code>query prices {
  current: bundles(first: 1, subgraphError: allow) {
    ethPriceUSD
    __typename
  }
  oneDay: bundles(first: 1, block: {number: 14423607}, subgraphError: allow) {
    ethPriceUSD
    __typename
  }
  twoDay: bundles(first: 1, block: {number: 14417197}, subgraphError: allow) {
    ethPriceUSD
    __typename
  }
  oneWeek: bundles(first: 1, block: {number: 14385081}, subgraphError: allow) {
    ethPriceUSD
    __typename
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;current&quot;: [
      {
        &quot;ethPriceUSD&quot;: &quot;2911.900514205906596528906408766284&quot;,
        &quot;__typename&quot;: &quot;Bundle&quot;
      }
    ],
    &quot;oneDay&quot;: [
      {
        &quot;ethPriceUSD&quot;: &quot;2881.703460328542976410568122182245&quot;,
        &quot;__typename&quot;: &quot;Bundle&quot;
      }
    ],
    &quot;twoDay&quot;: [
      {
        &quot;ethPriceUSD&quot;: &quot;2957.208390287011377358451424105611&quot;,
        &quot;__typename&quot;: &quot;Bundle&quot;
      }
    ],
    &quot;oneWeek&quot;: [
      {
        &quot;ethPriceUSD&quot;: &quot;2566.212421242889978064374895815068&quot;,
        &quot;__typename&quot;: &quot;Bundle&quot;
      }
    ]
  }
}
</code></pre>
<h3>查询 transactions</h3>
<pre><code>query transactions {
  transactions(
    first: 500
    orderBy: timestamp
    orderDirection: desc
    subgraphError: allow
  ) {
    id
    timestamp
    mints {
      pool {
        token0 {
          id
          symbol
          __typename
        }
        token1 {
          id
          symbol
          __typename
        }
        __typename
      }
      owner
      sender
      origin
      amount0
      amount1
      amountUSD
      __typename
    }
    swaps {
      pool {
        token0 {
          id
          symbol
          __typename
        }
        token1 {
          id
          symbol
          __typename
        }
        __typename
      }
      origin
      amount0
      amount1
      amountUSD
      __typename
    }
    burns {
      pool {
        token0 {
          id
          symbol
          __typename
        }
        token1 {
          id
          symbol
          __typename
        }
        __typename
      }
      owner
      origin
      amount0
      amount1
      amountUSD
      __typename
    }
    __typename
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;transactions&quot;: [
      {
        &quot;id&quot;: &quot;0xd87658f56454d4bccf363af8ed720e19990d3c7a02939320ae59258fbef2aa0a&quot;,
        &quot;timestamp&quot;: &quot;1647872333&quot;,
        &quot;mints&quot;: [],
        &quot;swaps&quot;: [
          {
            &quot;pool&quot;: {
              &quot;token0&quot;: {
                &quot;id&quot;: &quot;0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48&quot;,
                &quot;symbol&quot;: &quot;USDC&quot;,
                &quot;__typename&quot;: &quot;Token&quot;
              },
              &quot;token1&quot;: {
                &quot;id&quot;: &quot;0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2&quot;,
                &quot;symbol&quot;: &quot;WETH&quot;,
                &quot;__typename&quot;: &quot;Token&quot;
              },
              &quot;__typename&quot;: &quot;Pool&quot;
            },
            &quot;origin&quot;: &quot;0x6e5dac0408d313c3adb78c671741df7a1944f9d5&quot;,
            &quot;amount0&quot;: &quot;838.639246&quot;,
            &quot;amount1&quot;: &quot;-0.288308585496447514&quot;,
            &quot;amountUSD&quot;: &quot;839.082582178541550390129466135908&quot;,
            &quot;__typename&quot;: &quot;Swap&quot;
          },
          {
            &quot;pool&quot;: {
              &quot;token0&quot;: {
                &quot;id&quot;: &quot;0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48&quot;,
                &quot;symbol&quot;: &quot;USDC&quot;,
                &quot;__typename&quot;: &quot;Token&quot;
              },
              &quot;token1&quot;: {
                &quot;id&quot;: &quot;0xd5d86fc8d5c0ea1ac1ac5dfab6e529c9967a45e9&quot;,
                &quot;symbol&quot;: &quot;WRLD&quot;,
                &quot;__typename&quot;: &quot;Token&quot;
              },
              &quot;__typename&quot;: &quot;Pool&quot;
            },
            &quot;origin&quot;: &quot;0x6e5dac0408d313c3adb78c671741df7a1944f9d5&quot;,
            &quot;amount0&quot;: &quot;-838.639246&quot;,
            &quot;amount1&quot;: &quot;3500&quot;,
            &quot;amountUSD&quot;: &quot;838.639246&quot;,
            &quot;__typename&quot;: &quot;Swap&quot;
          }
        ],
        &quot;burns&quot;: [],
        &quot;__typename&quot;: &quot;Transaction&quot;
      }
    ]
  }
}
</code></pre>
<h3>查询 uniswapDayDatas</h3>
<pre><code>query uniswapDayDatas {
  uniswapDayDatas(
    first: 1000
    skip: 0
    subgraphError: allow
    where: {date_gt: 1619170975}
    orderBy: date
    orderDirection: asc
  ) {
    id
    date
    volumeUSD
    tvlUSD
    __typename
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;uniswapDayDatas&quot;: [
      {
        &quot;id&quot;: &quot;18751&quot;,
        &quot;date&quot;: 1620086400,
        &quot;volumeUSD&quot;: &quot;0&quot;,
        &quot;tvlUSD&quot;: &quot;0&quot;,
        &quot;__typename&quot;: &quot;UniswapDayData&quot;
      },
    ]
  }
}
</code></pre>
<h3>poolDayDatas</h3>
<pre><code>query poolDayDatas {
  poolDayDatas(
    first: 1000
    skip: 0
    where: {pool: &quot;0xa850478adaace4c08fc61de44d8cf3b64f359bec&quot;, date_gt: 1619170975}
    orderBy: date
    orderDirection: asc
    subgraphError: allow
  ) {
    date
    volumeUSD
    tvlUSD
    feesUSD
    __typename
  }
}
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;poolDayDatas&quot;: [
      {
        &quot;date&quot;: 1625356800,
        &quot;volumeUSD&quot;: &quot;0&quot;,
        &quot;tvlUSD&quot;: &quot;0&quot;,
        &quot;feesUSD&quot;: &quot;0&quot;,
        &quot;__typename&quot;: &quot;PoolDayData&quot;
      },
      {
        &quot;date&quot;: 1634342400,
        &quot;volumeUSD&quot;: &quot;0&quot;,
        &quot;tvlUSD&quot;: &quot;0&quot;,
        &quot;feesUSD&quot;: &quot;0&quot;,
        &quot;__typename&quot;: &quot;PoolDayData&quot;
      },
      {
        &quot;date&quot;: 1646611200,
        &quot;volumeUSD&quot;: &quot;0&quot;,
        &quot;tvlUSD&quot;: &quot;261269729093.816542194433000739702&quot;,
        &quot;feesUSD&quot;: &quot;0&quot;,
        &quot;__typename&quot;: &quot;PoolDayData&quot;
      },
      {
        &quot;date&quot;: 1646697600,
        &quot;volumeUSD&quot;: &quot;0&quot;,
        &quot;tvlUSD&quot;: &quot;12887625156.60443191907094774602519&quot;,
        &quot;feesUSD&quot;: &quot;0&quot;,
        &quot;__typename&quot;: &quot;PoolDayData&quot;
      }
    ]
  }
}
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[浏览器打开图片 URL 是显示还是下载]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/91</link>
            <guid>https://github.com/xiaotiandada/blog/issues/91</guid>
            <pubDate>Tue, 11 Jan 2022 07:13:24 GMT</pubDate>
            <description><![CDATA[<p><a href="https://help.aliyun.com/document_detail/39545.html">访问存储在OSS中的资源时资源被强制下载</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition">Content-Disposition</a></p>
<blockquote>
<h2>问题原因</h2>
<p>访问存储在OSS的文件、图片等被强制下载的可能原因如下所示：</p>
<ul>
<li>使用OSS提供的默认域名，且没有经过其他配置。</li>
<li>对应资源的Content-Type设置错误。Content-Type如果设置为application/octet-stream也会导致强制下载，这个是二进制的下载流。</li>
<li>对应资源的Content-Disposition设置错误。Content-Disposition如果设置为attachment，就是会强制下载。</li>
<li>CDN缓存了错误的Content-Type或者Content-Disposition。</li>
<li>浏览器不支持该格式资源的展示。</li>
</ul>
</blockquote>
<p>条件问题只测试了没有域名，使用默认 OSS 提供的域名。</p>
<p>图片1</p>
<p><a href="https://storageapi.fleek.co/andoroyur-team-bucket/metanetwork/users/metaio-storage/24jokhpxex0vg9bkcvav9xrn1.jpeg">https://storageapi.fleek.co/andoroyur-team-bucket/metanetwork/users/metaio-storage/24jokhpxex0vg9bkcvav9xrn1.jpeg</a></p>
<p><img src="https://user-images.githubusercontent.com/24250627/148896308-ab2fa536-f9fb-47f8-98c9-8b6af744cca3.png" alt="image"></p>
<pre><code>content-type: application/octet-stream
</code></pre>
<p>这张图片会默认下载</p>
<p>图片2</p>
<p><a href="https://smartsignature-img.oss-cn-hongkong.aliyuncs.com/banner/2020/02/04/a60cf0aa4ec50c39196dbf97ceddbbc8.jpg">https://smartsignature-img.oss-cn-hongkong.aliyuncs.com/banner/2020/02/04/a60cf0aa4ec50c39196dbf97ceddbbc8.jpg</a></p>
<p><img src="https://user-images.githubusercontent.com/24250627/148896449-a716187e-0c7c-4d1b-a23e-c85d6842f097.png" alt="image"></p>
<pre><code>Content-Type: image/jpeg
</code></pre>
<p>图片会默认打开预览</p>
<p>如果 修改 HTTP 头</p>
<pre><code>Content-Disposition: attachment
Content-Type: image/jpeg
</code></pre>
<p><img src="https://user-images.githubusercontent.com/24250627/148896709-481b30f6-d521-41be-bd03-8c5179b305c4.png" alt="image"></p>
<p>这种情况会下载图片</p>
<pre><code>content-type: application/octet-stream
</code></pre>
<p>这种设置会下载图片</p>
<p>其他情况具体需要测试</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Bit 使用]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/90</link>
            <guid>https://github.com/xiaotiandada/blog/issues/90</guid>
            <pubDate>Fri, 01 Apr 2022 08:23:22 GMT</pubDate>
            <description><![CDATA[<h2>创建新组件</h2>
<p><a href="https://bit.dev/docs/workspace/creating-components">https://bit.dev/docs/workspace/creating-components</a></p>
<pre><code class="language-tsx">bit create react xx
bit compile 
bit start  
</code></pre>
<h2>坑</h2>
<ol>
<li>
<p>新 bvm install 的 bit，import 不能 import old bit project compoents，可以 import harmony project components</p>
</li>
<li>
<p>bit start 如果不能启动，需要 compile then start or down version <a href="https://github.com/teambit/bit/issues/4522">Issues</a></p>
</li>
<li>
<p>如果有多个目录 <code>bit export</code> 报错 <code>unable to export the following lanes master. they don't exist or are empty</code> 可以分开导出比如 <code>bit export nft/card</code></p>
</li>
</ol>
<h2>Tag</h2>
<p><a href="https://legacy-docs.bit.dev/docs/tag-component-version">https://legacy-docs.bit.dev/docs/tag-component-version</a></p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Nuxt.js deploy to vercel]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/89</link>
            <guid>https://github.com/xiaotiandada/blog/issues/89</guid>
            <pubDate>Tue, 07 Dec 2021 03:38:37 GMT</pubDate>
            <description><![CDATA[<p>Vercel deploy ...</p>
<p><a href="https://github.com/nuxt/vercel-builder#readme">https://github.com/nuxt/vercel-builder#readme</a></p>
<ol>
<li>
<p>/bin/sh: node-gyp-build: command not found  <a href="https://github.com/nuxt/vercel-builder/issues/371">https://github.com/nuxt/vercel-builder/issues/371</a></p>
<ol>
<li>package.json add script</li>
</ol>
<pre><code class="language-json">&quot;scripts&quot;: {
  &quot;vercel-build&quot;: &quot;yarn global add node-gyp-build&quot;
}
</code></pre>
<ol start="2">
<li>add vercel.json file</li>
</ol>
<pre><code class="language-json">{
  &quot;version&quot;: 2,
  &quot;builds&quot;: [
    {
      &quot;src&quot;: &quot;package.json&quot;,
      &quot;use&quot;: &quot;@vercel/node&quot;
    },
    {
      &quot;src&quot;: &quot;nuxt.config.js&quot;,
      &quot;use&quot;: &quot;@nuxtjs/vercel-builder&quot;,
      &quot;config&quot;: {
        &quot;serverFiles&quot;: [
          &quot;package.json&quot;
          ...
        ]
      }
    }
  ],
  &quot;routes&quot;: [
    {
      &quot;src&quot;: &quot;/sw.js&quot;,
      &quot;continue&quot;: true,
      &quot;headers&quot;: {
        &quot;Cache-Control&quot;: &quot;public, max-age=0, must-revalidate&quot;,
        &quot;Service-Worker-Allowed&quot;: &quot;/&quot;
      }
    }
  ]
}
</code></pre>
</li>
<li>
<p>other dependencies command not found or local file command not found</p>
</li>
</ol>
<p>需要包含在 serverFiles 或者 dependencies</p>
<p>其他也一样 command not found 基本上都一样 esm 之类的文件</p>
<pre><code>npm i 'command not found'
</code></pre>
<ol start="3">
<li>Serverless Function &quot;index&quot; size limit</li>
</ol>
<pre><code>Error: The Serverless Function &quot;index&quot; is 104.9mb which exceeds the maximum size limit of 50mb. Learn More: https://vercel.link/serverless-function-size
</code></pre>
<p>dependencies move to devDependencies</p>
<p>前置条件 nuxt.config.js 没有导入任何依赖文件</p>
<ul>
<li>如果需要 import 本地文件 需要在 vercel.json serverFiles 里面包含文件</li>
<li>如果需要 import 依赖，需要在 dependencies 包含</li>
<li>如果 import 本地文件 里面包含了 本地文件或依赖也需要包含在 serverFiles or dependencies</li>
<li>如果需要 modules 使用（不会报错 会有警告 所以可以包含在 dependencies）</li>
</ul>
<p>减少 map 这样也可以减少打包大小</p>
<pre><code class="language-javascript">  build: {
    extend (config) {
      config.devtool = false
    }
  },
</code></pre>
<ol start="4">
<li>if use svg-sprite-loader （optional）</li>
</ol>
<p><a href="https://github.com/JetBrains/svg-sprite-loader#readme">https://github.com/JetBrains/svg-sprite-loader#readme</a></p>
<p><a href="https://github.com/dword-design/nuxt-svg-sprite-loader#readme">https://github.com/dword-design/nuxt-svg-sprite-loader#readme</a></p>
<p><a href="https://nuxtjs.org/docs/directory-structure/modules/">https://nuxtjs.org/docs/directory-structure/modules/</a></p>
<pre><code class="language-javascript">import packageName from 'depcheck-package-name'
import path from 'path'

const resolve = (dir) =&gt; path.join(__dirname, dir)
const svgRulePredicate = rule =&gt; rule.test &amp;&amp; rule.test.test('.svg')

export default function (moduleOptions) {
  const options = { ...this.options.spriteSvgLoader, ...moduleOptions }
  this.extendBuild(config =&gt; {
    const imageLoaderRule = config.module.rules.find(svgRulePredicate)
    console.log('imageLoaderRule', imageLoaderRule, resolve('../icons/svg'))
    imageLoaderRule.exclude = [resolve('../icons/svg')]

    config.module.rules.push({
      loader: packageName`svg-sprite-loader`,
      options,
      include: [resolve('../icons/svg')], // include =&gt; 只处理指定的文件夹下的文件
      test: /\.svg$/,
    })
  })
}
</code></pre>
<ol start="5">
<li>nuxt.config.js import webpack （optional）</li>
</ol>
<p>webpack command not found</p>
<p>maybe add webpack dependence can solve it</p>
<p>but i use other webpack rules, show <code>Error: Cannot find module 'webpack/lib/RuleSet'</code></p>
<ol start="6">
<li>nuxt.config.js import svg-sprite-loader（optional）</li>
</ol>
<p>show <code>Error: Cannot find module 'webpack/lib/RuleSet'</code>, so i remove it</p>
<p>use modules <code>nuxt-svg-sprite-loader</code></p>
<ol start="7">
<li>nuxt.config.js parallel config （optional）</li>
</ol>
<p>if parallel is true, maybe build fail</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[React Hooks 学习]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/88</link>
            <guid>https://github.com/xiaotiandada/blog/issues/88</guid>
            <pubDate>Thu, 24 Mar 2022 16:36:45 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://segmentfault.com/a/1190000021057476">https://segmentfault.com/a/1190000021057476</a></li>
<li><a href="https://github.com/facebook/react/blob/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberHooks.js#L336">https://github.com/facebook/react/blob/5f06576f51ece88d846d01abd2ddd575827c6127/packages/react-reconciler/src/ReactFiberHooks.js#L336</a></li>
</ul>
<pre><code class="language-tsx">import { render } from &quot;react-dom&quot;;

const memorizedState: any[] = [];
let cursor: number = 0;

function useState&lt;T&gt;(initialState: T): [T, any] {
  memorizedState[cursor] = memorizedState[cursor] || initialState;
  const currentCursor = cursor;

  function setState&lt;T&gt;(newState: T) {
    memorizedState[currentCursor] = newState;
    renderFn();
  }

  return [memorizedState[cursor++], setState];
}

function useCallback(callback: any, dependenciesArray?: any[]) {
  const hasNotDependencies = !dependenciesArray;

  const dependencies = memorizedState[cursor];

  const changeDependencies = dependencies
    ? !dependenciesArray!.every((el, i) =&gt; el === dependencies[i])
    : true;

  // 没有依赖 或者 依赖改变
  if (hasNotDependencies || changeDependencies) {
    callback();
    memorizedState[cursor] = dependenciesArray;
  }

  cursor++;
}

function App() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState(&quot;xiao&quot;);

  useCallback(() =&gt; {
    console.log(&quot;not dependencies&quot;);
  });

  useCallback(() =&gt; {
    console.log(&quot;only once&quot;);
  }, []);

  useCallback(() =&gt; {
    console.log(&quot;change count or name&quot;, count, name);
  }, [count, name]);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setCount(Date.now())}&gt;count {count}&lt;/button&gt;
      &lt;button onClick={() =&gt; setName(Date.now() + &quot; - name&quot;)}&gt;
        name {name}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

const root = document.getElementById(&quot;root&quot;);

function renderFn() {
  cursor = 0;
  render(&lt;App /&gt;, root);
}

renderFn();

</code></pre>
<p><a href="https://codesandbox.io/s/react-hooks-ytbtb?file=/src/index.tsx">https://codesandbox.io/s/react-hooks-ytbtb?file=/src/index.tsx</a></p>
<p>依靠 memorizedState 数组来存放数据</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Taro 学习]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/87</link>
            <guid>https://github.com/xiaotiandada/blog/issues/87</guid>
            <pubDate>Wed, 29 Sep 2021 13:13:47 GMT</pubDate>
            <description><![CDATA[<p>Taro 学习</p>
<h3>路由跳转</h3>
<pre><code class="language-tsx">import Taro from '@tarojs/taro'

Taro.navigateTo({ url: '/pages/user/index' })
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[React Native 学习]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/86</link>
            <guid>https://github.com/xiaotiandada/blog/issues/86</guid>
            <pubDate>Wed, 29 Sep 2021 08:17:55 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://github.com/xiaotiandada/look">repo</a></li>
<li><a href="https://expo.dev/@xiaotiandada/AwesomeProject">App</a></li>
<li><a href="https://nativebase.io/">NativeBase</a> UI 组件库</li>
</ul>
<p>记录一些觉得有意义的功能点</p>
<h3>列表滚动</h3>
<ul>
<li>
<p>静态列表 不多的情况我会用 <a href="https://reactnative.dev/docs/scrollview">ScrollView</a></p>
<pre><code class="language-tsx">&lt;ScrollView style={styles.scrollView}&gt;
  &lt;Text style={styles.text}&gt;
    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do
    eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad
    minim veniam, quis nostrud exercitation ullamco laboris nisi ut
    aliquip ex ea commodo consequat. Duis aute irure dolor in
    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
    pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
    culpa qui officia deserunt mollit anim id est laborum.
  &lt;/Text&gt;
&lt;/ScrollView&gt;
</code></pre>
</li>
<li>
<p>动态加载 包含图片什么的 <a href="https://reactnative.dev/docs/flatlist">flatlist</a></p>
</li>
</ul>
<pre><code class="language-tsx">&lt;FlatList
  data={DATA}
  renderItem={renderItem}
  keyExtractor={(item) =&gt; item.id}
  /&gt;
</code></pre>
<ul>
<li><a href="https://reactnative.dev/docs/sectionlist">SectionList</a> 暂没用上</li>
</ul>
<h3>列表下拉刷新</h3>
<pre><code class="language-tsx">const [refreshing, setRefreshing] = useState&lt;boolean&gt;(false);

// refresh
const onRefresh = useCallback(
  async () =&gt; {
    // do something
  }, []);


&lt;FlatList
  ref={refFlatList}
  numColumns={2}
  renderItem={renderItem}
  keyExtractor={(item) =&gt; item.id}
  refreshControl={
    &lt;RefreshControl refreshing={refreshing} onRefresh={onRefresh} /&gt;
  }
// ...
</code></pre>
<p>FlatList 继承了 ScrollView 所以 ScrollView 也一样</p>
<h3>列表上拉加载</h3>
<pre><code class="language-tsx">// more load components
const RenderLoadMoreView = () =&gt; {
  return &lt;View style={styles.loadMore}&gt;
    &lt;ActivityIndicator
      style={styles.indicator}
      size={&quot;small&quot;}
      animating={true}
      /&gt;
    &lt;Text&gt;Loading...&lt;/Text&gt;
  &lt;/View&gt;
};

const fetchCosplayMore = useCallback(
  async () =&gt; {
    // do something
  }, []);


&lt;FlatList
  ref={refFlatList}
  numColumns={2}
  renderItem={renderItem}
  keyExtractor={(item) =&gt; item.id}
  refreshControl={
    &lt;RefreshControl refreshing={refreshing} onRefresh={onRefresh} /&gt;
  }
  ListFooterComponent={() =&gt; RenderLoadMoreView()}
  onEndReached={() =&gt; fetchCosplayMore()}
  
  // ...
</code></pre>
<h3>列表滚动</h3>
<pre><code class="language-tsx">const handleScroll = useCallback((e: NativeSyntheticEvent&lt;NativeScrollEvent&gt;) =&gt; {
  // do something
}, []);

&lt;FlatList
  ref={refFlatList}
  numColumns={2}
  renderItem={renderItem}
  keyExtractor={(item) =&gt; item.id}
  refreshControl={
    &lt;RefreshControl refreshing={refreshing} onRefresh={onRefresh} /&gt;
  }
  ListFooterComponent={() =&gt; RenderLoadMoreView()}
  onEndReached={() =&gt; fetchCosplayMore()}
  onScroll={handleScroll}
</code></pre>
<h3>图片保存 ios</h3>
<pre><code class="language-tsx">import * as MediaLibrary from 'expo-media-library';
import * as ImagePicker from 'expo-image-picker';

const handleDownload = useCallback(
    async (url: string): Promise&lt;void&gt; =&gt; {
      // libraryPermissionResult Object {
      //   &quot;accessPrivileges&quot;: &quot;none&quot;,
      //   &quot;canAskAgain&quot;: false,
      //   &quot;expires&quot;: &quot;never&quot;,
      //   &quot;granted&quot;: false,
      //   &quot;status&quot;: &quot;denied&quot;,
      // }
	
      // copy doc 不太需要
      if (Platform.OS !== 'web') {
        const { status } = await ImagePicker.getMediaLibraryPermissionsAsync();
        if (status !== 'granted') {
          // Alert.alert('Sorry, we need media library permissions to make this work!');
          // return
        }
      } else {
        console.log('no support web')
        return
      }
			
      // 好像是这个权限 后来不知道怎么清空权限重新获取一下
      const libraryPermissionResult = await ImagePicker.getMediaLibraryPermissionsAsync()
      console.log('libraryPermissionResult', libraryPermissionResult)
      // ImagePicker.requestMediaLibraryPermissionsAsync(writeOnly)

      // Get permission
      if (libraryPermissionResult.accessPrivileges === 'none' &amp;&amp; libraryPermissionResult.status !== 'granted') {
        await ImagePicker.requestMediaLibraryPermissionsAsync(true)

        const _libraryPermissionResult = await ImagePicker.getMediaLibraryPermissionsAsync()
        console.log('_libraryPermissionResult', _libraryPermissionResult)

        if (_libraryPermissionResult.accessPrivileges === 'none' &amp;&amp; _libraryPermissionResult.status !== 'granted') {
          return
        }
      }

      // Save
      try {
        // encode 因为图片 url 有中文 会报错
        await MediaLibrary.saveToLibraryAsync(encodeURI(url))
        Alert.alert('Saved successfully')

      } catch (error) {
        console.log('error', error)
        Alert.alert('Save failed')
      }
    }, [])
</code></pre>
<blockquote>
<p>先跑了个流程</p>
</blockquote>
<h3>ActionSheetIOS</h3>
<pre><code class="language-tsx">import { ActionSheetIOS } from 'react-native';

const onPress = () =&gt;
  ActionSheetIOS.showActionSheetWithOptions(
    {
      options: [&quot;Cancel&quot;, &quot;Generate number&quot;, &quot;Reset&quot;],
      destructiveButtonIndex: 2,
      cancelButtonIndex: 0,
      userInterfaceStyle: 'dark'
    },
    buttonIndex =&gt; {
      if (buttonIndex === 0) {
        // cancel action
      } else if (buttonIndex === 1) {
        setResult(Math.floor(Math.random() * 100) + 1);
      } else if (buttonIndex === 2) {
        setResult(&quot;🔮&quot;);
      }
    }
  );
</code></pre>
<p>会弹出一个菜单</p>
<h3>Share</h3>
<pre><code class="language-tsx">import { Share } from 'react-native';
const onShare = async () =&gt; {
    try {
      const result = await Share.share({
        message:
          'React Native | A framework for building native apps using React',
      });
      if (result.action === Share.sharedAction) {
        if (result.activityType) {
          // shared with activity type of result.activityType
        } else {
          // shared
        }
      } else if (result.action === Share.dismissedAction) {
        // dismissed
      }
    } catch (error) {
      alert(error.message);
    }
  };
</code></pre>
<p>会出现一个 分享 菜单，和 expo share sdk 有什么区别我还不知道 <a href="https://docs.expo.dev/versions/latest/react-native/share/">https://docs.expo.dev/versions/latest/react-native/share/</a></p>
<h3>返回到顶部</h3>
<pre><code class="language-tsx">// TODO: type fix
const refFlatList = useRef&lt;any&gt;(null);

// go top
const goToTop = useCallback(() =&gt; {
  // 后来看见的 懒得试
  // https://reactnavigation.org/docs/use-scroll-to-top
  refFlatList.current.scrollToOffset({ offset: 0 });
}, [refFlatList]);


&lt;FlatList
  ref={refFlatList}
</code></pre>
<p>reactnavigation 文档也提到了这个功能</p>
<h3>react-navigation</h3>
<p><a href="https://reactnavigation.org/">https://reactnavigation.org/</a></p>
<ul>
<li>
<p>navigation.navigate('Detail') 只会产生一条记录</p>
</li>
<li>
<p>navigation.push('Detail') 会产出N条记录</p>
</li>
<li>
<p>useFocusEffect</p>
<pre><code class="language-tsx">useFocusEffect(
  useCallback(() =&gt; {
    const fetch = () =&gt; something()
    fetch()
  }, [])
);
</code></pre>
</li>
<li>
<p>params <code>navigation.navigate('Detail', params)</code></p>
</li>
<li>
<p>...</p>
</li>
</ul>
<h3>背景渐变</h3>
<pre><code class="language-tsx">import * as React from 'react';
import { StyleSheet, Text, View } from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';

export default function App() {
  return (
    &lt;View style={styles.container}&gt;
      &lt;LinearGradient
        // Background Linear Gradient
        colors={['rgba(0,0,0,0.8)', 'transparent']}
        style={styles.background}
      /&gt;
      &lt;LinearGradient
        // Button Linear Gradient
        colors={['#4c669f', '#3b5998', '#192f6a']}
        style={styles.button}&gt;
        &lt;Text style={styles.text}&gt;Sign in with Facebook&lt;/Text&gt;
      &lt;/LinearGradient&gt;
    &lt;/View&gt;
  );
}

const styles = StyleSheet.create({ ... }); 
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[Vuex 源码研究]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/85</link>
            <guid>https://github.com/xiaotiandada/blog/issues/85</guid>
            <pubDate>Tue, 31 Aug 2021 17:17:07 GMT</pubDate>
            <description><![CDATA[<ul>
<li>
<p><a href="https://tech.meituan.com/2017/04/27/vuex-code-analysis.htm">https://tech.meituan.com/2017/04/27/vuex-code-analysis.htm</a></p>
</li>
<li>
<p><a href="https://github.com/answershuto/learnVue/blob/master/docs/Vuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.MarkDown">https://github.com/answershuto/learnVue/blob/master/docs/Vuex源码解析.MarkDown</a></p>
</li>
<li>
<p><a href="https://github.com/xiaotiandada/Case/tree/master/vuex-learn">https://github.com/xiaotiandada/Case/tree/master/vuex-learn</a></p>
</li>
</ul>
<h2>Index.js</h2>
<pre><code class="language-javascript">import { Store, install } from './store'
</code></pre>
<p>导入/导出各个模块功能</p>
<h3>Store.js</h3>
<pre><code class="language-javascript">if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) {
	install(window.Vue)
}
</code></pre>
<p>在 Vue 环境中安装</p>
<pre><code class="language-javascript">if (__DEV__) {
  assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)
  assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)
  assert(this instanceof Store, `store must be called with the new operator.`)
}
</code></pre>
<p>开发模式断言</p>
<pre><code class="language-javascript">    const {
      // 一个数组，包含应用在 store 上的插件方法。
      plugins = [],
      // 使 Vuex store 进入严格模式，在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误。
      strict = false
    } = options
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[React.memo 学习]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/84</link>
            <guid>https://github.com/xiaotiandada/blog/issues/84</guid>
            <pubDate>Wed, 05 Jan 2022 08:38:30 GMT</pubDate>
            <description><![CDATA[<h2><code>React.memo</code></h2>
<pre><code class="language-react">const MyComponent = React.memo(function MyComponent(props) {
  /* 使用 props 渲染 */
});
</code></pre>
<p><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo">https://zh-hans.reactjs.org/docs/react-api.html#reactmemo</a></p>
<blockquote>
<p>如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 <code>React.memo</code> 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p>
<p><code>React.memo</code> 仅检查 props 变更。如果函数组件被 <code>React.memo</code> 包裹，且其实现中拥有 <a href="https://zh-hans.reactjs.org/docs/hooks-state.html"><code>useState</code></a>，<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer"><code>useReducer</code></a> 或 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext"><code>useContext</code></a> 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。</p>
<p>...</p>
</blockquote>
<p><a href="https://codesandbox.io/s/react-memo-qknj7?file=/src/App.tsx">demo</a> 代码都在这儿</p>
<h3>默认情况</h3>
<pre><code class="language-tsx">console.log(&quot;App Parent&quot;);

const [time, setTime] = useState&lt;string&gt;(&quot;&quot;);
const [time1, setTime1] = useState&lt;string&gt;(&quot;&quot;);

&lt;div&gt;
  &lt;div&gt;Parent&lt;/div&gt;
  &lt;ul&gt;
    &lt;li&gt;time: {time}&lt;/li&gt;
    &lt;li&gt;time1: {time1}&lt;/li&gt;
  &lt;/ul&gt;
  &lt;button onClick={() =&gt; setTime(&quot;1111&quot;)}&gt;toggle&lt;/button&gt;
  &lt;button onClick={() =&gt; setTime1(String(Date.now()))}&gt;toggle1&lt;/button&gt;
  &lt;button onClick={() =&gt; setTime1(&quot;0000000000&quot;)}&gt;toggle1&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<ol>
<li>默认执行 输出 <code>App Parent</code> 一次</li>
<li>组件内 useState 变动则会重新渲染一次</li>
</ol>
<h3>默认组件 在组件内</h3>
<pre><code class="language-tsx">  const child1: React.FC = () =&gt; {
    console.log(&quot;child1&quot;);
    return (
      &lt;div&gt;
        &lt;div&gt;child1&lt;/div&gt;
        &lt;button onClick={() =&gt; setTime1(&quot;child1&quot;)}&gt;toggle&lt;/button&gt;
        &lt;button onClick={() =&gt; setTime1(String(Date.now()))}&gt;toggle&lt;/button&gt;
      &lt;/div&gt;
    );
  };
</code></pre>
<ol>
<li>父组件渲染一次 child1 也渲染一次</li>
<li>父组件 useState 改动 父组件和 child1 渲染一次</li>
<li>child1 组件 useState 改动 父组件和 child1 渲染一次</li>
</ol>
<h3>默认组件 使用方式</h3>
<pre><code class="language-tsx">&lt;div&gt;{Child1()}&lt;/div&gt;
&lt;Child2 /&gt;
</code></pre>
<pre><code>App Parent 
Child1 
Child2 

App Parent 
Child1 
</code></pre>
<ol>
<li>表现基本与上面一致</li>
<li>第一次 都渲染，后面 修改相同 useState 执行 Child1，修改不相同 useState 执行  Child1 Child2</li>
</ol>
<h3>Memo 在组件内</h3>
<pre><code class="language-tsx">const Child3: React.FC = React.memo(function Child3() {
  console.log(&quot;Child3&quot;);
  return (
    &lt;div&gt;
      &lt;div&gt;Child2&lt;/div&gt;
      &lt;div&gt;{time}&lt;/div&gt;
      &lt;div&gt;{time1}&lt;/div&gt;
    &lt;/div&gt;
  );
});
</code></pre>
<ol>
<li>无效 表现和默认一致</li>
</ol>
<h3>在组件内 无依赖 修改 useState</h3>
<pre><code class="language-tsx">  const Child4: React.FC = () =&gt; {
    console.log(&quot;Child4&quot;);
    const [state, setstate] = useState(&quot;&quot;);

    return (
      &lt;div&gt;
        &lt;div&gt;{state}&lt;/div&gt;
        &lt;button onClick={() =&gt; setstate(String(Date.now()))}&gt;toggle&lt;/button&gt;
      &lt;/div&gt;
    );
  };
</code></pre>
<ol>
<li>只渲染当前组件</li>
</ol>
<h3>在组件外 默认组件 无依赖</h3>
<pre><code class="language-tsx">const Outer1 = () =&gt; {
  console.log(&quot;Outer1&quot;);
  return &lt;div&gt;Outer1&lt;/div&gt;;
};
</code></pre>
<ol>
<li>表现和默认一致</li>
</ol>
<pre><code>App Parent 
Outer1 
</code></pre>
<h3>在组件外 Momo 无依赖</h3>
<pre><code class="language-tsx">const Outer2 = React.memo(function Outer2() {
  console.log(&quot;Outer2&quot;);
  return &lt;div&gt;Outer2&lt;/div&gt;;
});
</code></pre>
<pre><code>
App Parent 
Outer1 
Outer2 
App Parent 
Outer1
App Parent 
Outer1 
</code></pre>
<ol>
<li>只会渲染一次 父级 useState 改变不受影响</li>
</ol>
<h3>在组件外 Memo useState 依赖</h3>
<pre><code class="language-tsx">const Outer3: React.FC&lt;{ time1: string }&gt; = React.memo(function Outer3({
  time1
}) {
  console.log(&quot;Outer3 time1&quot;, time1);
  return &lt;div&gt;Outer3 {time1}&lt;/div&gt;;
});
</code></pre>
<pre><code>
App Parent 
Outer1 
Outer2 
Outer3 time1 &quot;&quot; 
App Parent 
Outer1 
Outer3 time1 1630983888577 
App Parent 
Outer1 
Outer3 time1 1630983892146 
</code></pre>
<ol>
<li>默认执行一次</li>
<li>依赖外 useState 变动不渲染</li>
<li>依赖 useState 变动渲染一次</li>
</ol>
<h3>在组件外 Memo useState 依赖 ， 内部拥有 useState</h3>
<pre><code class="language-tsx">const Outer4: React.FC&lt;{ time1: string }&gt; = React.memo(function Outer4({
  time1
}) {
  const [state, setstate] = useState(&quot;&quot;);

  console.log(&quot;Outer4&quot;);
  return (
    &lt;div&gt;
      &lt;div&gt;Outer4 state {state}&lt;/div&gt;
      &lt;div&gt;Outer4 time1 {time1}&lt;/div&gt;
      &lt;button onClick={() =&gt; setstate(String(Date.now()))}&gt;Toggle&lt;/button&gt;
    &lt;/div&gt;
  );
});
</code></pre>
<pre><code>App Parent 
Outer1 
Outer2 
Outer3 time1 &quot;&quot; 
Outer4 
App Parent 
Outer1 
App Parent 
Outer1 
Outer3 time1 1630984999782 
Outer4 
Outer4 
</code></pre>
<ol>
<li>同上</li>
<li>内部 useState 变动渲染一次</li>
</ol>
<h3>在组件外 Memo function 依赖 (在父级组件内定义)</h3>
<pre><code class="language-tsx">const Outer5: React.FC&lt;{ fn: () =&gt; void }&gt; = React.memo(function Outer5({
  fn
}) {
  const [state, setstate] = useState(&quot;&quot;);

  console.log(&quot;Outer5&quot;);
  return (
    &lt;div&gt;
      &lt;div&gt;Outer5 state {state}&lt;/div&gt;
      &lt;button onClick={() =&gt; setstate(String(Date.now()))}&gt;Toggle&lt;/button&gt;
      &lt;button onClick={() =&gt; fn()}&gt;Fn&lt;/button&gt;
    &lt;/div&gt;
  );
});

const Outer4Fn = () =&gt; {
  console.log(&quot;Outer4Fn&quot;);
};
</code></pre>
<pre><code>
App Parent 
Outer1 
Outer2 
Outer3 time1 &quot;&quot; 
Outer4 
Outer5 

App Parent 
Outer1 
Outer5 

App Parent 
Outer1 
Outer3 time1 1630985278410 
Outer4 
Outer5 

App Parent 
Outer1 
Outer3 time1 1630985281298 
Outer4 
Outer5 

Outer4Fn 
Outer4Fn 
</code></pre>
<ol>
<li>默认渲染一次</li>
<li>修改父级组件 useState 渲染一次</li>
<li>执行 fn 不渲染</li>
</ol>
<p>应该是父级渲染导致方法重新更新/定义返回了新的方法 导致渲染（这里是猜测 但是大概应该就是这样），解决这个问题需要用 useCallback 包裹方法即可, 在依赖没有变动的情况下返回相同的方法</p>
<pre><code class="language-tsx">const Outer4FnCallback = useCallback(() =&gt; {
  console.log(&quot;Outer4FnCallback&quot;);
}, []);
</code></pre>
<h3>在组件外 Memo 变量依赖(在父级组件内定义)</h3>
<pre><code class="language-tsx">const Outer6V = &quot;var&quot;;
const Outer6V = [1,2,3]


const Outer6: React.FC&lt;{ v: string }&gt; = React.memo(function Outer6({ v }) {
  console.log(&quot;Outer6&quot;, v);
  return (
    &lt;div&gt;
      &lt;div&gt;Outer6 {v}&lt;/div&gt;
    &lt;/div&gt;
  );
});
</code></pre>
<ol>
<li>字符变量 和默认 Memo 无依赖表现一致</li>
<li>数组/对象 每次父组件更新会重新渲染，返回了新的引用</li>
</ol>
<p>如果想定义对象变量又不想触发重新渲染用 useMemo包裹即可</p>
<pre><code class="language-tsx">const Outer6V = useMemo(() =&gt; {
	return { a: 1 };
}, []);
</code></pre>
<h3>在组件外 Memo 无依赖 调用外部 方法</h3>
<pre><code class="language-tsx">const Outer7Outer = () =&gt; {
  console.log(&quot;c4Test&quot;);
};

const Outer7: React.FC = React.memo(function Outer7({}) {
  const [state, setstate] = useState(&quot;&quot;);

  console.log(&quot;Outer7&quot;);
  return (
    &lt;div&gt;
      &lt;div&gt;Outer7 state {state}&lt;/div&gt;
      &lt;button onClick={() =&gt; setstate(String(Date.now()))}&gt;C4&lt;/button&gt;
      &lt;button onClick={() =&gt; Outer7Outer()}&gt;Fn&lt;/button&gt;
    &lt;/div&gt;
  );
});
</code></pre>
<ol>
<li>父级渲染不影响组件</li>
<li>方法固定引用不重新渲染</li>
</ol>
<h3>在组件外 Memo 依赖传入外部方法</h3>
<pre><code class="language-tsx">const Outer7Outer = () =&gt; {
  console.log(&quot;Outer7Outer&quot;);
};

const Outer8: React.FC&lt;{ fn: () =&gt; void }&gt; = React.memo(function Outer8({
  fn
}) {
  console.log(&quot;Outer8&quot;);
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; fn()}&gt;Fn&lt;/button&gt;
    &lt;/div&gt;
  );
});
</code></pre>
<ol>
<li>同上 没有影响</li>
</ol>
<h3>在组件外 Memo 依赖传入 Object 数据</h3>
<pre><code class="language-tsx">const Outer9: React.FC&lt;{ list: object }&gt; = React.memo(function Outer9({
  list
}) {
  console.log(&quot;Outer9&quot;);
  return (
    &lt;div&gt;
      &lt;div&gt;Outer9 {JSON.stringify(list)}&lt;/div&gt;
    &lt;/div&gt;
  );
});
</code></pre>
<ol>
<li>表现和默认 Memo 行为一样</li>
</ol>
<h3>在组件外 无 Memo 无依赖 内部 useState 变动</h3>
<pre><code class="language-tsx">const Outer10: React.FC = () =&gt; {
  console.log(&quot;Outer10&quot;);
  const [state, setstate] = useState(&quot;&quot;);

  return (
    &lt;div&gt;
      &lt;div&gt;Outer10 {state}&lt;/div&gt;
      &lt;button onClick={() =&gt; setstate(String(Date.now()))}&gt;toggle&lt;/button&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<ol>
<li>表现和默认一致</li>
</ol>
<h3>在组件外 无 Memo 依赖 useState，内部 useMemo</h3>
<pre><code class="language-tsx">const Outer11: React.FC&lt;{time1: string}&gt; = ({ time1 }) =&gt; {
  console.log(&quot;Outer11&quot;);

  const timeMemo = useMemo(() =&gt; {
    console.log(&quot;Outer11 useMemo&quot;);

    return time1 + &quot;-----&quot;;
  }, [time1]);

  return &lt;div&gt;Outer11 {timeMemo}&lt;/div&gt;;
};
</code></pre>
<ol>
<li>表现默认一致</li>
<li>useMemo 默认执行</li>
</ol>
<h3>在组件外 使用 ahooks useEventEmitter 测试</h3>
<pre><code class="language-tsx">// Parent
const focus$ = useEventEmitter();
&lt;button onClick={() =&gt; focus$.emit()}&gt;Event&lt;/button&gt;
</code></pre>
<pre><code class="language-tsx">const Outer12: React.FC&lt;{ focus$: EventEmitter&lt;void&gt; }&gt; = React.memo(
  function Outer12({ focus$ }) {
    console.log(&quot;Outer12&quot;, focus$);

    focus$.useSubscription(() =&gt; {
      console.log(&quot;Outer12 emit&quot;, focus$);
    });
    return &lt;div&gt;Outer12&lt;/div&gt;;
  }
);

const Outer13: React.FC&lt;{ focus$: EventEmitter&lt;void&gt; }&gt; = ({ focus$ }) =&gt; {
  console.log(&quot;Outer13&quot;, focus$);

  focus$.useSubscription(() =&gt; {
    console.log(&quot;Outer13 emit&quot;, focus$);
  });
  return &lt;div&gt;Outer13&lt;/div&gt;;
};
</code></pre>
<pre><code>// 默认
App Parent 
focus$ 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}
Outer12 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}
Outer13 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}

// 改变 useState
App Parent 
focus$ 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}
Outer13 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}

// 发送事件 emit
Outer12 emit 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}
Outer13 emit 
EventEmitter {subscriptions: Set, emit: ƒ (), useSubscription: ƒ (), constructor: Object}

</code></pre>
<ol>
<li>默认执行机制</li>
<li>useEventEmitter 事件不会触发渲染机制</li>
</ol>
<h3>PureComponent</h3>
<pre><code class="language-tsx">type PureProps = {
  time1: string;
};
class Pure extends React.PureComponent&lt;PureProps&gt; {

  componentDidMount() {
    console.log('Pure')
  }

  componentDidUpdate() {
    console.log(&quot;PureCp---componentDidUpdate&quot;);
  }

  render() {
    return &lt;h3&gt;PureCp: {this.props.time1}&lt;/h3&gt;;
  }
}
</code></pre>
<p><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent">https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent</a></p>
<blockquote>
<p><code>React.PureComponent</code> 与 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent"><code>React.Component</code></a> 很相似。两者的区别在于 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactcomponent"><code>React.Component</code></a> 并未实现 <a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a>，而 <code>React.PureComponent</code> 中以浅层对比 prop 和 state 的方式来实现了该函数。</p>
<p>如果赋予 React 组件相同的 props 和 state，<code>render()</code> 函数会渲染相同的内容，那么在某些情况下使用 <code>React.PureComponent</code> 可提高性能。</p>
</blockquote>
]]></description>
        </item>
        <item>
            <title><![CDATA[Vue 源码解析]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/83</link>
            <guid>https://github.com/xiaotiandada/blog/issues/83</guid>
            <pubDate>Tue, 31 Aug 2021 17:29:24 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://ustbhuangyi.github.io/vue-analysis/v2/prepare/">https://ustbhuangyi.github.io/vue-analysis/v2/prepare/</a></li>
</ul>
<h3>core/index.js</h3>
<pre><code class="language-javascript">import Vue from './instance/index'
import { initGlobalAPI } from './global-api/index'

initGlobalAPI(Vue)
</code></pre>
<h3>core/instance/index.js</h3>
<pre><code class="language-javascript">import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'
// 一个用 Function 实现的类，我们只能通过 new Vue 去实例化它。
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
// 后看这里有很多 xxxMixin 的函数调用，并把 Vue 当参数传入，它们的功能都是给 Vue 的 prototype 上扩展一些方法，
// Vue 按功能把这些扩展分散到多个模块中去实现，而不是在一个模块里实现所有，
// 这种方式是用 Class 难以实现的。这么做的好处是非常方便代码的维护和管理。
initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[DAPP]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/82</link>
            <guid>https://github.com/xiaotiandada/blog/issues/82</guid>
            <pubDate>Mon, 13 Jun 2022 13:54:27 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://github.com/aragon/use-wallet/pull/122">https://github.com/aragon/use-wallet/pull/122</a></li>
<li><a href="https://guoyu.mirror.xyz/RD-xkpoxasAU7x5MIJmiCX4gll3Cs0pAd5iM258S1Ek">https://guoyu.mirror.xyz/RD-xkpoxasAU7x5MIJmiCX4gll3Cs0pAd5iM258S1Ek</a></li>
<li><a href="https://github.com/xiaotiandada/chain-temp">chain-temp</a></li>
<li><a href="https://github.com/paulrberg/create-eth-app">create-eth-app</a></li>
<li><a href="https://github.com/TrueFiEng/useDApp">useDapp</a></li>
<li><a href="https://github.com/aragon/use-wallet">useWallet</a></li>
<li><a href="https://github.com/xiaotiandada/blog/issues/46">https://github.com/xiaotiandada/blog/issues/46</a></li>
</ul>
<h3>前端</h3>
<h4>调用合约</h4>
<ol>
<li>写 Hooks 方法</li>
</ol>
<pre><code class="language-tsx">import { useCallback, useMemo } from 'react';
import { BigNumber, ethers, utils } from 'ethers';

import { currentProvider } from 'https://data-seed-prebsc-2-s2.binance.org:8545 BSC Provider';
import { useSigner } from '看下面的 useSigner Hooks';
import { TokenFactory__factory } from '合约 Compile 出来的 Typechain 文件'

export function useTokenFactory() {
  const { signer, isSignerReady } = useSigner();
  console.log('currentContracts', currentContracts)

  const token = useMemo(() =&gt; {
    const readonlyProvider = currentProvider as ethers.providers.Provider;
    if (isSignerReady(signer)) {
      return TokenFactory__factory.connect(合约地址, signer)
    } else {
      return TokenFactory__factory.connect(合约地址, readonlyProvider)
    }
  }, [ signer, isSignerReady ])

  /**
   * 发布 Token
   */
  const mint = useCallback(
    async (
      name: string,
      symbol: string,
      initialBalance: string
    ): Promise&lt;ethers.ContractTransaction&gt; =&gt; {
    const mintToken = await token.mint(name, symbol, BigNumber.from(utils.parseUnits(initialBalance, 18)))
    console.log('mintToken', mintToken)
    console.log('mintToken hash', mintToken.hash)
    mintToken.wait()
    return mintToken
  }, [ token ])

  /**
   * 发布过的 Token
   */
  const list = useCallback(
    async (): Promise&lt;string[]&gt;  =&gt; {
      const listResult = await token.list()
      console.log('listResult', listResult)
      return listResult
  }, [ token ])

  return {
    mint, list
  }
}
</code></pre>
<ol start="2">
<li>页面调用</li>
</ol>
<pre><code class="language-tsx">  const { mint, list } = useTokenFactory()
  
  // list
  async () =&gt; {
    await list()
  }
  
  // mint
  await mint(name, symbol, initialBalance)
</code></pre>
<h4>批量查询</h4>
<pre><code class="language-tsx">// Multicall 具体可以看 Repo 里面的方法

import { ethers } from 'ethers';
import { Multicall__factory } from 'Multicall Contract';
import { currentMulticallAddress } from 'Multicall Address';
import { currentProvider } from '参考上面的 providers';

// static multicall
export const staticMulticall = Multicall__factory.connect(
  currentMulticallAddress,
  currentProvider as ethers.providers.Provider
);
</code></pre>
<pre><code class="language-tsx">import { BigNumber, ethers, utils } from 'ethers';
import { useCallback, useEffect, useState } from 'react';
import { useWallet } from 'use-wallet';

import { _abi } from '合约导出的 ABI'
import { staticMulticall } from './useMulticall';
import { chunk } from 'lodash';

interface ERC20MulticallResult {
  address: string,
  data: {
    [key: string]: string | number | ethers.BigNumber,
    name: string,
    symbol: string,
    decimals: number,
    totalSupply: ethers.BigNumber,
    balanceOf: ethers.BigNumber
  }
}

const ERC20Interface = new utils.Interface(_abi)
// console.log('ERC20Interface', ERC20Interface)

/**
 * ERC20 Multicall
 * @param address
 * @returns
 */
export function useERC20Multicall(address: string[]) {
  const { account } = useWallet();
  const [tokenData, setTokenData] = useState&lt;ERC20MulticallResult[]&gt;([])

  // fetch data
  const fetchAllAddress = useCallback(
    async () =&gt; {
      if (!address.length) {
        return
      }

      // 校验地址
      const checksAddress = address.map(i =&gt; utils.getAddress(i))

      if (!checksAddress.length) {
        return
      }

      let keys = [ 'name', 'symbol', 'decimals', 'totalSupply', 'balanceOf' ]
      const len = account ? 5 : 4

      // calls
      const calls :{ target: string,callData: string  }[] = []
      for (let i = 0; i &lt; checksAddress.length; i++) {
        const ele = checksAddress[i];
        for (let j = 0; j &lt; len; j++) {
          calls.push({
            target: ele,
            callData: ERC20Interface.encodeFunctionData(keys[j], (keys[j] === 'balanceOf' &amp;&amp; account) ? [account] : [])
          })
        }
      }

      // aggregate
      const { returnData } = await staticMulticall.callStatic.aggregate(calls)

      // merged
      const chunkReturnData = chunk(returnData, len)
      console.log('chunkReturnData', chunkReturnData)

      let result: ERC20MulticallResult[] = []
      for (let i = 0; i &lt; chunkReturnData.length; i++) {
        const ele = chunkReturnData[i];
        result[i] = {
          address: checksAddress[i],
          data: {
            name: '',
            symbol: '',
            decimals: 18,
            totalSupply: BigNumber.from(0),
            balanceOf: BigNumber.from(0),
          }
        }
        for (let j = 0; j &lt; ele.length; j++) {
          const eleJ = ele[j];
          const [ res ] = ERC20Interface.decodeFunctionResult(keys[j], eleJ)
          result[i].data[keys[j]] = res
        }
      }

      console.log('result', result)
      setTokenData(result)

      return result
  }, [ address, account ])

  useEffect(() =&gt; {
    console.log('address', address)
    fetchAllAddress()
  }, [ address, fetchAllAddress ])

  return { tokenData };
}
</code></pre>
<p>聚合查询：讲解（同样也很感谢好同事写的方法）</p>
<pre><code class="language-ts">// calls 格式, 可以根据自己的需求封装方法
const calls = [
  {
    target: address,
    callData: ERC20Interface.encodeFunctionData('key', [])
  }
]

// aggregate 聚合去查询
const { returnData } = await staticMulticall.callStatic.aggregate(calls)

// 解码数据
const [ res ] = ERC20Interface.decodeFunctionResult('key', returnData[index])
</code></pre>
<h4>批量查询余额</h4>
<p>和上面的聚合查询差不多的，批量处理 Calls 方法然后调用。(查询余额 记得带 Account)</p>
<pre><code class="language-ts">Interface.encodeFunctionData('balanceOf', [account])
</code></pre>
<h4>签名</h4>
<pre><code class="language-tsx">// 感谢俺的同事写的 Hooks 复制过来的

import { ethers } from 'ethers';
import { useMemo } from 'react';
import { useWallet } from 'use-wallet';

/**
 * 签名
 * @param addressOrIndex
 * @returns
 */
export function useSigner(addressOrIndex?: string | number) {
  const wallet = useWallet();

  const signer = useMemo(() =&gt; {
    if (!wallet.ethereum) return null;
    const provider = new ethers.providers.Web3Provider(wallet.ethereum as ReturnType&lt;typeof wallet.ethereum&gt;);
    return provider.getSigner(addressOrIndex);
  }, [wallet, addressOrIndex]);

  function isSignerReady(
    signer: ethers.providers.JsonRpcSigner | null
  ): signer is ethers.providers.JsonRpcSigner {
    return Boolean(signer);
  }

  return { signer, isSignerReady };
}
</code></pre>
<h4>Token 选择</h4>
<img src="https://user-images.githubusercontent.com/24250627/130107940-5e502cfb-592b-4f86-83f1-47dd16f149c3.png" alt="image" style="width: 300px" />
<ul>
<li>
<p>Hooks <a href="https://github.com/xiaotiandada/chain-temp/blob/master/src/hooks/useTokenList.ts">https://github.com/xiaotiandada/chain-temp/blob/master/src/hooks/useTokenList.ts</a></p>
</li>
<li>
<p>Views <a href="https://github.com/xiaotiandada/chain-temp/blob/master/src/components/TokenListSelect/index.tsx">https://github.com/xiaotiandada/chain-temp/blob/master/src/components/TokenListSelect/index.tsx</a></p>
</li>
<li>
<p>这块比较简单，Token 余额查询使用批量查询即可，搜索可以 <strong>本地+单独调用合约</strong>。</p>
</li>
</ul>
<h3>合约</h3>
<ol>
<li><a href="https://hardhat.org/getting-started/">https://hardhat.org/getting-started/</a> 按照文垱一把梭哈（可以部署到测试网 Rinkey 等）</li>
<li>Typescript 支持 <a href="https://hardhat.org/guides/typescript.html">https://hardhat.org/guides/typescript.html</a></li>
<li>导出 Type 方便前端使用 <a href="https://github.com/ethereum-ts/TypeChain/tree/master/packages/hardhat">https://github.com/ethereum-ts/TypeChain/tree/master/packages/hardhat</a></li>
<li>如果想部署到 BSC 测试网 <a href="https://docs.binance.org/smart-chain/developer/deploy/hardhat.html">https://docs.binance.org/smart-chain/developer/deploy/hardhat.html</a></li>
</ol>
<p>写了一个简单的 Demo Contract （或者使用官方例子）</p>
<pre><code class="language-javascript">pragma solidity ^0.8.0;

import &quot;hardhat/console.sol&quot;;
import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;

// ERC20 Token
contract Token is ERC20 {
    constructor(
        string memory name,
        string memory symbol,
        uint256 initialBalance
    ) public ERC20(name, symbol) {
        _mint(msg.sender, initialBalance);
    }
}

// Create ERC20 Token
contract TokenFactory {
    constructor() {}

    address[] public contracts;

    // mint
    function mint(
        string memory name,
        string memory symbol,
        uint256 initialBalance
    ) public {
        console.log(&quot;Create ERC20&quot;);
        address contractAddress = address(
            new Token(name, symbol, initialBalance)
        );
        console.log(&quot;contractAddress '%s'&quot;, contractAddress);
        contracts.push(contractAddress);
    }

    function list() public view returns (address[] memory) {
        return contracts;
    }
}
</code></pre>
<p><strong>总结</strong> 两个方法 Address：0x008c5c5cb4196719cbb61050d41BeEdAF01c5726</p>
<ul>
<li>Mint ERC20 Token 然后保存合约地址 （mint）</li>
<li>查询 Mint 过的合约地址（list）</li>
</ul>
<p>Compile 之后会生成 typechain 文件方便前端用，也可以自己用第三方工具快速生成 DAPP 方法调用，传入 Contract Address 和ABI就好了</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Intersection Observer API]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/81</link>
            <guid>https://github.com/xiaotiandada/blog/issues/81</guid>
            <pubDate>Sun, 20 Jun 2021 17:03:37 GMT</pubDate>
            <description><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API">https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API</a></p>
<p>Intersection Observer API提供了一种异步检测目标元素与祖先元素或 viewport 相交情况变化的方法。</p>
<p>// TODO：等补充</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Document.createElementNS() API]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/80</link>
            <guid>https://github.com/xiaotiandada/blog/issues/80</guid>
            <pubDate>Sun, 20 Jun 2021 16:51:08 GMT</pubDate>
            <description><![CDATA[<p>创建一个具有指定的命名空间URI和限定名称的元素。</p>
<p>要创建一个元素而不指定命名空间URI，请使用  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createElement">createElement</a> 方法。</p>
<p><a href="https://segmentfault.com/a/1190000021258267">https://segmentfault.com/a/1190000021258267</a> 等补充...</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[document.createComment API]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/79</link>
            <guid>https://github.com/xiaotiandada/blog/issues/79</guid>
            <pubDate>Sun, 20 Jun 2021 16:20:50 GMT</pubDate>
            <description><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createComment">https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createComment</a></p>
<p>createComment() 方法用来创建并返回一个注释节点.</p>
<pre><code class="language-javascript">var commentNode = document.createComment('注释')

document.querySelector('body').appendChild(commentNode)
</code></pre>
<p><img src="https://user-images.githubusercontent.com/24250627/122681283-15b97d00-d226-11eb-9742-b1c0695f8278.png" alt="image"></p>
<p>api 是在看 snabbdom 源码的时候发现的</p>
<pre><code class="language-javascript">// init.ts

const sel = vnode.sel;
if (sel === &quot;!&quot;) {
  if (isUndef(vnode.text)) {
    vnode.text = &quot;&quot;;
  }
  vnode.elm = api.createComment(vnode.text!);
}

h(&quot;!&quot;, &quot;注释&quot;),
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[Vue Virtual Dom]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/78</link>
            <guid>https://github.com/xiaotiandada/blog/issues/78</guid>
            <pubDate>Tue, 05 Apr 2022 17:33:16 GMT</pubDate>
            <description><![CDATA[<p><a href="https://github.com/creeperyang/blog/issues/33">解析 snabbdom 源码，教你实现精简的 Virtual DOM 库</a></p>
<p><a href="https://juejin.cn/post/6844903671906435080#heading-1">snabbdom 源码阅读分析</a></p>
<p><a href="https://juejin.cn/post/6844903831717806087">https://juejin.cn/post/6844903831717806087</a></p>
<p><a href="https://gzg.me/posts/2021/snabbdom_source/">https://gzg.me/posts/2021/snabbdom_source/</a></p>
<p><a href="https://www.cnblogs.com/xuntu/p/6800547.html">https://www.cnblogs.com/xuntu/p/6800547.html</a></p>
<blockquote>
<p>通常情况下，找到两棵任意的树之间最小修改的时间复杂度是 <strong>O(n^3)</strong>，这不可接受。幸好，我们可以对 Virtual DOM 树有这样的假设：</p>
<p>如果 oldVnode 和 vnode 不同（如 type 从 <code>div</code> 变到 <code>p</code>，或者 <code>key</code> 改变），意味着整个 vnode 被替换（因为我们通常不会去跨层移动 vnode ），所以我们没有必要去比较 vnode 的 子 vnode（children） 了。基于这个假设，我们可以 <strong>按照层级分解</strong> 树，这大大简化了复杂度，大到接近 <strong>O(n)</strong> 的复杂度：</p>
<p><img src="https://user-images.githubusercontent.com/8046480/27190439-0a875688-5227-11e7-9015-eb34142de8ce.png" alt=""></p>
<p>此外，对于 children （数组）的比较，因为同层是很可能有移动的，顺
序比较会无法最大化复用已有的 DOM。所以我们通过为每个 vnode 加上 key 来追踪这种顺序变动。</p>
<p><img src="https://user-images.githubusercontent.com/8046480/27191679-28085118-522b-11e7-92e9-fa0ed047f7cd.png" alt=""></p>
</blockquote>
<blockquote>
<ul>
<li>用 js 对象来描述 dom 树结构，然后用这个 js 对象来创建一棵真正的 dom 树，插入到文档中</li>
<li>当状态更新时，将新的 js 对象和旧的 js 对象进行比较，得到两个对象之间的差异</li>
<li>将差异应用到真正的 dom 上</li>
</ul>
</blockquote>
<h3>vnode</h3>
<pre><code class="language-typescript">// https://github.com/snabbdom/snabbdom/blob/master/src/vnode.ts
// ...
export type Key = string | number | symbol;

export interface VNode {
  sel: string | undefined;
  data: VNodeData | undefined;
  children: Array&lt;VNode | string&gt; | undefined;
  elm: Node | undefined;
  text: string | undefined;
  key: Key | undefined;
}

export interface VNodeData {
  props?: Props;
  attrs?: Attrs;
  class?: Classes;
  style?: VNodeStyle;
  dataset?: Dataset;
  on?: On;
  attachData?: AttachData;
  hook?: Hooks;
  key?: Key;
  ns?: string; // for SVGs
  fn?: () =&gt; VNode; // for thunks
  args?: any[]; // for thunks
  is?: string; // for custom elements v1
  [key: string]: any; // for any other 3rd party module
}

export function vnode(
  sel: string | undefined,
  data: any | undefined,
  children: Array&lt;VNode | string&gt; | undefined,
  text: string | undefined,
  elm: Element | Text | undefined
): VNode {
  const key = data === undefined ? undefined : data.key;
  return { sel, data, children, text, elm, key };
}
</code></pre>
<h3>init</h3>
<pre><code class="language-typescript">// https://github.com/snabbdom/snabbdom/blob/master/src/init.ts
import { Module } from &quot;./modules/module&quot;;
import { vnode, VNode } from &quot;./vnode&quot;;
import * as is from &quot;./is&quot;;
import { htmlDomApi, DOMAPI } from &quot;./htmldomapi&quot;;

type NonUndefined&lt;T&gt; = T extends undefined ? never : T;

function isUndef(s: any): boolean {
  return s === undefined;
}
function isDef&lt;A&gt;(s: A): s is NonUndefined&lt;A&gt; {
  return s !== undefined;
}

type VNodeQueue = VNode[];

const emptyNode = vnode(&quot;&quot;, {}, [], undefined, undefined);

function sameVnode(vnode1: VNode, vnode2: VNode): boolean {
  const isSameKey = vnode1.key === vnode2.key;
  const isSameIs = vnode1.data?.is === vnode2.data?.is;
  const isSameSel = vnode1.sel === vnode2.sel;

  return isSameSel &amp;&amp; isSameKey &amp;&amp; isSameIs;
}

function isVnode(vnode: any): vnode is VNode {
  return vnode.sel !== undefined;
}

type KeyToIndexMap = { [key: string]: number };

type ArraysOf&lt;T&gt; = {
  [K in keyof T]: Array&lt;T[K]&gt;;
};

type ModuleHooks = ArraysOf&lt;Required&lt;Module&gt;&gt;;

function createKeyToOldIdx(
  children: VNode[],
  beginIdx: number,
  endIdx: number
): KeyToIndexMap {
  const map: KeyToIndexMap = {};
  for (let i = beginIdx; i &lt;= endIdx; ++i) {
    const key = children[i]?.key;
    if (key !== undefined) {
      map[key as string] = i;
    }
  }
  return map;
}

const hooks: Array&lt;keyof Module&gt; = [
  &quot;create&quot;,
  &quot;update&quot;,
  &quot;remove&quot;,
  &quot;destroy&quot;,
  &quot;pre&quot;,
  &quot;post&quot;,
];

export function init(modules: Array&lt;Partial&lt;Module&gt;&gt;, domApi?: DOMAPI) {
  let i: number;
  let j: number;
  // 收集 module in the hook
  const cbs: ModuleHooks = {
    create: [],
    update: [],
    remove: [],
    destroy: [],
    pre: [],
    post: [],
  };
	
  // 如果没有传递 domApi 使用浏览器中和 dom 相关的 api 
  // https://github.com/snabbdom/snabbdom/blob/master/src/htmldomapi.ts
  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;
	
  // 收集 module in the hook
  for (i = 0; i &lt; hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j &lt; modules.length; ++j) {
      const hook = modules[j][hooks[i]];
      if (hook !== undefined) {
        (cbs[hooks[i]] as any[]).push(hook);
      }
    }
  }

  function emptyNodeAt(elm: Element) {
    const id = elm.id ? &quot;#&quot; + elm.id : &quot;&quot;;

    // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.
    // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring
    // weex https://github.com/vuejs/vue/blob/dev/src/platforms/weex/runtime/node-ops.js
    const classes = elm.getAttribute(&quot;class&quot;);

    const c = classes ? &quot;.&quot; + classes.split(&quot; &quot;).join(&quot;.&quot;) : &quot;&quot;;
    return vnode(
      api.tagName(elm).toLowerCase() + id + c,
      {},
      [],
      undefined,
      elm
    );
  }

  function createRmCb(childElm: Node, listeners: number) {
    return function rmCb() {
      if (--listeners === 0) {
        const parent = api.parentNode(childElm) as Node;
        api.removeChild(parent, childElm);
      }
    };
  }

  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {
    let i: any;
    let data = vnode.data;
    if (data !== undefined) {
      const init = data.hook?.init;
      if (isDef(init)) {
        init(vnode);
        data = vnode.data;
      }
    }
    const children = vnode.children;
    const sel = vnode.sel;
    if (sel === &quot;!&quot;) {
      if (isUndef(vnode.text)) {
        vnode.text = &quot;&quot;;
      }
      vnode.elm = api.createComment(vnode.text!);
    } else if (sel !== undefined) {
      // Parse selector
      const hashIdx = sel.indexOf(&quot;#&quot;);
      const dotIdx = sel.indexOf(&quot;.&quot;, hashIdx);
      const hash = hashIdx &gt; 0 ? hashIdx : sel.length;
      const dot = dotIdx &gt; 0 ? dotIdx : sel.length;
      const tag =
        hashIdx !== -1 || dotIdx !== -1
          ? sel.slice(0, Math.min(hash, dot))
          : sel;
      const elm = (vnode.elm =
        isDef(data) &amp;&amp; isDef((i = data.ns))
          ? api.createElementNS(i, tag, data)
          : api.createElement(tag, data));
      if (hash &lt; dot) elm.setAttribute(&quot;id&quot;, sel.slice(hash + 1, dot));
      if (dotIdx &gt; 0)
        elm.setAttribute(&quot;class&quot;, sel.slice(dot + 1).replace(/\./g, &quot; &quot;));
      for (i = 0; i &lt; cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
      if (is.array(children)) {
        for (i = 0; i &lt; children.length; ++i) {
          const ch = children[i];
          if (ch != null) {
            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));
          }
        }
      } else if (is.primitive(vnode.text)) {
        api.appendChild(elm, api.createTextNode(vnode.text));
      }
      const hook = vnode.data!.hook;
      if (isDef(hook)) {
        hook.create?.(emptyNode, vnode);
        if (hook.insert) {
          insertedVnodeQueue.push(vnode);
        }
      }
    } else {
      vnode.elm = api.createTextNode(vnode.text!);
    }
    return vnode.elm;
  }

  function addVnodes(
    parentElm: Node,
    before: Node | null,
    vnodes: VNode[],
    startIdx: number,
    endIdx: number,
    insertedVnodeQueue: VNodeQueue
  ) {
    for (; startIdx &lt;= endIdx; ++startIdx) {
      const ch = vnodes[startIdx];
      if (ch != null) {
        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
      }
    }
  }

  function invokeDestroyHook(vnode: VNode) {
    const data = vnode.data;
    if (data !== undefined) {
      data?.hook?.destroy?.(vnode);
      for (let i = 0; i &lt; cbs.destroy.length; ++i) cbs.destroy[i](vnode);
      if (vnode.children !== undefined) {
        for (let j = 0; j &lt; vnode.children.length; ++j) {
          const child = vnode.children[j];
          if (child != null &amp;&amp; typeof child !== &quot;string&quot;) {
            invokeDestroyHook(child);
          }
        }
      }
    }
  }

  function removeVnodes(
    parentElm: Node,
    vnodes: VNode[],
    startIdx: number,
    endIdx: number
  ): void {
    for (; startIdx &lt;= endIdx; ++startIdx) {
      let listeners: number;
      let rm: () =&gt; void;
      const ch = vnodes[startIdx];
      if (ch != null) {
        if (isDef(ch.sel)) {
          invokeDestroyHook(ch);
          listeners = cbs.remove.length + 1;
          rm = createRmCb(ch.elm!, listeners);
          for (let i = 0; i &lt; cbs.remove.length; ++i) cbs.remove[i](ch, rm);
          const removeHook = ch?.data?.hook?.remove;
          if (isDef(removeHook)) {
            removeHook(ch, rm);
          } else {
            rm();
          }
        } else {
          // Text node
          api.removeChild(parentElm, ch.elm!);
        }
      }
    }
  }

  function updateChildren(
    parentElm: Node,
    oldCh: VNode[],
    newCh: VNode[],
    insertedVnodeQueue: VNodeQueue
  ) {
    let oldStartIdx = 0;
    let newStartIdx = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];
    let oldEndVnode = oldCh[oldEndIdx];
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let oldKeyToIdx: KeyToIndexMap | undefined;
    let idxInOld: number;
    let elmToMove: VNode;
    let before: any;

    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {
      if (oldStartVnode == null) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx];
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(
          parentElm,
          oldStartVnode.elm!,
          api.nextSibling(oldEndVnode.elm!)
        );
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (oldKeyToIdx === undefined) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = oldKeyToIdx[newStartVnode.key as string];
        if (isUndef(idxInOld)) {
          // New element
          api.insertBefore(
            parentElm,
            createElm(newStartVnode, insertedVnodeQueue),
            oldStartVnode.elm!
          );
        } else {
          elmToMove = oldCh[idxInOld];
          if (elmToMove.sel !== newStartVnode.sel) {
            api.insertBefore(
              parentElm,
              createElm(newStartVnode, insertedVnodeQueue),
              oldStartVnode.elm!
            );
          } else {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined as any;
            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) {
      if (oldStartIdx &gt; oldEndIdx) {
        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
        addVnodes(
          parentElm,
          before,
          newCh,
          newStartIdx,
          newEndIdx,
          insertedVnodeQueue
        );
      } else {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }
  }

  function patchVnode(
    oldVnode: VNode,
    vnode: VNode,
    insertedVnodeQueue: VNodeQueue
  ) {
    const hook = vnode.data?.hook;
    hook?.prepatch?.(oldVnode, vnode);
    const elm = (vnode.elm = oldVnode.elm)!;
    const oldCh = oldVnode.children as VNode[];
    const ch = vnode.children as VNode[];
    if (oldVnode === vnode) return;
    if (vnode.data !== undefined) {
      for (let i = 0; i &lt; cbs.update.length; ++i)
        cbs.update[i](oldVnode, vnode);
      vnode.data.hook?.update?.(oldVnode, vnode);
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) &amp;&amp; isDef(ch)) {
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) api.setTextContent(elm, &quot;&quot;);
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        api.setTextContent(elm, &quot;&quot;);
      }
    } else if (oldVnode.text !== vnode.text) {
      if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      }
      api.setTextContent(elm, vnode.text!);
    }
    hook?.postpatch?.(oldVnode, vnode);
  }

  return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {
    let i: number, elm: Node, parent: Node;
    const insertedVnodeQueue: VNodeQueue = [];
    for (i = 0; i &lt; cbs.pre.length; ++i) cbs.pre[i]();

    if (!isVnode(oldVnode)) {
      oldVnode = emptyNodeAt(oldVnode);
    }

    if (sameVnode(oldVnode, vnode)) {
      patchVnode(oldVnode, vnode, insertedVnodeQueue);
    } else {
      elm = oldVnode.elm!;
      parent = api.parentNode(elm) as Node;

      createElm(vnode, insertedVnodeQueue);

      if (parent !== null) {
        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));
        removeVnodes(parent, [oldVnode], 0, 0);
      }
    }

    for (i = 0; i &lt; insertedVnodeQueue.length; ++i) {
      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);
    }
    for (i = 0; i &lt; cbs.post.length; ++i) cbs.post[i]();
    return vnode;
  };
}

</code></pre>
<h3>h</h3>
<pre><code class="language-typescript">import { vnode, VNode, VNodeData } from &quot;./vnode&quot;;
import * as is from &quot;./is&quot;;

export type VNodes = VNode[];
export type VNodeChildElement = VNode | string | number | undefined | null;
export type ArrayOrElement&lt;T&gt; = T | T[];
export type VNodeChildren = ArrayOrElement&lt;VNodeChildElement&gt;;

function addNS(
  data: any,
  children: VNodes | undefined,
  sel: string | undefined
): void {
  data.ns = &quot;http://www.w3.org/2000/svg&quot;;
  if (sel !== &quot;foreignObject&quot; &amp;&amp; children !== undefined) {
    for (let i = 0; i &lt; children.length; ++i) {
      const childData = children[i].data;
      if (childData !== undefined) {
        addNS(childData, children[i].children as VNodes, children[i].sel);
      }
    }
  }
}

export function h(sel: string): VNode;
export function h(sel: string, data: VNodeData | null): VNode;
export function h(sel: string, children: VNodeChildren): VNode;
export function h(
  sel: string,
  data: VNodeData | null,
  children: VNodeChildren
): VNode;
export function h(sel: any, b?: any, c?: any): VNode {
  let data: VNodeData = {};
  let children: any;
  let text: any;
  let i: number;
  // c 不为空 可能是 [] / string
  if (c !== undefined) {
    // b 不为空 有 {} options (认为是 VNodeData)
    if (b !== null) {
      data = b;
    }
    // 如果 c 是 []
    if (is.array(c)) {
      children = c;
    } else if (is.primitive(c)) { // c 是 string / number 应该认为是 text node
      text = c;
    } else if (c &amp;&amp; c.sel) { // TODO: 应该是 h 拥有 sel, 然后认为是 [ c ]
      children = [c];
    }
  } else if (b !== undefined &amp;&amp; b !== null) { // 如果是 b 不为空
    // 如果是 array 说明是 VNodeChildren
    if (is.array(b)) {
      children = b;
    } else if (is.primitive(b)) { // 如果是 string/number 应该认为是 text node
      text = b;
    } else if (b &amp;&amp; b.sel) { // TODO: 应该是 h 拥有 sel, 然后认为是 [ b ]
      children = [b];
    } else { // 认为 b 是 VNodeData
      data = b;
    }
  }
  // 如果存在 children
  if (children !== undefined) {
    for (i = 0; i &lt; children.length; ++i) {
      // 如果每个 children 是 string/number 转换成 vnode
      if (is.primitive(children[i]))
        children[i] = vnode(
          undefined,
          undefined,
          undefined,
          children[i],
          undefined
        );
    }
  }
  // 如果是 svg 添加 namespace
  if (
    sel[0] === &quot;s&quot; &amp;&amp;
    sel[1] === &quot;v&quot; &amp;&amp;
    sel[2] === &quot;g&quot; &amp;&amp;
    (sel.length === 3 || sel[3] === &quot;.&quot; || sel[3] === &quot;#&quot;)
  ) {
    addNS(data, children, sel);
  }
  return vnode(sel, data, children, text, undefined);
}
</code></pre>
<h3>patch</h3>
<pre><code class="language-typescript">// 调用 init 返回 patch  

  function emptyNodeAt(elm: Element) {
    const id = elm.id ? &quot;#&quot; + elm.id : &quot;&quot;;

    // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.
    // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring
    const classes = elm.getAttribute(&quot;class&quot;);

    const c = classes ? &quot;.&quot; + classes.split(&quot; &quot;).join(&quot;.&quot;) : &quot;&quot;;
    // document.querySelector('div').tagName =&gt; DIV
    // div#id.classa.classb / div#id / div.class / div
    return vnode(
      api.tagName(elm).toLowerCase() + id + c,
      {},
      [],
      undefined,
      elm
    );
  }

return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {
    let i: number, elm: Node, parent: Node;
    const insertedVnodeQueue: VNodeQueue = [];
	  // 调用 module 中的 pre hook 
    for (i = 0; i &lt; cbs.pre.length; ++i) cbs.pre[i]();
		
	  // 如果 oldVnode 是 Element 转换为空的 vnode
    if (!isVnode(oldVnode)) {
      oldVnode = emptyNodeAt(oldVnode);
    }
			
   	// &gt; 如果相同，调用 patchVnode，如果不相同，会调用 createElm 来创建一个新的 dom 节点，然后如果存在父节点，便将其插入到 dom 上，然后移除旧的 dom 节点来完成更新。
  
	  // oldVnode vnode sel key is 相同
    if (sameVnode(oldVnode, vnode)) {
      patchVnode(oldVnode, vnode, insertedVnodeQueue);
    } else {
      elm = oldVnode.elm!;
      // ele parentNode
      parent = api.parentNode(elm) as Node;
			// 创建
      createElm(vnode, insertedVnodeQueue);
			
      // 有父节点
      if (parent !== null) {
        // insert dom
        api.insertBefore(parent, vnode.elm!, api.nextSibling(elm));
        // remove vnode
        removeVnodes(parent, [oldVnode], 0, 0);
      }
    }
		
  // 调用元素上的 insert hook，insert  hook 在 module 上不支持
    for (i = 0; i &lt; insertedVnodeQueue.length; ++i) {
      insertedVnodeQueue[i].data!.hook!.insert!(insertedVnodeQueue[i]);
    }
	  // 调用 module post hook
    for (i = 0; i &lt; cbs.post.length; ++i) cbs.post[i]();
    return vnode;
  };
</code></pre>
<blockquote>
<p>The following hooks are available for modules: <code>pre</code>, <code>create</code>, <code>update</code>, <code>destroy</code>, <code>remove</code>, <code>post</code></p>
<p>The following hooks are available in the <code>hook</code> property of individual elements: <code>init</code>, <code>create</code>, <code>insert</code>, <code>prepatch</code>, <code>update</code>, <code>postpatch</code>, <code>destroy</code>, <code>remove</code>.</p>
</blockquote>
<h3>createElm</h3>
<pre><code class="language-typescript">  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {
    let i: any;
    let data = vnode.data;
    // 调用元素的 init hook
    if (data !== undefined) {
      const init = data.hook?.init;
      if (isDef(init)) {
        init(vnode);
        data = vnode.data;
      }
    }
    const children = vnode.children;
    
    // 创建注释节点
    const sel = vnode.sel;
    if (sel === &quot;!&quot;) {
      if (isUndef(vnode.text)) {
        vnode.text = &quot;&quot;;
      }
      vnode.elm = api.createComment(vnode.text!);
    } else if (sel !== undefined) {
      // Parse selector
      const hashIdx = sel.indexOf(&quot;#&quot;);
      const dotIdx = sel.indexOf(&quot;.&quot;, hashIdx);
      // div#box
      const hash = hashIdx &gt; 0 ? hashIdx : sel.length;
      // div.boxclass
      const dot = dotIdx &gt; 0 ? dotIdx : sel.length;
      const tag =
        hashIdx !== -1 || dotIdx !== -1
          ? sel.slice(0, Math.min(hash, dot))
          : sel;
      const elm = (vnode.elm =
        isDef(data) &amp;&amp; isDef((i = data.ns))
          ? api.createElementNS(i, tag, data)
          : api.createElement(tag, data));
      if (hash &lt; dot) elm.setAttribute(&quot;id&quot;, sel.slice(hash + 1, dot));
      if (dotIdx &gt; 0)
        elm.setAttribute(&quot;class&quot;, sel.slice(dot + 1).replace(/\./g, &quot; &quot;));
      // 调用 module 的 create hook
      for (i = 0; i &lt; cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
      // 挂在子节点
      if (is.array(children)) {
        for (i = 0; i &lt; children.length; ++i) {
          const ch = children[i];
          if (ch != null) {
            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));
          }
        }
      } else if (is.primitive(vnode.text)) {
        // 插入 文本节点
        api.appendChild(elm, api.createTextNode(vnode.text));
      }
      // 执行 vnode data hook
      const hook = vnode.data!.hook;
      if (isDef(hook)) {
        // 执行 hook create
        hook.create?.(emptyNode, vnode);
        if (hook.insert) {
          // insert hook 存储起来 等 dom 插入后才会调用，这里用个数组来保存能避免调用时再次对 vnode 树做遍历
          insertedVnodeQueue.push(vnode);
        }
      }
    } else {
      // 文本节点
      vnode.elm = api.createTextNode(vnode.text!);
    }
    return vnode.elm;
  }
</code></pre>
<h3>patchVnode</h3>
<pre><code class="language-typescript">function patchVnode(
    oldVnode: VNode,
    vnode: VNode,
    insertedVnodeQueue: VNodeQueue
  ) {
    const hook = vnode.data?.hook;
    // 执行 prepatch hook
    hook?.prepatch?.(oldVnode, vnode);
    const elm = (vnode.elm = oldVnode.elm)!;
    const oldCh = oldVnode.children as VNode[];
    const ch = vnode.children as VNode[];
     // 新 旧 vnode 相同
    if (oldVnode === vnode) return;
    // 执行 cbs update hook，vnode update hook
    if (vnode.data !== undefined) {
      for (let i = 0; i &lt; cbs.update.length; ++i)
        cbs.update[i](oldVnode, vnode);
      vnode.data.hook?.update?.(oldVnode, vnode);
    }
    // 是没有定义的
    if (isUndef(vnode.text)) {
      // 均存在 children 且不相同，调用 updateChildren
    
      // 定义过 children
      if (isDef(oldCh) &amp;&amp; isDef(ch)) {
        // old children 不等于 new children
        // 更新 updateChildren
        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
      } else if (isDef(ch)) { // 只定义了 new children
        // 新 vnode 存在 children，旧 vnode 不存在 children，如果旧 vnode 存在 text 先清空，然后调用 addVnodes
        
        // 如果是 text，设置内容
        if (isDef(oldVnode.text)) api.setTextContent(elm, &quot;&quot;);
        // 添加 vnode
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) { // 只定义 old children
        // 新 vnode 不存在 children，旧 vnode 存在 children，调用 removeVnodes 移除 children
        
        // 移除 vnode
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) { // 只定义了 old vnode text
        // 设置内容
        api.setTextContent(elm, &quot;&quot;);
      }
    } else if (oldVnode.text !== vnode.text) { // old vnode text 和 new vnode text 不一样
      // 均不存在 children，新 vnode 不存在 text，移除旧 vnode 的 text
      
      // 如果定义了 old children
      if (isDef(oldCh)) {
        // 移除
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      }
      // 均存在 text，更新 text
      
      // 设置新内容
      api.setTextContent(elm, vnode.text!);
    }
    // 执行 postpatch hook
    hook?.postpatch?.(oldVnode, vnode);
  }
</code></pre>
<h3>updateChildren</h3>
<pre><code class="language-typescript">  function updateChildren(
    parentElm: Node,
    oldCh: VNode[],
    newCh: VNode[],
    insertedVnodeQueue: VNodeQueue
  ) {
    let oldStartIdx = 0; // 旧 头 索引
    let newStartIdx = 0; // 新 头 索引
    let oldEndIdx = oldCh.length - 1; // 旧 尾 索引
    let oldStartVnode = oldCh[0]; // 旧 头 Vnode
    let oldEndVnode = oldCh[oldEndIdx]; // 旧 尾 Vnode
    let newEndIdx = newCh.length - 1; // 新 尾 索引
    let newStartVnode = newCh[0]; // 新 头 Vnode
    let newEndVnode = newCh[newEndIdx]; // 新 尾 Vnode
    let oldKeyToIdx: KeyToIndexMap | undefined;
    let idxInOld: number;
    let elmToMove: VNode;
    let before: any;

    // 循环 从 头 到 尾 处理（新/旧）
    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {
      // 如果 头尾（新/旧）其中有为 null 重新赋值，并且为元素数组中 添加/减少 一位
      if (oldStartVnode == null) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx];
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx];

        // 如果相同 对比 新/旧 内容变化然后更新 DOM
        // 新/旧 头Vnode 赋值
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];

        // 节点移动到右边 更新 DOM
        // 把更新的内容移动插入到旧节点最后
        // 旧头索引 ++
        // 新尾索引 --
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(
          parentElm,
          oldStartVnode.elm!,
          api.nextSibling(oldEndVnode.elm!)
        );
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];

        // 节点移动到左边 更新 DOM
        // 把更新的内容移动插入到旧节点最前
        // 旧尾 --
        // 新头 ++
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm!, oldStartVnode.elm!);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];


        // 如果不是以上情况
        // 开始节点是一个新节点
        // 如果没有 key，创建 DOM 插入到前方
        // 如果有 key，判断 sel 是否相同，如果不同创建 DOM 如果相同则代表是相同节点
      } else {

        // 方便通过新节点的key找到旧节点数组的索引
        if (oldKeyToIdx === undefined) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        // 用新节点的key 找到老节点的索引
        idxInOld = oldKeyToIdx[newStartVnode.key as string];

        // 如果是新节点
        if (isUndef(idxInOld)) {
          // New element
          api.insertBefore(
            parentElm,
            createElm(newStartVnode, insertedVnodeQueue),
            oldStartVnode.elm!
          );
        } else {
          // 旧节点
          // 取出旧节点
          elmToMove = oldCh[idxInOld];
          // 新元素 直接创建一个新的插入
          if (elmToMove.sel !== newStartVnode.sel) {
            api.insertBefore(
              parentElm,
              createElm(newStartVnode, insertedVnodeQueue),
              oldStartVnode.elm!
            );
          } else {
            // 没有修改过 更新内部 DOM
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            // 把旧节点相应位置的元素设置为undefined
            oldCh[idxInOld] = undefined as any;
            api.insertBefore(parentElm, elmToMove.elm!, oldStartVnode.elm!);
          }
        }
        // 插入完成后，索引增加
        newStartVnode = newCh[++newStartIdx];
      }
    }

    // 老节点 或 新节点遍历完成
    if (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) {
      if (oldStartIdx &gt; oldEndIdx) {
        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
        addVnodes(
          parentElm,
          before,
          newCh,
          newStartIdx,
          newEndIdx,
          insertedVnodeQueue
        );
      } else {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }
  }
</code></pre>
<h3>addVnodes</h3>
<pre><code class="language-typescript">  function addVnodes(
    parentElm: Node,
    before: Node | null,
    vnodes: VNode[],
    startIdx: number,
    endIdx: number,
    insertedVnodeQueue: VNodeQueue
  ) {
    for (; startIdx &lt;= endIdx; ++startIdx) {
      const ch = vnodes[startIdx];
      if (ch != null) {
        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
      }
    }
  }
</code></pre>
<h3>removeVnodes</h3>
<pre><code class="language-typescript">
  function removeVnodes(
    parentElm: Node,
    vnodes: VNode[],
    startIdx: number,
    endIdx: number
  ): void {
    for (; startIdx &lt;= endIdx; ++startIdx) {
      let listeners: number;
      let rm: () =&gt; void;
      const ch = vnodes[startIdx];
      if (ch != null) {
        if (isDef(ch.sel)) {
          // ˙执行 ch data destroy hook
          invokeDestroyHook(ch);
          listeners = cbs.remove.length + 1;
          rm = createRmCb(ch.elm!, listeners);
          // 调用 module 中是 remove hook
          for (let i = 0; i &lt; cbs.remove.length; ++i) cbs.remove[i](ch, rm);
           // 调用 vnode 的 remove hook
          const removeHook = ch?.data?.hook?.remove;
          if (isDef(removeHook)) {
            removeHook(ch, rm);
          } else {
            rm();
          }
        } else {
          // Text node
          api.removeChild(parentElm, ch.elm!);
        }
      }
    }
  }

// 调用 destroy hook
function invokeDestroyHook(vnode: VNode) {
  const data = vnode.data;
  if (data !== undefined) {
    data?.hook?.destroy?.(vnode);
    for (let i = 0; i &lt; cbs.destroy.length; ++i) cbs.destroy[i](vnode);
    if (vnode.children !== undefined) {
      for (let j = 0; j &lt; vnode.children.length; ++j) {
        const child = vnode.children[j];
        if (child != null &amp;&amp; typeof child !== &quot;string&quot;) {
          invokeDestroyHook(child);
        }
      }
    }
  }
}


function createRmCb(childElm: Node, listeners: number) {
  return function rmCb() {
    if (--listeners === 0) {
      const parent = api.parentNode(childElm) as Node;
      api.removeChild(parent, childElm);
    }
  };
}
</code></pre>
<h3>createElm</h3>
<pre><code class="language-typescript">  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {
    let i: any;
    let data = vnode.data;
    if (data !== undefined) {
      // 调用 init hook
      const init = data.hook?.init;
      if (isDef(init)) {
        init(vnode);
        data = vnode.data;
      }
    }
    const children = vnode.children;
    const sel = vnode.sel;
    if (sel === &quot;!&quot;) { // 注释
      if (isUndef(vnode.text)) {
        vnode.text = &quot;&quot;;
      }
      vnode.elm = api.createComment(vnode.text!);
    } else if (sel !== undefined) {
      // Parse selector
      const hashIdx = sel.indexOf(&quot;#&quot;);
      const dotIdx = sel.indexOf(&quot;.&quot;, hashIdx);
      const hash = hashIdx &gt; 0 ? hashIdx : sel.length;
      const dot = dotIdx &gt; 0 ? dotIdx : sel.length;
      const tag =
        hashIdx !== -1 || dotIdx !== -1
          ? sel.slice(0, Math.min(hash, dot))
          : sel;
      const elm = (vnode.elm =
        isDef(data) &amp;&amp; isDef((i = data.ns))
          ? api.createElementNS(i, tag, data)
          : api.createElement(tag, data));
      if (hash &lt; dot) elm.setAttribute(&quot;id&quot;, sel.slice(hash + 1, dot));
      if (dotIdx &gt; 0)
        elm.setAttribute(&quot;class&quot;, sel.slice(dot + 1).replace(/\./g, &quot; &quot;));
      for (i = 0; i &lt; cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
      if (is.array(children)) {
        for (i = 0; i &lt; children.length; ++i) {
          const ch = children[i];
          if (ch != null) {
            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));
          }
        }
      } else if (is.primitive(vnode.text)) {
        api.appendChild(elm, api.createTextNode(vnode.text));
      }
      // 调用 create hook
      const hook = vnode.data!.hook;
      if (isDef(hook)) {
        hook.create?.(emptyNode, vnode);
        if (hook.insert) {
          insertedVnodeQueue.push(vnode);
        }
      }
    } else {
      vnode.elm = api.createTextNode(vnode.text!);
    }
    return vnode.elm;
  }
</code></pre>
<h3>thunk</h3>
<pre><code class="language-typescript">export interface ThunkData extends VNodeData {
  fn: () =&gt; VNode;
  args: any[];
}

export interface Thunk extends VNode {
  data: ThunkData;
}

export interface ThunkFn {
  (sel: string, fn: (...args: any[]) =&gt; any, args: any[]): Thunk;
  (sel: string, key: any, fn: (...args: any[]) =&gt; any, args: any[]): Thunk;
}

// thunk  fn 、 args 属性保存到 vnode 上，在 prepatch 时需要进行比较
// 将 vnode 上的数据拷贝到 thunk 上， patchVnode 中判断，相同会结束 patchVnode
function copyToThunk(vnode: VNode, thunk: VNode): void {
  (vnode.data as VNodeData).fn = (thunk.data as VNodeData).fn;
  (vnode.data as VNodeData).args = (thunk.data as VNodeData).args;
  thunk.data = vnode.data;
  thunk.children = vnode.children;
  thunk.text = vnode.text;
  thunk.elm = vnode.elm;
}

function init(thunk: VNode): void {
  const cur = thunk.data as VNodeData;
  const vnode = (cur.fn as any)(...cur.args!);
  copyToThunk(vnode, thunk);
}

function prepatch(oldVnode: VNode, thunk: VNode): void {
  let i: number;
  const old = oldVnode.data as VNodeData;
  const cur = thunk.data as VNodeData;
  const oldArgs = old.args;
  const args = cur.args;
  //  如果 fn 不同或 args 长度不同，说明发生了变化，调用 fn 生成新的 vnode 并返回
  if (old.fn !== cur.fn || (oldArgs as any).length !== (args as any).length) {
    copyToThunk((cur.fn as any)(...args!), thunk);
    return;
  }
  // 如果每个参数发生变化，逻辑同上
  for (i = 0; i &lt; (args as any).length; ++i) {
    if ((oldArgs as any)[i] !== (args as any)[i]) {
      copyToThunk((cur.fn as any)(...args!), thunk);
      return;
    }
  }
  copyToThunk(oldVnode, thunk);
}
// 使用 h 返回 vnode
// 添加 init prepatch hook
export const thunk = function thunk(
  sel: string,
  key?: any,
  fn?: any,
  args?: any
): VNode {
  if (args === undefined) {
    args = fn;
    fn = key;
    key = undefined;
  }
  return h(sel, {
    key: key,
    hook: { init, prepatch },
    fn: fn,
    args: args,
  });
} as ThunkFn;

</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[Snabbdom example]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/77</link>
            <guid>https://github.com/xiaotiandada/blog/issues/77</guid>
            <pubDate>Tue, 08 Jun 2021 17:34:21 GMT</pubDate>
            <description><![CDATA[<p><a href="https://github.com/snabbdom/snabbdom">https://github.com/snabbdom/snabbdom</a></p>
<p><a href="https://github.com/snabbdom/snabbdom/tree/master/examples">https://github.com/snabbdom/snabbdom/tree/master/examples</a></p>
<h3>Count</h3>
<p>通过 View 生成 dom，然后调用 render 渲染</p>
<pre><code class="language-javascript">import {
  init,
  classModule,
  propsModule,
  styleModule,
  eventListenersModule,
  h,
} from &quot;snabbdom&quot;;

const patch = init([
  // Init patch function with chosen modules
  classModule, // makes it easy to toggle classes
  propsModule, // for setting properties on DOM elements
  styleModule, // handles styling on elements with support for animations
  eventListenersModule, // attaches event listeners
]);

let vnode;
let count = 0

const increase = () =&gt; {
  count++
  console.log('count increase', count)
  render();
}
const decrease = () =&gt;{
  count--
  console.log('count decrease', count)
  render();
}

const view = () =&gt; {
  return h(&quot;div#container.two.classes&quot;, [
    h(&quot;span&quot;, { style: { fontWeight: &quot;bold&quot; } }, &quot;Number&quot;),
    h('span', ` Count: ${count} `),
    h('button', { on: { click: increase } }, &quot;Increase&quot;),
    h('button', { on: { click: decrease }}, &quot;Decrease&quot;)
  ]);
}

function render() {
  vnode = patch(vnode, view());
}

window.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
  let container = document.getElementById(&quot;container&quot;);
  vnode = patch(container, view());
  render();
});
</code></pre>
<h3>Svg</h3>
<pre><code class="language-javascript">import { init, attributesModule, h } from &quot;snabbdom&quot;;

const patch = init([attributesModule]);

window.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
  const container = document.getElementById(&quot;container2&quot;);
  const vnode = h(&quot;div&quot;, [
    h(&quot;svg&quot;, { attrs: { width: 100, height: 100 } }, [
      h(&quot;circle&quot;, {
        attrs: {
          cx: 50,
          cy: 50,
          r: 40,
          stroke: &quot;green&quot;,
          &quot;stroke-width&quot;: 4,
          fill: &quot;yellow&quot;,
        },
      }),
    ]),
  ]);
  patch(container, vnode);
});
</code></pre>
<h3>Carousel svg</h3>
<pre><code class="language-javascript">import {
  init,
  attributesModule,
  styleModule,
  eventListenersModule,
  h,
} from &quot;snabbdom&quot;;

const patch = init([attributesModule, styleModule, eventListenersModule]);

let vnode;

let data = {
  degRotation: 0,
};

function gRotation() {
  // console.log(&quot;gRotation: %s&quot;, data.degRotation);
  return &quot;rotate(&quot; + data.degRotation + &quot;deg)&quot;;
}

function triangleClick(id) {
  console.log(&quot;triangleClick: %s&quot;, id);
  render();
}

function handleRotate(degs) {
  data.degRotation += degs;
  console.log(&quot;handleRotate: %s, %s&quot;, degs, data.degRotation);
  render();
}

function handleReset(degs) {
  data.degRotation = degs;
  console.log(&quot;handleReset: %s&quot;, degs);
  render();
}

function render() {
  vnode = patch(vnode, view(data));
}

const hTriangle = (id, degRotation) =&gt;
  h(&quot;polygon#&quot; + id, {
    attrs: {
      points: &quot;-50,-88 0,-175 50,-88&quot;,
      transform: &quot;rotate(&quot; + degRotation + &quot;)&quot;,
      &quot;stroke-width&quot;: 3,
    },
    on: {
      click: () =&gt; {
        triangleClick(id);
      },
    },
  });

const view = () =&gt;
  h(&quot;div.view&quot;, [
    h(&quot;h1&quot;, &quot;Snabbdom SVG Carousel&quot;),
    h(
      &quot;svg&quot;,
      { attrs: { width: 380, height: 380, viewBox: [-190, -190, 380, 380] } },
      [
        h(
          &quot;g#carousel&quot;,
          {
            style: { &quot;-webkit-transform&quot;: gRotation(), transform: gRotation(), transition: 'all .3s' },
          },
          [
            hTriangle(&quot;yellow&quot;, 0),
            hTriangle(&quot;green&quot;, 60),
            hTriangle(&quot;magenta&quot;, 120),
            hTriangle(&quot;red&quot;, 180),
            hTriangle(&quot;cyan&quot;, 240),
            hTriangle(&quot;blue&quot;, 300),
          ]
        ),
      ]
    ),
    h(
      &quot;button&quot;,
      {
        on: {
          click: () =&gt; {
            handleRotate(60);
          },
        },
      },
      &quot;Rotate Clockwise&quot;
    ),
    h(
      &quot;button&quot;,
      {
        on: {
          click: () =&gt; {
            handleRotate(-60);
          },
        },
      },
      &quot;Rotate Anticlockwise&quot;
    ),
    h(
      &quot;button&quot;,
      {
        on: {
          click: () =&gt; {
            handleReset(0);
          },
        },
      },
      &quot;Reset&quot;
    ),
  ]);

window.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
  const container = document.getElementById(&quot;container1&quot;);
  vnode = patch(container, view(data));
  render();
});
</code></pre>
<h3>Carousel animation</h3>
<pre><code class="language-javascript">import {
  init,
  classModule,
  propsModule,
  styleModule,
  eventListenersModule,
  h,
} from &quot;snabbdom&quot;;

const patch = init([
  classModule,
  propsModule,
  styleModule,
  eventListenersModule,
]);

let vnode;

let nextKey = 11;
const margin = 8;
let sortBy = &quot;rank&quot;;
let totalHeight = 0;
const originalData = [
  {
    rank: 1,
    title: &quot;The Shawshank Redemption&quot;,
    desc:
      &quot;Two imprisoned men bond over a number of years, finding solace and eventual redemption through acts of common decency.&quot;,
    elmHeight: 0,
  },
  {
    rank: 2,
    title: &quot;The Godfather&quot;,
    desc:
      &quot;The aging patriarch of an organized crime dynasty transfers control of his clandestine empire to his reluctant son.&quot;,
    elmHeight: 0,
  },
  {
    rank: 3,
    title: &quot;The Godfather: Part II&quot;,
    desc:
      &quot;The early life and career of Vito Corleone in 1920s New York is portrayed while his son, Michael, expands and tightens his grip on his crime syndicate stretching from Lake Tahoe, Nevada to pre-revolution 1958 Cuba.&quot;,
    elmHeight: 0,
  },
  {
    rank: 4,
    title: &quot;The Dark Knight&quot;,
    desc:
      &quot;When the menace known as the Joker wreaks havoc and chaos on the people of Gotham, the caped crusader must come to terms with one of the greatest psychological tests of his ability to fight injustice.&quot;,
    elmHeight: 0,
  },
  {
    rank: 5,
    title: &quot;Pulp Fiction&quot;,
    desc:
      &quot;The lives of two mob hit men, a boxer, a gangster's wife, and a pair of diner bandits intertwine in four tales of violence and redemption.&quot;,
    elmHeight: 0,
  },
  {
    rank: 6,
    title: &quot;Schindler's List&quot;,
    desc:
      &quot;In Poland during World War II, Oskar Schindler gradually becomes concerned for his Jewish workforce after witnessing their persecution by the Nazis.&quot;,
    elmHeight: 0,
  },
  {
    rank: 7,
    title: &quot;12 Angry Men&quot;,
    desc:
      &quot;A dissenting juror in a murder trial slowly manages to convince the others that the case is not as obviously clear as it seemed in court.&quot;,
    elmHeight: 0,
  },
  {
    rank: 8,
    title: &quot;The Good, the Bad and the Ugly&quot;,
    desc:
      &quot;A bounty hunting scam joins two men in an uneasy alliance against a third in a race to find a fortune in gold buried in a remote cemetery.&quot;,
    elmHeight: 0,
  },
  {
    rank: 9,
    title: &quot;The Lord of the Rings: The Return of the King&quot;,
    desc:
      &quot;Gandalf and Aragorn lead the World of Men against Sauron's army to draw his gaze from Frodo and Sam as they approach Mount Doom with the One Ring.&quot;,
    elmHeight: 0,
  },
  {
    rank: 10,
    title: &quot;Fight Club&quot;,
    desc:
      &quot;An insomniac office worker looking for a way to change his life crosses paths with a devil-may-care soap maker and they form an underground fight club that evolves into something much, much more...&quot;,
    elmHeight: 0,
  },
];
let data = [
  originalData[0],
  originalData[1],
  originalData[2],
  originalData[3],
  originalData[4],
  originalData[5],
  originalData[6],
  originalData[7],
  originalData[8],
  originalData[9],
];

function changeSort(prop) {
  sortBy = prop;
  data.sort((a, b) =&gt; {
    if (a[prop] &gt; b[prop]) {
      return 1;
    }
    if (a[prop] &lt; b[prop]) {
      return -1;
    }
    return 0;
  });
  render();
}

function add() {
  const n = originalData[Math.floor(Math.random() * 10)];
  data = [
    { rank: nextKey++, title: n.title, desc: n.desc, elmHeight: 0 },
  ].concat(data);
  render();
  render();
}

function remove(movie) {
  data = data.filter((m) =&gt; {
    return m !== movie;
  });
  render();
}

function movieView(movie) {
  return h(
    &quot;div.row&quot;,
    {
      key: movie.rank,
      style: {
        opacity: &quot;0&quot;,
        transform: &quot;translate(-200px)&quot;,
        delayed: { transform: `translateY(${movie.offset}px)`, opacity: &quot;1&quot; },
        remove: {
          opacity: &quot;0&quot;,
          transform: `translateY(${movie.offset}px) translateX(200px)`,
        },
      },
      hook: {
        insert: (vnode) =&gt; {
          movie.elmHeight = vnode.elm.offsetHeight;
        },
      },
    },
    [
      h(&quot;div&quot;, { style: { fontWeight: &quot;bold&quot; } }, movie.rank),
      h(&quot;div&quot;, movie.title),
      h(&quot;div&quot;, movie.desc),
      h(
        &quot;div.btn.rm-btn&quot;,
        {
          on: {
            click: () =&gt; {
              remove(movie);
            },
          },
        },
        &quot;x&quot;
      ),
    ]
  );
}

function render() {
  data = data.reduce((acc, m) =&gt; {
    console.log('acc', acc)
    console.log('m', m)
    const last = acc[acc.length - 1];
    m.offset = last ? last.offset + last.elmHeight + margin : margin;
    return acc.concat(m);
  }, []);
  totalHeight =
    data.length === 0
      ? 0
      : data[data.length - 1].offset + data[data.length - 1].elmHeight;
  vnode = patch(vnode, view(data));
}

function view(data) {
  return h(&quot;div&quot;, [
    h(&quot;h1&quot;, &quot;Top 10 movies&quot;),
    h(&quot;div&quot;, [
      h(&quot;a.btn.add&quot;, { on: { click: add } }, &quot;Add&quot;),
      &quot;Sort by: &quot;,
      h(&quot;span.btn-group&quot;, [
        h(
          &quot;a.btn.rank&quot;,
          {
            class: { active: sortBy === &quot;rank&quot; },
            on: {
              click: () =&gt; {
                changeSort(&quot;rank&quot;);
              },
            },
          },
          &quot;Rank&quot;
        ),
        h(
          &quot;a.btn.title&quot;,
          {
            class: { active: sortBy === &quot;title&quot; },
            on: {
              click: () =&gt; {
                changeSort(&quot;title&quot;);
              },
            },
          },
          &quot;Title&quot;
        ),
        h(
          &quot;a.btn.desc&quot;,
          {
            class: { active: sortBy === &quot;desc&quot; },
            on: {
              click: () =&gt; {
                changeSort(&quot;desc&quot;);
              },
            },
          },
          &quot;Description&quot;
        ),
      ]),
    ]),
    h(
      &quot;div.list&quot;,
      { style: { height: totalHeight + &quot;px&quot; } },
      data.map(movieView)
    ),
  ]);
}

window.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; {
  const container = document.getElementById(&quot;container3&quot;);
  vnode = patch(container, view(data));
  render();
});
</code></pre>
<h3>Hero</h3>
<p>...</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[HackMD 打字动画]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/76</link>
            <guid>https://github.com/xiaotiandada/blog/issues/76</guid>
            <pubDate>Wed, 02 Jun 2021 15:37:48 GMT</pubDate>
            <description><![CDATA[<p><a href="https://codepen.io/xiaotiandada/pen/KKWQXqN">https://codepen.io/xiaotiandada/pen/KKWQXqN</a> codepen</p>
<pre><code class="language-html">
&lt;p class=&quot;lead ma-0&quot; style=&quot;max-width: 680px; margin: auto; margin-bottom: 30px;&quot;&gt;
用即時協作的 Markdown 編輯器書寫
&lt;span class=&quot;typewriter-container inline-flex justify-center en&quot;&gt;
&lt;span class=&quot;typewriter-text text-1&quot;&gt;專案&lt;/span&gt;
&lt;span class=&quot;typewriter-text text-2&quot;&gt;團隊&lt;/span&gt;
&lt;span class=&quot;typewriter-text text-3&quot;&gt;技術&lt;/span&gt;
&lt;span class=&quot;typewriter-text text-4&quot;&gt;個人&lt;/span&gt;
&lt;/span&gt;
文件，讓你快速協作、輕鬆紀錄想法、隨時共享知識。
&lt;/p&gt;
</code></pre>
<pre><code class="language-css">@keyframes typing1 {
 0% { width: 0%; }
 5% { width: 100%; }
 24% { width: 100%; }
 25%, 100% { width: 0%; }
}
@keyframes typing2 {
 0% { width: 0%; }
 25% { width: 0%; }
 30% { width: 100%; }
 49% { width: 100%; }
 50%, 100% { width: 0%; }
}
@keyframes typing3 {
 0% { width: 0%; }
 50% { width: 0%; }
 55% { width: 100%; }
 74% { width: 100%; }
 75%, 100% { width: 0%; }
}
@keyframes typing4 {
 0% { width: 0%; }
 75% { width: 0%; }
 80% { width: 100%; }
 99% { width: 100%; }
 100% { width: 0%; }
}
@keyframes blink {
 from, to { opacity: 0; }
 50% { opacity: 1; }
}
.typewriter-container {
    border: solid #7a7a7a;
    border-width: 0;
    border-bottom-width: 1px;
    height: 1.8em;
    margin-bottom: 3px;
    position: relative;
    width: 5.4em;
    display: inline-flex;
    justify-content: center;
    text-align: center;
}
.typewriter-container .typewriter-text {
    display: inline-block;
    position: relative;
    box-sizing: border-box;
    overflow: hidden;
    letter-spacing: 2px;
    max-width: 2.7em;
    line-height: 30px;
}
.typewriter-container.en .typewriter-text { letter-spacing: 0; }
.typewriter-container.en .typewriter-text.text-1 { max-width: 3.5em; animation: typing1 14s steps( 7 ) infinite; }
.typewriter-container.en .typewriter-text.text-2 { max-width: 2.5em; animation: typing2 14s steps( 4 ) infinite; }
.typewriter-container.en .typewriter-text.text-3 { max-width: 4.2em; animation: typing3 14s steps( 9 ) infinite; }
.typewriter-container.en .typewriter-text.text-4 { max-width: 4.2em; animation: typing4 14s steps( 8 ) infinite; }
.typewriter-container .typewriter-text::after {
  content: &quot;|&quot;;
  color: #7a7a7a;
  position: absolute;
  right: -2px;
  top: -1px;
  animation: blink .95s infinite;
}
</code></pre>
<p>TODO：需要看一下 steps， 还没弄懂原理</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Github Actions]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/75</link>
            <guid>https://github.com/xiaotiandada/blog/issues/75</guid>
            <pubDate>Mon, 31 May 2021 16:20:43 GMT</pubDate>
            <description><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a></p>
<p><a href="https://docs.github.com/cn/actions/quickstart">https://docs.github.com/cn/actions/quickstart</a></p>
<p><a href="https://github.com/actions/starter-workflows/blob/7c29ac248118d9e004eb6776e22cadbca1dd524a/ci/node.js.yml">https://github.com/actions/starter-workflows/blob/7c29ac248118d9e004eb6776e22cadbca1dd524a/ci/node.js.yml</a> 配置文件用了这个模版</p>
<p><a href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows">https://docs.github.com/en/actions/reference/events-that-trigger-workflows</a> 定时任务相关 定时在某个小时成功了，但是每分钟执行一次还没测试出来...</p>
<p>```* * * * *` runs every minute of every day.``</p>
<p><a href="https://docs.github.com/en/actions/reference/encrypted-secrets">https://docs.github.com/en/actions/reference/encrypted-secrets</a> 设置 secrets  <code>${{ secrets.TOKEN }}</code></p>
<p>提交代码就可以自动执行</p>
<pre><code class="language-yaml">
# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the action will run. 
on:
  schedule:
    - cron: '0 4 * * *'

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called &quot;build&quot;
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [14.x]
        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/
          
    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm install
      - run: TOKEN=${{ secrets.TOKEN }} node ./dist/index.js
   
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[140 行写一个自动生成 Issues 为 Markdown 文垱]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/74</link>
            <guid>https://github.com/xiaotiandada/blog/issues/74</guid>
            <pubDate>Tue, 07 Jun 2022 04:32:11 GMT</pubDate>
            <description><![CDATA[<p><a href="https://github.com/xiaotiandada/issues">Repo Issues</a></p>
<ul>
<li><a href="https://dev.to/github/the-githubtoken-in-github-actions-how-it-works-change-permissions-customizations-3cgp">the-githubtoken-in-github-actions-how-it-works-change-permissions-customizations-3cgp</a> 使用<code>secrets.GITHUB_TOKEN</code></li>
</ul>
<ol>
<li>
<p>生成个人 <a href="https://github.com/settings/tokens">Token</a></p>
<pre><code class="language-javascript">const octokit = new Octokit({
  auth: process.env.TOKEN
});

// TOKEN=xxx node ./app/index.js
</code></pre>
</li>
<li>
<p>获取 Repo 数据 主要获取 Name、Issues count 信息，然后获取 Issues 信息</p>
<pre><code class="language-javascript">// 分页处理
let count = (respo as any).open_issues_count
let per_page = 100 // default 30 max 100
let len = Math.floor(count / per_page) + 1
</code></pre>
</li>
<li>
<p>生成 Markdown</p>
</li>
<li>
<p>Push 内容为 <a href="http://Readme.md">Readme.md</a></p>
<pre><code class="language-javascript">// push 内容需要 base64
const contentsBase64 = new Buffer(contents).toString('base64');
</code></pre>
</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/24250627/120079607-40149080-c0e7-11eb-8e6a-2db97cf4dae4.png" alt="image"></p>
<ol start="5">
<li>使用 GitHub Action 定时更新</li>
</ol>
<pre><code class="language-typescript">import { Octokit } from '@octokit/rest';
import { RestEndpointMethodTypes } from &quot;@octokit/plugin-rest-endpoint-methods/dist-types/generated/parameters-and-response-types&quot;;

type listForRepoType = RestEndpointMethodTypes[&quot;issues&quot;][&quot;listForRepo&quot;][&quot;parameters&quot;]

// https://docs.github.com/en/rest/reference/issues#list-repository-issues
// https://octokit.github.io/rest.js/v18

const octokit = new Octokit({
  auth: process.env.TOKEN
});
const owner = 'xiaotiandada'
const repo = 'blog'
const path = 'README.md'

/**
 * push markdown
 * @param contents 文垱内容
 * @returns
 */
const push = async (contents: string) =&gt; {
  try {
    const { status, data } = await octokit.repos.getContent({
      owner,
      repo,
      path,
    });
    // console.log(data)

    if (status !== 200) {
      console.log('fail', status)
      return
    }

    const contentsBase64 = new Buffer(contents).toString('base64');
    const { status: pushStatus, data: pushData } = await octokit.repos.createOrUpdateFileContents({
      owner,
      repo,
      path,
      message: `Update ${Date.now()}`,
      content: contentsBase64,
      sha: data.sha,
    });
    if (pushStatus === 200) {
    // console.log(pushData)
      console.log(`push success, url: ${pushData.content.html_url}`)
    } else {
      console.log('fail', pushStatus)
    }
  } catch (e) {
    console.log('push', e.toString())
  }
}
/**
 * process markdown
 * @param data issues list
 */
const processMd = ({data, name, description}: { data: Array&lt;listForRepoType&gt;, name: string, description: string }) =&gt; {
  let md =
`&lt;div align=&quot;center&quot;&gt;
&lt;h1&gt;${name}&lt;/h1&gt;
&lt;p&gt;${description}&lt;/p&gt;
&lt;/div&gt;\n\n`

  data.map((i) =&gt; {
    let label = ''
    let labels: any = i.labels
    for (let i = 0; i &lt; labels.length; i++) {
      const ele: { name: string } = labels[i];
      label += ` ${ele.name} `
    }
    // [xxx](xxx) [ xx ]
    md += `[#${i.number} ${i.title}](${i.html_url}) ${ label ? '[' + label + ']' : '' }\n\n`
  })

  // console.log('md', md)
  push(md)
}
/**
 * get repo
 */
const getRepo = async () =&gt; {
  try {
    const { status, data } = await octokit.rest.repos.get({
      owner,
      repo,
    });
    if (status === 200) {
      // console.log('data', data)
      return data
    } else {
      console.log('fail', status)
      return false
    }
  } catch (e) {
    console.log('getRepo', e.toString())
    return false
  }
}

/**
 * fetch issues
 */
const fetch = async () =&gt; {
  try {

    const respo = await getRepo()
    let count = (respo as any).open_issues_count
    let per_page = 100 // default 30 max 100
    let len = Math.floor(count / per_page) + 1

    let list: listForRepoType[] = []
    for (let i = 1; i &lt;= len; i++) {
      const { status, data } = await octokit.rest.issues.listForRepo({
        owner,
        repo,
        page: i,
        per_page: per_page
      });
      if (status === 200) {
        // console.log('data', data)
        list.push(...(data as any))
      } else {
        console.log('fail', status)
      }
    }

    processMd({
      data: list,
      name: (respo as any).name,
      description: (respo as any).description,
    })
  } catch (e) {
    console.log('fetch', e.toString())
  }
}

fetch()
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[前端下载 Markdown File]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/73</link>
            <guid>https://github.com/xiaotiandada/blog/issues/73</guid>
            <pubDate>Wed, 26 May 2021 17:04:28 GMT</pubDate>
            <description><![CDATA[<p><a href="https://dev.to/nombrekeff/download-file-from-blob-21ho">Download Any File from Blob</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL">https://developer.mozilla.org/zh-CN/docs/Web/API/URL</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent">https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent</a></p>
<blockquote>
<p><code>Blob</code> 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream"><code>ReadableStream</code></a> 来用于数据操作。</p>
<p>Blob 表示的不一定是JavaScript原生格式的数据。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File"><code>File</code></a> 接口基于<code>Blob</code>，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>
<p>要从其他非blob对象和数据构造一个 <code>Blob</code>，请使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob"><code>Blob()</code></a> 构造函数。要创建一个 blob 数据的子集 blob，请使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice"><code>slice()</code></a> 方法。要获取用户文件系统上的文件对应的 <code>Blob</code> 对象，请参阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File"><code>File</code></a> 文档。</p>
<p>接受 <code>Blob</code> 对象的API也被列在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File"><code>File</code></a> 文档中。</p>
<p><strong>注意：</strong><code>slice()</code> 方法原本接受 <code>length</code> 作为第二个参数，以表示复制到新 <code>Blob</code> 对象的字节数。如果设置的参数使 <code>start + length</code> 超出了源 <code>Blob</code> 对象的大小，则返回从开始到结尾的所有数据。</p>
<p><strong>注意：</strong><code>slice()</code> 方法在某些浏览器和版本上带有浏览器引擎前缀：比如 Firefox 12 及更早版本的<code>blob.mozSlice()</code> 和 Safari 中的<code>blob.webkitSlice()</code>。 没有浏览器引擎前缀的老版本 <code>slice()</code> 方法有不同的语义，并且已过时。Firefox 30 取消了对 <code>blob.mozSlice()</code> 的支持。</p>
</blockquote>
<pre><code class="language-javascript">var debug = {hello: &quot;world&quot;};
var blob = new Blob([JSON.stringify(debug, null, 2)], {type : 'application/json'});
</code></pre>
<blockquote>
<p>**<code>URL</code>**接口用于解析，构造，规范化和编码 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/URL">URLs</a>。 它通过提供允许您轻松阅读和修改URL组件的属性来工作。 通常，通过在调用URL的构造函数时将URL指定为字符串或提供相对URL和基本URL来创建新的URL对象。 然后，您可以轻松读取URL的已解析组成部分或对URL进行更改。</p>
<p>如果浏览器尚不支持<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/URL"><code>URL()</code></a>构造函数，则可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window"><code>Window</code></a>中的<a href="https://developer.mozilla.org/zh-CN/docs/conflicting/Web/API/URL"><code>Window.URL</code></a>属性。 确保检查您的任何目标浏览器是否要求对此添加前缀。</p>
</blockquote>
<blockquote>
<p><strong><code>URL.createObjectURL()</code></strong> 静态方法会创建一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString"><code>DOMString</code></a>，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document"><code>document</code></a> 绑定。这个新的URL 对象表示指定的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File"><code>File</code></a> 对象或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob"><code>Blob</code></a> 对象。</p>
</blockquote>
<blockquote>
<p><strong><code>URL.revokeObjectURL()</code></strong> 静态方法用来释放一个之前已经存在的、通过调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL"><code>URL.createObjectURL()</code></a> 创建的 URL 对象。当你结束使用某个 URL 对象之后，应该通过调用这个方法来让浏览器知道不用在内存中继续保留对这个文件的引用了。</p>
<p>你可以在 <code>sourceopen</code> 被处理之后的任何时候调用 <code>revokeObjectURL()</code>。这是因为 <code>createObjectURL()</code> 仅仅意味着将一个媒体元素的 <code>src</code> 属性关联到一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaSource"><code>MediaSource</code></a> 对象上去。调用<code>revokeObjectURL()</code> 使这个潜在的对象回到原来的地方，允许平台在合适的时机进行垃圾收集。</p>
</blockquote>
<pre><code class="language-javascript">let objectURL = URL.createObjectURL(object);

window.URL.revokeObjectURL(objectURL);
</code></pre>
<blockquote>
<p><strong>EventTarget.dispatchEvent</strong></p>
<p>向一个指定的事件目标派发一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event">事件</a>, 并以合适的顺序<strong>同步调用</strong>目标元素相关的事件处理函数。标准事件处理规则(包括事件捕获和可选的冒泡过程)同样适用于通过手动的使用<code>dispatchEvent()</code>方法派发的事件。</p>
</blockquote>
<blockquote>
<p>MouseEvent</p>
<p>The <code>**MouseEvent**</code> interface represents events that occur due to the user interacting with a pointing device (such as a mouse). Common events using this interface include <code>click</code>, <code>dblclick</code>, <code>mouseup</code>, <code>mousedown</code>.</p>
<p><code>MouseEvent</code> derives from <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent"><code>UIEvent</code></a>, which in turn derives from <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event"><code>Event</code></a>. Though the <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/initMouseEvent"><code>MouseEvent.initMouseEvent()</code></a> method is kept for backward compatibility, creating of a <code>MouseEvent</code> object should be done using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent"><code>MouseEvent()</code></a> constructor.</p>
<p>Several more specific events are based on <code>MouseEvent</code>, including <a href="https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent"><code>WheelEvent</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/DragEvent"><code>DragEvent</code></a>.</p>
<iframe class="inheritance-diagram-frame" id="frame_inheritance_diagram" width="600" height="70" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/API/MouseEvent/_sample_.inheritance_diagram.html" loading="lazy" style="box-sizing: border-box; max-width: 100%; border: 0px;"></iframe>
</blockquote>
<pre><code class="language-javascript">let evt = new MouseEvent(&quot;click&quot;, {
  bubbles: true,
  cancelable: true,
  view: window
});

cb.dispatchEvent(evt);
</code></pre>
<p>将数据转换为 blob，然后创建 url 链接，赋值给 a tag 利用 a tag 实现下载文件。</p>
<pre><code class="language-javascript">
function downloadBlob(blob, name = 'file.txt') {
  // Convert your blob into a Blob URL (a special url that points to an object in the browser's memory)
  const blobUrl = URL.createObjectURL(blob);

  // Create a link element
  const link = document.createElement(&quot;a&quot;);

  // Set link's href to point to the Blob URL
  link.href = blobUrl;
  link.download = name;

  // Append link to the body
  document.body.appendChild(link);

  // Dispatch click event on the link
  // This is necessary as link.click() does not work on the latest firefox
  link.dispatchEvent(
    new MouseEvent('click', { 
      bubbles: true, 
      cancelable: true, 
      view: window 
    })
  );

  // Remove link from body
  document.body.removeChild(link);
  window.URL.revokeObjectURL(blobUrl)
}

// Usage
let mdBlob = new Blob(['markdown'])
downloadBlob(mdBlob, 'markdown.md');

</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[剧本杀]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/72</link>
            <guid>https://github.com/xiaotiandada/blog/issues/72</guid>
            <pubDate>Wed, 02 Jun 2021 18:37:54 GMT</pubDate>
            <description><![CDATA[<h3>《笼中鸟》 凌舒 恐怖本</h3>
<p><a href="https://zhuanlan.zhihu.com/p/149006742">【剧本测评】独家本《笼中鸟》| 一场人性的考验，谁能从笼中出去呢</a></p>
<p><img src="https://user-images.githubusercontent.com/24250627/115835480-e61a0e80-a448-11eb-88de-0107f71f4f3a.png" alt="image"></p>
<p>我的随机角色：</p>
<p>凌舒 男
温柔暖男，报社记者，皮肤细腻，相貌异常英俊。</p>
<blockquote>
<p>推理还原方面</p>
<p>其次，《笼中鸟》的推理还原环节可谓是令玩家大呼过瘾的方面，也是这个本另外一个值得推荐的点。</p>
<p>2起突发分尸案和1起追踪多年的连环杀人案是《笼中鸟》最后投票时，需要玩家判断选择真凶的。</p>
<p>分尸案主要以本格形式呈现，作者为此处设计的嫌疑人动机、诡计以及杀人手法，都禁得住玩家推敲琢磨，玩家在这里要做的便是仔细斟酌剧本给出的线索以及每名角色的犯案动机，并充分将它们联系在一起分析推导。</p>
<p>连环杀人案是剧本的另外一个侧重点，是需要靠玩家大致还原出整个故事，才能顺利推出真凶的。当然，这个案件也有它的推理捷径和细节，防止剧透，在这里我不做阐述【为了保证玩家体验感和剧本完整度，我建议玩家还是尽量去还原故事】</p>
<p>《笼中鸟》这个剧本给我最直观的感受就是，来到这里的每名角色都心怀鬼胎，他们没有真正的善，也没有完全的恶，或许是童年、或许是当下，他们的每一次选择，都使他们在同一条轨道上渐行渐远。剧本尾声当他们要做出最后的抉择时，我想这也将是对他们每个人心灵最后的洗礼，谁将成为这笼中鸟，谁又能飞的出这人性的牢笼。</p>
</blockquote>
<hr>
<p align="center">还没有玩过的同学就不要往下看了 避免下次玩的时候体验不好(尽量不剧透)...</p>
<hr>
<p>第一章的梦：</p>
<p>我遇到了我的温柔对象(同)，我们看了三步电影。开始觉得莫名其妙的但是认真的往后读剧本就会觉得能说通。</p>
<ol>
<li>第一部是搞笑片的电影 但是我们看的过程中会出现很多恐怖的画面。</li>
<li>第二部是演绎的一对夫妻求子然后幸福美满的结局</li>
<li>第三部是一对同性恋想要生孩子。</li>
</ol>
<p>有一天点外卖点了一份成人套餐但是送过来的时候是<strong>一份儿童套餐</strong>。我很生气但是真司说我点的就是儿童套餐！</p>
<p>中间自己的同事会问我我家的小孩子怎么样了，但是我家里根本没有小孩子。只有我的对象真司 是一个成年人。</p>
<blockquote>
<p>这里就能连起来了 能想明白了。（线索在第三章）</p>
</blockquote>
<p>有一天报道学校的校园霸凌事件，但是公司不愿意说出更多的内幕，自己很生气。开始不知道为什么很生气，但是通过后面的剧情联想起来自己从小也是被霸凌的对象！！！</p>
<blockquote>
<p>需要后面和前面的剧情连起来才能想明白（线索在第三章）</p>
</blockquote>
<p>看第三部的时候很恐怖然后被婴儿和真司吓到跑，拼命拼命拼命的跑！！！</p>
<blockquote>
<p>所以为什么看搞笑片里面有恐怖的内容，可能就是和真司有关系</p>
</blockquote>
<p>第三章：</p>
<p>这部分是很烧脑同时也是最有趣的部分，需要靠大家去推理。（这里剧透了就过分了..所以留空了 只介绍第一章的信息）</p>
<p>这里可以解释为什么梦里我的对象是成人真司而我的同事见到的是小孩子。因为真司在小时候已经去世了(为什么剧本有写)。因为自己小时候很喜欢真司所以梦里也是和真司在一起。</p>
<p>这样就可以解释为什么是儿童套餐，因为真司就是儿童。(瞎猜的...)</p>
<p>结局：</p>
<p>结局的梦 我还是梦到和真司在一起。父亲也接受了女朋友的他。</p>
<hr>
<p>因为第一次玩线下剧本杀，队友都是随缘上车的。所以我还是很认真的在阅读剧本，过程中避免玩手机和做一些有的没得尽量融入到角色中，然后跟着他们的剧情推理解释他们的疑问和做自己的主线任务/支线任务。</p>
<p>因为不太会玩，游戏中还是给队友和DM造成了不少的迷惑行为。好在队友和DM挺包容的2333 没有怪我</p>
<p>结局最后大家都投了我😷。最后需要牺牲一个人打破结界 三个人死在了鬼手里，还有两个人是盟友直接祭献了我然后通关。</p>
<p>剧情很烧脑，导致有部分剧情结束的时候还是懵逼的....</p>
<p>最后复盘的时候还是能很明显的觉得自己没有把角色演好 不然可能更好玩 疑点更多！！！</p>
<p>结束后觉得第一章的剧情挺<strong>细思极恐</strong>的所以才写了这莫名其妙的文字内容，没有剧透的意思，你也有可能看不懂。但是等玩了之后再回来看 说不定就能一眼看明白我在瞎说些什么。</p>
<p>以上内容纯本人胡编滥造，不代表任何观点。</p>
<h3>《林家宅2》秦甜 恐怖本</h3>
<p><img src="https://user-images.githubusercontent.com/24250627/119075560-89981800-ba23-11eb-9e23-1ae3c89dcec7.png" alt="image"></p>
<p>凶手线索较少 需要扣细节才能盘出凶手是谁。</p>
<p>结局是婉儿 🔪了所有祭品，无一人逃脱。 成功复活后和李书佑在一起了。</p>
<h3>《第七号嫌疑人》 红雪 崔媛 硬核/烧脑/反转</h3>
<p><img src="https://user-images.githubusercontent.com/24250627/120533807-b67cff80-c413-11eb-8fde-dd6a1f5c7156.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/24250627/120534133-14a9e280-c414-11eb-9e40-860ee8a62212.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/24250627/120534142-17a4d300-c414-11eb-8de5-b75ae2c3c25b.png" alt="image"></p>
<p>只能说整本都是细节，只要写了的都是有用的。没有加粗的字体也是线索！！！</p>
<p>红雪本人不知道玉在红雪手上... 红雪十二岁就死了 完事后红雪跑路不见了(彩蛋)</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Promise的源码实现]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/71</link>
            <guid>https://github.com/xiaotiandada/blog/issues/71</guid>
            <pubDate>Thu, 01 Apr 2021 02:47:41 GMT</pubDate>
            <description><![CDATA[<p>参考文章</p>
<ul>
<li><a href="https://github.com/YvetteLau/Blog/issues/2">Promise的源码实现（完美符合Promise/A+规范）</a></li>
</ul>
<pre><code class="language-javascript">const log = (...args) =&gt; {
  console.log(args)
}

// 三种状态 pending fulfilled rejected
// Promise 必须处于以下三个状态之一: pending, fulfilled 或者是 rejected
const PENDING = 'pending'
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

function Promise(executor) {
  let self = this
  self.status = PENDING
  self.onFulfilled = []
  self.onRejected = []

  // 可以变成 fulfilled 或者是 rejected
  function resolve(value) {
    if (self.status === PENDING) {
      // 2.1.2 如果promise在fulfilled状态
      self.status = FULFILLED
      // 2.1.2.2 必须有一个value值
      self.value = value
      self.onFulfilled.forEach(fn =&gt; fn())
    }
  }
  // 可以变成 fulfilled 或者是 rejected
  function reject(reason) {
    if (self.status === PENDING) {
      // 2.1.3.1 不会变成其它状态
      self.status = REJECTED
      // 2.1.3.2 必须有一个promise被reject的reason
      self.reason = reason
      self.onRejected.forEach(fn =&gt; fn())
    }
  }

  try {
    // 执行executor
    executor(resolve, reject)
  } catch (e) {
    reject(e)
  }
}
// promise的then方法接收两个参数
Promise.prototype.then = function (onFulfilled, onRejected) {

  let self = this

  // 2.2.1 onFulfilled 和 onRejected 都是可选参数
  // 2.2.1.1 onFulfilled 必须是函数类型
  // 2.2.1.2 onRejected 必须是函数类型
  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value
  onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; {
    throw reason
  }

  // 2.2.4 onFulfilled 和 onRejected 应该是微任务
  // 2.2.5 onFulfilled 和 onRejected 必须作为函数被调用

  // 2.2.7.1 onFulfilled 或 onRejected 执行的结果为x,调用 resolvePromise
  // 2.2.7.2 如果 onFulfilled 或者 onRejected 执行时抛出异常e,promise2需要被reject
  let promise2 = new Promise((resolve, reject) =&gt; {
    if (self.status === FULFILLED) {
      setTimeout(() =&gt; {
        try {
          let x = onFulfilled(self.value)
          resolvePromise(promise2, x, resolve, reject)
        } catch (e) {
          reject(e)
        }
      })
    } else if (self.status === REJECTED) {
      setTimeout(() =&gt; {
        try {
          let x = onRejected(self.reason)
          resolvePromise(promise2, x, resolve, reject)
        } catch (e) {
          reject(e)
        }
      })
    } else if (self.status === PENDING) {
      // 2.2.2.1 必须在promise变成 fulfilled 时，调用 onFulfilled，参数是promise的value
      self.onFulfilled.push(() =&gt; {
        setTimeout(() =&gt; {
          try {
            let x = onFulfilled(self.value)
            resolvePromise(promise2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        })
      })
      // 2.2.3.1 必须在promise变成 rejected 时，调用 onRejected，参数是promise的reason
      self.onRejected.push(() =&gt; {
        setTimeout(() =&gt; {
          try {
            let x = onRejected(self.reason)
            resolvePromise(promise2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        })
      })
    }
  })
  // 2.2.7 then必须返回一个promise
  return promise2
}

function resolvePromise(promise2, x, resolve, reject) {
  // 2.3.1 如果 promise2 和 x 相等，那么 reject promise with a TypeError
  if (promise2 === x) {
    reject(new TypeError('Chaining cycle'));
  }
  // 2.3.3.3.3 如果 resolvePromise 和 rejectPromise 都调用了，那么第一个调用优先，后面的调用忽略。
  let used
  // 2.3.3 如果 x 是一个 object 或者 是一个 function
  if (x &amp;&amp; typeof x === 'object' || typeof x === 'function') {
    try {
      // 2.3.3.2 如果 x.then 这步出错，那么 reject promise with e as the reason..
      let then = x.then
      // 2.3.3.3 如果 then 是一个函数，then.call(x, resolvePromiseFn, rejectPromise)
      if (typeof then === 'function') { // 2.3.2 如果 x 是一个 promsie
        // 2.3.2.2 如果 x 被 fulfilled, fulfill promise with the same value.
        // 2.3.2.3 如果 x 被 rejected, reject promise with the same reason.
        then.call(x, y =&gt; {
          if (used) return
          used = true
          // 2.3.3.3.1 resolvePromiseFn 的 入参是 y, 执行 resolvePromise(promise2, y, resolve, reject);
          resolvePromise(promise2, y, resolve, reject)
        }, r =&gt; {
          if (used) return
          used = true
          // 2.3.3.3.2 rejectPromise 的 入参是 r, reject promise with r.
          reject(r)
        })
      } else {
        if (used) return
        used = true
        resolve(x)
      }
    } catch (e) {
      if (used) return
      used = true
      // 2.3.3.3.4 如果调用then抛出异常e
      reject(e)
    }
  } else {
    // 2.3.4 如果 x 不是一个 object 或者 function，fulfill promise with x.
    resolve(x)
  }
}


// {
//   const p = new Promise((resolve, reject) =&gt; {
//     setTimeout(() =&gt; {
//       log(`setTimeout log ${Date.now()}`)
//       resolve(12)
//     }, 2000)
//   })
//   p.then(res =&gt; {
//     log('res', res)
//     return 2
//   }).then(res =&gt; {
//     log('res3', res)
//     return {
//       value: 123
//     }
//   }).then(res =&gt; {
//     log('res4', res)
//     return () =&gt; {
//       log('fun')
//     }
//   }).then(res =&gt; {
//     log('res5', res)
//     return new Promise(() =&gt; {
//       log('promise')
//     })
//   })
// }

Promise.resolve = function(params) {
  // 如果 value 是个 thenable 对象，返回的promise会“跟随”这个thenable的对象，采用它的最终状态
  if (params instanceof Promise) {
    return params
  }
  return new Promise((resolve, reject) =&gt; {
    // 如果传入的value本身就是promise对象，那么Promise.resolve将不做任何修改、原封不动地返回这个promise对象。
    if (params &amp;&amp; params.then &amp;&amp; typeof params.then === 'function') {
      setTimeout(() =&gt; {
        params.then(resolve, reject)
      })
    // 其他情况，直接返回以该值为成功状态的promise对象。
    } else {
      resolve(params)
    }
  })
}

// {
//   let p = Promise.resolve(20);
//   p.then((data) =&gt; {
//       console.log(1, data);
//   });
//   let p2 = Promise.resolve({
//       then: function(resolve, reject) {
//           resolve(30);
//       }
//   });
//   p2.then((data)=&gt; {
//       console.log(2, data)
//   });
//   let p3 = Promise.resolve(new Promise((resolve, reject) =&gt; {
//       resolve(400)
//   }));
//   p3.then((data) =&gt; {
//       console.log(3, data)
//   });
// }

// Promise.reject方法和Promise.resolve不同，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。
Promise.prototype.reject = function(reason) {
  return new Promise((resolve, reject) =&gt; {
    reject(reason)
  })
}

// Promise.prototype.catch 用于指定出错时的回调，是特殊的then方法，catch之后，可以继续 .then
Promise.prototype.catch = function(onRejected) {
  return this.then(null, onRejected)
}

// {
//   let x = new Promise((resolve, reject) =&gt; {
//     resolve(1)
//   })
//   x.then(res =&gt; {
//     throw new Error('err')
//   }).catch(e =&gt; {
//     console.log('err', e.toString())
//   })
// }

Promise.prototype.finally = function(callback) {
  return this.then(value =&gt; {
    return Promise.resolve(callback()).then(() =&gt; value)
  }, err =&gt; {
    return new Promise.resolve(callback()).then(() =&gt; { throw err })
  })
}

// {
//   let x = new Promise((resolve, reject) =&gt; {
//     resolve(1)
//   })
//   x.then(res =&gt; {
//     console.log('111', res)
//   }).finally(() =&gt; {
//     console.log(222)
//   }).then(() =&gt; {
//     console.log('333')
//   })
// }

Promise.all = function(promisees) {
  return new Promise((resolve, reject) =&gt; {
    let index = 0
    // 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组
    let result = []
    if (promisees.length === 0) {
      resolve(result)
    } else {
      function processValue(i, data) {
        result[i] = data
        if (++index === promisees.length) {
          resolve(result)
        }
      }
      for (let i = 0; i &lt; promisees.length; i++) {
        // promises[i] 可能是普通值
        Promise.resolve(promisees[i]).then(data =&gt; {
          processValue(i, data)
        }, err =&gt; {
          // 如果参数中有一个promise失败，那么Promise.all返回的promise对象失败
          reject(err)
          return
        })
      }
    }
  })
}

// {
//   var promise1 = new Promise((resolve, reject) =&gt; {
//     resolve(3);
//   })
//   var promise2 = 42;
//   var promise3 = new Promise(function(resolve, reject) {
//     setTimeout(resolve, 100, 'foo');
//   });

//   Promise.all([promise1, promise2, promise3]).then(function(values) {
//     console.log('values', values); //[3, 42, 'foo']
//   },(err)=&gt;{
//       console.log(err)
//   });

//   var p = Promise.all([]); // will be immediately resolved
//   var p2 = Promise.all([1337, &quot;hi&quot;]); // non-promise values will be ignored, but the evaluation will be done asynchronously
//   console.log(p);
//   console.log(p2)
//   setTimeout(function(){
//       console.log('the stack is now empty');
//       console.log(p2);
//   });
// }


Promise.race = function(promises) {
  return new Promise((resolve, reject) =&gt; {
    // 如果传的参数数组是空，则返回的 promise 将永远等待。
    if (promises.length === 0) {
      return
    } else {
      for (let i = 0; i &lt; promises.length; i++) {
        Promise.resolve(promises[i]).then(data =&gt; {
          resolve(data)
          return
        }, err =&gt; {
          reject(err)
          return
        })
      }
    }
  })
}

{
  Promise.race([
    new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(100) }, 1000) }),
    undefined,
    new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(100) }, 100) })
  ]).then((data) =&gt; {
      console.log('success ', data);
  }, (err) =&gt; {
      console.log('err ',err);
  });

  Promise.race([
      new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(100) }, 1000) }),
      new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(200) }, 200) }),
      new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(100) }, 100) })
  ]).then((data) =&gt; {
      console.log(data);
  }, (err) =&gt; {
      console.log(err);
  });
}


Promise.defer = Promise.deferred = function () {
  let dfd = {};
  dfd.promise = new Promise((resolve, reject) =&gt; {
    dfd.resolve = resolve;
    dfd.reject = reject;
  });
  return dfd;
}

module.exports = Promise
</code></pre>
<pre><code class="language-bash"># 测试用例

npm install -g promises-aplus-tests

promises-aplus-tests promise.js
</code></pre>
<p>Simple</p>
<pre><code class="language-javascript">// simple
const log = (...args) =&gt; {
  console.log(args)
}

const PENDING = 'pending'
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

function Promise(executor) {
  let self = this
  self.status = PENDING
  self.onFulfilled = []
  self.onRejected = []

  function resolve(value) {
    if (self.status === PENDING) {
      self.status = FULFILLED
      self.value = value
      self.onFulfilled.forEach(fn =&gt; fn())
    }
  }

  function reject(reason) {
    if (self.status === PENDING) {
      self.status = REJECTED
      self.reason = reason
      self.onRejected.forEach(fn =&gt; fn())
    }
  }

  try {
    executor(resolve, reject)
  } catch (e) {
    reject(e)
  }
}

Promise.prototype.then = function (onFulfilled, onRejected) {
  let self = this

  let promise2 = new Promise((resolve, reject) =&gt; {
    if (self.status === PENDING) {
      self.onFulfilled.push(() =&gt; {
        setTimeout(() =&gt; {
          try {
            let x = onFulfilled(self.value)
            resolve(x)
          } catch (e) {
            reject(e)
          }
        })
      })
    }
  })
  return promise2
}

{
  const p = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      log(`setTimeout log ${Date.now()}`)
      resolve(12)
    }, 2000)
  })
  p.then(res =&gt; {
      log('res', res)
      return 2
    }).then(res =&gt; {
      log('res2', res)
      return 3
    })
    .then(res =&gt; {
      log('res3', res)
    })
}
</code></pre>
<p>参考文章写得非常好，改天理解更深入后再来更新</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Nuxt 添加 Less 报错 TypeError: this.getOptions is not a function at Object.lessLoader]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/70</link>
            <guid>https://github.com/xiaotiandada/blog/issues/70</guid>
            <pubDate>Wed, 29 Jun 2022 04:19:39 GMT</pubDate>
            <description><![CDATA[<pre><code class="language-bash">Module build failed (from ./node_modules/less-loader/dist/cjs.js):                                                               friendly-errors 15:45:54
TypeError: this.getOptions is not a function
    at Object.lessLoader (/Users/xiaotian/Code/matataki-editor/node_modules/less-loader/dist/index.js:21:24)
</code></pre>
<p>原因：可能版本过高！！？？ 🤷‍♂️</p>
<p>当前错误版本：&quot;less-loader&quot;: &quot;^8.0.0&quot;
降级后的版本：&quot;less-loader&quot;: &quot;^5.0.0&quot;</p>
<p>work</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Grafana]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/69</link>
            <guid>https://github.com/xiaotiandada/blog/issues/69</guid>
            <pubDate>Sat, 13 Mar 2021 17:52:50 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://grafana.com/docs/grafana/latest/getting-started/getting-started/">https://grafana.com/docs/grafana/latest/getting-started/getting-started/</a></li>
</ul>
<h2>Step 1: Install Grafana</h2>
<p><a href="https://grafana.com/docs/grafana/latest/installation/">https://grafana.com/docs/grafana/latest/installation/</a></p>
<pre><code class="language-bash">brew services start grafana

brew services stop grafana
</code></pre>
<h2>Step 2: Log in</h2>
<p><a href="http://localhost:3000">http://localhost:3000</a></p>
<p>username and password： admin</p>
<h2>Step 3: Create a dashboard</h2>
<p><img src="https://user-images.githubusercontent.com/24250627/111038865-0fb54280-8466-11eb-8868-1c0c7a44a4cd.png" alt="image"></p>
<h2>设置Mysql</h2>
<p><img src="https://user-images.githubusercontent.com/24250627/111038877-222f7c00-8466-11eb-9e89-fa182ff979ae.png" alt="image"></p>
<p>点击 Data Sources，选择Mysql 填写配置</p>
<p><img src="https://user-images.githubusercontent.com/24250627/111038906-48edb280-8466-11eb-874e-1c5d83a6114e.png" alt="image"></p>
<h2>创建一个 Dashboard</h2>
<p><img src="https://user-images.githubusercontent.com/24250627/111038938-691d7180-8466-11eb-97ff-257dd8893935.png" alt="image"></p>
<p>写一个最简单的Sql语句并且选择一个 <strong>Visualization</strong> 模块</p>
<p><img src="https://user-images.githubusercontent.com/24250627/111038956-818d8c00-8466-11eb-98d7-58f6b561b42f.png" alt="image"></p>
<h2>创建User</h2>
<p>选择User 输入信息创建用户</p>
<p><img src="https://user-images.githubusercontent.com/24250627/111039189-bc43f400-8467-11eb-808f-0108fbb2a178.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/24250627/111039209-cc5bd380-8467-11eb-961c-56696d426d9c.png" alt="image"></p>
<p>.... 还没写完 .....</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[前端总结]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/68</link>
            <guid>https://github.com/xiaotiandada/blog/issues/68</guid>
            <pubDate>Wed, 02 Jun 2021 18:28:40 GMT</pubDate>
            <description><![CDATA[<ol>
<li><a href="https://juejin.cn/post/6844903673009553416#heading-59">2018前端面试总结</a></li>
<li><a href="https://ld246.com/article/1544793046274">每天 30 秒系列之前端面试</a></li>
<li><a href="https://juejin.cn/post/6844903682455109640">2万5千字大厂面经 | 掘金技术征文</a></li>
</ol>
<h2>HTML</h2>
<h3>图片标签中的 alt 有什么作用？</h3>
<ol>
<li>当图片无法加载的时候， alt 的属性值会以文字的形式替代图片显示。alt 属性是用来描述图片内容的，当图片作为背景等装饰时，alt 属性应该为空。</li>
<li>装饰作用的图片 alt 属性应该为空</li>
<li>网站爬虫根据其属性值来理解图片的内容，因此 alt 属性对 SEO（搜索引擎优化） 来说非常重要</li>
<li>alt 值应以句号结尾，以提高可访问性</li>
<li>网速过慢导致图片加载需较长一段时间时，在图片加载完成之前，会显示 alt 属性值来替代图片。</li>
</ol>
<h3>简述 <code>&lt;script&gt;</code> 标签中的 defer 和 async 属性</h3>
<ol>
<li>
<p>如果两个属性都没有（默认行为），脚本的下载和执行将会按照文档的先后顺序同步进行。当脚本下载和执行的时候，文档解析就会被阻塞，在脚本下载和执行完成之后文档才能往下继续进行解析。</p>
</li>
<li>
<p><code>defer</code> 属性表示脚本按顺序被解析到时就开始下载，下载过程中文档继续进行解析，当文档全部解析完成之后便开始执行下载好的脚本，这相当于在 <code>DOMContentLoaded</code> 的监听事件内进行执行。虽然 <code>defer</code> 属性的脚本需要等到文档解析完才开始执行，但其执行是有顺序的。</p>
</li>
<li>
<p><code>async</code> 属性表示脚本按顺序被解析到时就开始下载，下载过程中文档继续进行解析，当下载完成后文档停止解析开始执行下载好的脚本，脚本执行完后继续解析文档。<code>async</code> 脚本由于网络等的影响将不会按照顺序执行。</p>
</li>
</ol>
<pre><code class="language-javascript">&lt;script src=&quot;myscript.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;myscript.js&quot; defer&gt;&lt;/script&gt;
&lt;script src=&quot;myscript.js&quot; async&gt;&lt;/script&gt; 
</code></pre>
<ol start="4">
<li>把带 <code>defer</code> 属性的脚本放在 <code>&lt;head&gt;</code> 中比无属性的脚本放在 <code>&lt;/body&gt;</code> 之前要更好，因为浏览器在页面解析时可对带 <code>defer</code> 属性的脚本进行下载。</li>
<li>如果脚本相互依赖，请使用 <code>defer</code>。</li>
<li>如果脚本是独立的，请使用 <code>async</code>。</li>
<li>如果 DOM 必须解析好才执行且执行函数没有放在 <code>DOMContentLoaded</code> 的监听器中，请使用 <code>defer</code>。</li>
</ol>
<h3>什么是 DOM？</h3>
<p>DOM（文档对象模型）是可扩展标记语言的标准编程接口，用来处理如 HTML 或 XML 这样由节点组成的树形结构的标记语言。这些节点（例如元素和文本节点）都是能够被编程接口操作的对象，他们任何可见的改变都会在文档中实时反映出来。在浏览器中，这些接口可供 JavaScript 进行使用，使其操作 DOM 节点来改变他们的样式、内容、在文档中的位置或者通过事件监听器来进行交互。</p>
<ol>
<li>DOM 的设计与特定的编程语言相独立，以便使文档的结构化表述可以通过单一、一致的 API 获得。</li>
<li>随着页面的加载，DOM 在浏览器中是逐步构建的，因此脚本通常放在页面底部，或设置 <code>defer</code> 属性后置于 <code>&lt;head&gt;</code> 中，或放在 <code>DOMContentLoaded</code> 事件监听器内部。为了避免错误，脚本对 DOM 节点的操作应该放在 DOM 完成构建之后。</li>
<li><code>document.getElementById()</code> 和 <code>document.querySelector()</code> 是用来选择 DOM 节点的常用方法。</li>
<li><code>BOM</code> 主要处理浏览器窗口和框架，不过通常浏览器特定的 <code>JavaScript</code> 扩展都被看做 BOM 的一部分。<code>window</code> 对象的属性和方法通常被称为 <code>BOM</code>。<code>DOM</code> 描述了处理网页内容的方法和接口，<code>BOM</code> 描述了与浏览器进行交互的方法和接口。</li>
</ol>
<h3>XHTML 和 HTML 有什么不同?</h3>
<ol>
<li>XHTML 是更严格更纯净的 HTML 代码，他必须包含 <code>&lt;DOCTYPE&gt;</code></li>
<li>XHTML 属性值必须使用双引号扩起来</li>
<li>XHTML 属性值不能省略。如 <code>checked=&quot;checked&quot;</code> 不能简写为 <code>checked</code></li>
<li>XHTML 元素必须被正确地嵌套。</li>
<li>XHTML 元素必须被关闭 如 <code>&lt;br&gt;</code> 必须写为 <code>&lt;br /&gt;</code></li>
<li>XHTML 标签名必须使用小写字母</li>
<li>XHTML 文档必须拥有根元素</li>
<li>XHTML 中特殊字符必须转译</li>
<li>不同的浏览器对 HTML 标签嵌套错误的兼融性处理存在一定的区别。当嵌套错误时，可能会导致在某些浏览器上依旧能正常显示，而某些浏览器上则显示错乱甚至出现 JavaScript 报错。</li>
</ol>
<h3>rel=&quot;noopener&quot;  应在什么场景下使用，为什么？</h3>
<ol>
<li><code>rel=&quot;noopener&quot;</code> 是 <code>&lt;a&gt;</code> 超链接标签的一个属性。他可以禁止打开的新页面中使用 <code>window.opener</code> 属性，这样一来打开的新页面就不能通过 <code>window.opener</code> 去操作你的页面, 否则就会导致严重的安全漏洞。</li>
<li>如果使用 JavaScript 打开的页面，可以通过如下代码解决：</li>
</ol>
<pre><code>var hacpaiWindow = window.open('https://hacpai.com');
hacpaiWindow.opener = null;
</code></pre>
<h3>什么是 HTML5 存储？解释一下 <code>localStorage</code> 和 <code>sessionStorage</code></h3>
<ol>
<li>页面可以在用户的浏览器中存储本地数据 这些数据以 key/value 的格式进行存储。</li>
<li>通过 <code>localStorage</code> 存储的数据是持久化的 不会过期，除非清除缓存。</li>
<li><code>sessionStorage</code> 存储数据的生命周期和顶层窗口或浏览器标签页的一样。当标签页被永久关闭，通过 <code>sessionStorage</code> 存储的数据也将被删除。同一个页面被浏览器的两个标签页打开，这两个标签页中的 <code>sessionStorage</code> 数据是互相独立的。</li>
<li>还有Cookie也可以存储数据</li>
<li>localStorage 比 cookie 要大（5MB左右）</li>
</ol>
<h3>MIME type</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a></p>
<blockquote>
<p>没用过...</p>
</blockquote>
<h3>新标签兼容低版本</h3>
<p>ie9之前版本通过createElement创建html5新标签
引入html5shiv.js <a href="https://github.com/aFarkas/html5shiv">https://github.com/aFarkas/html5shiv</a></p>
<h2>CSS</h2>
<h3>CSS盒模型</h3>
<pre><code class="language-css">/* 标准模型 */
box-sizing:content-box;
 /*IE模型*/
box-sizing:border-box;
</code></pre>
<p>盒模型分为IE盒模型和W3C标准盒模型。
IE盒模型和W3C标准盒模型的区别是什么？</p>
<ol>
<li>
<p>W3C 标准盒模型：
属性width,height只包含内容content，不包含border和padding。</p>
</li>
<li>
<p>IE 盒模型：
属性width,height包含border和padding，指的是content+padding+border。</p>
</li>
</ol>
<p>在ie8+浏览器中使用哪个盒模型可以由box-sizing(CSS新增的属性)控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6,7,8中DOCTYPE缺失会触发IE模式。在当前W3C标准中盒模型是可以通过box-sizing自由的进行切换的。
content-box（标准盒模型）
width = 内容的宽度
height = 内容的高度
border-box（IE盒模型）
width = border + padding + 内容的宽度
height = border + padding + 内容的高度</p>
<h3>BEM</h3>
<p>BEM（Block, Element, Modifier）是一种基于组件的对 CSS 类名进行约定的 Web 开发方法。</p>
<p><a href="https://www.w3cplus.com/css/css-architecture-1.html">https://www.w3cplus.com/css/css-architecture-1.html</a></p>
<p><a href="https://css-tricks.com/bem-101/">https://css-tricks.com/bem-101/</a></p>
<h3>CSS 预处理器有什么优势？</h3>
<p>CSS 预处理器添加了一些实用的原生 CSS 没有的的功能，并且他通过使用 DRY（Don't Repeat Yourself）原则使生成的 CSS 更加整洁和易于维护</p>
<ul>
<li>CSS 预处理器虽然允许我们编写易于维护和可扩展的 CSS，但需要安装、配置、编译等（一般项目都配置好了</li>
<li>CSS 预处理器还包含文件切分、模块化、运算、函数等优势</li>
<li>目前主流的 CSS 预处理器有： <a href="https://link.ld246.com/forward?goto=https%3A%2F%2Fsass-lang.com%2F">Sass</a>、<a href="https://link.ld246.com/forward?goto=http%3A%2F%2Flesscss.org%2F">Less</a>、<a href="https://link.ld246.com/forward?goto=http%3A%2F%2Fstylus-lang.com%2F">Stylus</a></li>
<li>CSS 除了预处理器外还有后置处理器（Postprocessor），如：<a href="https://link.ld246.com/forward?goto=https%3A%2F%2Fgithub.com%2Fpostcss%2Fautoprefixer">Autoprefixer</a> 等</li>
<li>CSS 变量虽然已被大多数浏览器支持，但语法及可用性都不如 CSS 预处理器。</li>
</ul>
<h3>使用 flexbox，Create 3 Col 布局  col-{n} / 12</h3>
<pre><code class="language-html">&lt;style&gt;
  .row {
    display: flex;
  }
  .row_col {
    background-color: aqua;
    height: 300px;
    margin: 10px;
    box-sizing: border-box;
  }
  .row_col-2 {
    flex-grow: 2;
  }
  .row_col-4 {
    flex-grow: 4;
  }
  .row_col-7 {
    flex-grow: 7;
  }
&lt;/style&gt;
&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;row_col row_col-2&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;row_col row_col-7&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;row_col row_col-4&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3><code>@media</code></h3>
<p><code>@media</code> 是可根据一个或多个基于媒体特征、媒体类型等条件来使用样式的规则。其包含以下四种媒体类型：</p>
<ul>
<li><code>all</code>：适用于所有设备，默认选项</li>
<li><code>print</code>：仅适用于打印设备</li>
<li><code>screen</code>：仅适用于台式机、平板电脑、手机等屏幕</li>
<li><code>speech</code>：仅适用于屏幕阅读器</li>
<li>其余的媒体类型：<code>tty</code>，<code>tv</code>，<code>projection</code>，<code>handheld</code>，<code>braille</code>，<code>embossed</code>，<code>aural</code> 在 Media Queries Level 3 中已被废弃</li>
<li>可以使用逻辑操作符（<code>,</code>，<code>only</code>，<code>and</code>，<code>not</code>）组合媒体类型</li>
<li>iPhone X 系列存在安全距离，其 @media 识别如下：(自己没有用过 一般只判断了底部的安全距离 <a href="https://aotu.io/notes/2017/11/27/iphonex/index.html">网页适配 iPhoneX</a>)</li>
</ul>
<pre><code>// iPhone XR 1792x828px at 326ppi
@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) {
    ...
}
// iPhone XS 2436x1125px at 458ppi
@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {
    ...
}
// iPhone XS Max 2688x1242px at 458ppi
@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) {
    ...
}
</code></pre>
<pre><code class="language-html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, viewport-fit=cover&quot;&gt;
</code></pre>
<pre><code class="language-css">body {
  padding-bottom: constant(safe-area-inset-bottom);
  padding-bottom: env(safe-area-inset-bottom);
}
</code></pre>
<h3>描述 CSS 盒子模型布局并简要描述</h3>
<p>CSS 盒子模型（Box Model）布局包含内容（content）、内边距（padding）、边框（border）、外边距（margin）四个部分。</p>
<ul>
<li>content：盒子内部填充元素内容（例如文本、图像或视频播放器等）的区域。他的大小为 <code>content-box</code> 的宽和高。相关 CSS 属性为 <code>width</code>，<code>min-width</code>，<code>max-width</code>，<code>height</code>，<code>min-height</code>，<code>max-height</code>。</li>
<li>padding：内容周围的区域。他的大小为 <code>padding-box</code> 的宽和高。由 CSS 中的 <code>padding</code> 属性控制。</li>
<li>border：边框，在内边距的外围。他的大小为 <code>border-box</code> 的宽和高。由 CSS 中的 <code>border</code> 属性控制。</li>
<li>margin：最外围的透明区域，即边框外围区域。他可以将 DOM 中相邻的元素分开。他的大小为 <code>margin-box</code> 的宽和高。由 CSS 中的 <code>margin</code> 属性控制。</li>
</ul>
<p><img src="https://img.hacpai.com/e/cf8a06004b444fb895eb315d78f46324.gif" alt="alt text"></p>
<ul>
<li>标准盒模型：属性 width / height 只包含 content，不包含 border 和 padding</li>
<li>IE 盒模型：属性 width / height 包含 content + padding + border</li>
<li>IE6/7/8 中 DOCTYPE 缺失会触发 IE 盒模型，标准中可使用 <code>box-sizing</code> 属性进行控制：content-box | border-box | inherit</li>
<li>JavaScript 如何设置和获取盒模型对应的宽和高</li>
<li><code>element.style.width / height</code> 只能取到行内样式的宽和高，style 标签中和 link 外链的样式无法获取</li>
<li><code>window.getComputedStyle(element).width / height</code> 获取元素的宽或高：content + padding + border + 'px'</li>
<li><code>dom.getBoundingClientRect().width / height</code> 同上，但返回值为数字类型，不含 <code>px</code></li>
<li>页面中多个元素的流布局属于格式化上下文（formatting context），这个元素可能是块元素也可能是行内元素。块元素的为 BFC（Block formatting contexts），行内元素的为 IFC（Inline formatting contexts）。常见场景如：垂直块元素 <code>margin</code> 重叠；行内元素高度由 <code>line-height</code> 决定等。</li>
</ul>
<h3><code>em</code>  <code>rem</code> 区别</h3>
<p><code>em</code> 和 <code>rem</code> 都是基于 <code>font-size</code> 的 CSS 属性。唯一的区别是他们继承的对象不同。</p>
<ul>
<li><code>em</code> 继承父元素中的 <code>font-size</code></li>
<li><code>rem</code> 继承根元素（<code>html</code>）中的 <code>font-size</code></li>
<li>在大多数浏览器中，根元素的 <code>font-size</code> 默认值为 <code>16px</code></li>
</ul>
<p><strong>其他单位</strong></p>
<ul>
<li>vh<code>和</code>vw<code>：窗口高度或宽度的 1/100。可脱离父元素的继承规则，如：窗口高 900px，父元素高 1200px，1vh 为 9px。</code></li>
<li><code>vmin</code> 和 <code>vmax</code>：窗口高、宽取其最大或最小的 1/100。主要用于手机屏幕旋转，如：窗口高 900px，宽 600px，1vmin 为 6px，1vmax 为 9px</li>
<li>ex<code>和</code>ch<code>：分别为小写 x 的高度和数字 0 的宽度。主要用于精细排版中。</code> (没用过)</li>
<li><code>mm</code> 毫米、<code>cm</code> 厘米、<code>in</code> 英寸、<code>pt</code> 点（1/72 英寸）、<code>pc</code> 十二点活字（12 pt）。这些绝对单位之间的关系为：1in = 2.54cm = 25.4mm = 72pt = 6pc （没用过</li>
<li>px</li>
<li>% 百分比</li>
</ul>
<p><img src="https://img.hacpai.com/file/2018/12/image-52a5242f.png?imageView2/2/interlace/1/format/webp" alt="imagepng"></p>
<ul>
<li>其中 <code>rem</code>、<code>em</code> 、<code>vh</code>、<code>vx</code>、<code>vmin</code>、<code>vmax</code>、<code>%</code> 通常用于自适应方案中</li>
<li>移动端可采用 <code>viewport</code> 进行响应式设计 <a href="https://www.runoob.com/css/css-rwd-viewport.html">https://www.runoob.com/css/css-rwd-viewport.html</a></li>
</ul>
<h3>CSS sprites</h3>
<ol>
<li>CSS sprites 将多张图片合并为一张图片，从而减少浏览器对 HTTP 的请求数量，进而减少网页的加载时间。即使在 HTTP/2 协议下，这依旧可以减少网页的加载时间。</li>
<li>在 HTTP/1.1 中，每个 TCP 连接只允许一个请求。现代浏览器虽然可以打开多个（2-8）并行的 TCP 连接，但连接数量依旧有限。</li>
<li>HTTP/2 允许浏览器和服务器之间的多个请求在一个 TCP 连接上进行复用。 这意味着 TCP 连接被更有效的使用了：同一个页面在打开和关闭 TCP 连接的次数被减少了，客户端和服务器之间的延迟也被减少了。这样一来，数十个图片就可以在同一个 TCP 连接中并行加载了。</li>
<li>在 CSS 中使用 sprites 需要用到 CSS 中的 <code>background-image</code>、<code>background-position</code> 及 <code>background-size</code> 等属性</li>
</ol>
<h3>CSS 优先级</h3>
<p><strong>权重记忆口诀</strong>：<em>从0开始，一个行内样式+1000，一个id选择器+100，一个属性选择器、class或者伪类+10，一个元素选择器，或者伪元素+1，通配符+0。</em></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/41604775">https://zhuanlan.zhihu.com/p/41604775</a></p>
<h2>Javascript</h2>
<h3>JS中数据类型</h3>
<p><strong>基本数据类型</strong>： undefined、null、Boolean、Number、String和Symbol(ES6)
<strong>引用数据类型</strong>： Object(Array, Date, RegExp, Function)</p>
<h3>基本数据类型和引⽤类型在存储上的差别</h3>
<p>前者存储在栈上，后者存储在堆上(没太理解...)</p>
<h3><code>var</code>、<code>let</code>、<code>const</code> 和没有关键字的声明有什么区别？</h3>
<h4>无关键字</h4>
<p>在变量赋值之前如果没有关键字的话，则会把变量分配给全局变量或覆盖已经声明的变量。在非严格模式下将会把变量做为全局对象（浏览器中的 <code>window</code>）的一个属性。在严格模式下，他将抛出异常以防止创建不需要的全局变量。</p>
<h4>var</h4>
<p><code>var</code> 是 ES2015 以前声明变量的默认语句。他在函数作用域内创建的变量可以在该作用域中被重新赋值和重新声明。</p>
<p>以下代码片断中，在执行 <code>setTimeout</code> 回调时，循环完已经完成且变量 <code>i</code> 变为了 10，因此十个回调都引用了函数作用域中的同一个变量。</p>
<pre><code>for (var i = 0; i &lt; 10; i++) {
  setTimeout(() =&gt; {
    console.log(i) // 10
  })
}
</code></pre>
<p>可以通过创建一个新的函数作用域来解决此问题</p>
<pre><code>for (var i = 0; i &lt; 10; i++) {
  ;(i =&gt; {
    setTimeout(() =&gt; {
      console.log(i)
    })
  })(i)
} 
</code></pre>
<h4>let</h4>
<p><code>let</code> 是在 ES2015 中引入的，他是一种可在变量声明后可再赋值的常用声明方式。再次声明相同的变量将会抛出异常。他是有块作用域的，因此在循环中使用时将会保持在同一个作用域下迭代。</p>
<pre><code>for (let i = 0; i &lt; 10; i++) {
  setTimeout(() =&gt; {
    console.log(i) // 0 1 2...9
  })
} 
</code></pre>
<h4>const</h4>
<p><code>const</code> 是在 ES2015 中引入的，他是一种新的默认的常用的声明方式。他声明的所有变量将不可再被重新赋值，如果是对象的话，必须保持对象的引用不变。他是块作用域的，且不能被再次赋值。</p>
<pre><code>const myObject = {}
myObject.prop = &quot;hello!&quot; 
myObject = &quot;hello&quot; // Uncaught TypeError: Assignment to constant variable.
</code></pre>
<ul>
<li>所有声明在其范围内都会被提升。</li>
<li><code>let</code> 和 <code>const</code> 中有一个称为时间死区（temporal dead zone TDZ）的概念。虽然声明会被提升，但在进入作用域之后、声明之前他将无法被访问。</li>
<li>尽可能避免使用 <code>var</code> 使用 <code>let</code> 代替</li>
<li><code>const</code> 声明不变常量 <code>let</code> 声明可变变量</li>
</ul>
<h3>变量提升</h3>
<p>当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境。</p>
<p><code>var</code></p>
<pre><code class="language-react">b() // call b
console.log(a) // undefined

var a = 'Hello world'

function b() {
    console.log('call b')
}
</code></pre>
<p>因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。</p>
<p>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</p>
<pre><code class="language-react">b() // call b second

function b() {
    console.log('call b fist')
}
function b() {
    console.log('call b second')
}
var b = 'Hello world'
</code></pre>
<p><code>var</code> 会产生很多错误，所以在 ES6中引入了 <code>let</code>。<code>let</code> 不能在声明前使用，但是这并不是常说的 <code>let</code> 不会提升，<code>let</code> 提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用。</p>
<h3>bind、call、apply 区别</h3>
<p>首先说下前两者的区别。</p>
<p><code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</p>
<p>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组。</p>
<pre><code class="language-javascript">let a = {
    value: 1
}
function getValue(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value)
}
getValue.call(a, 'yck', '24')
getValue.apply(a, ['yck', '24'])

let getValueBind = getValue.bind(a)
getValueBind('yck', '25')
</code></pre>
<p><code>bind</code> 和其他两个方法作用也是一致的，只是该方法会返回一个函数 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind">MDN</a>。并且我们可以通过 <code>bind</code> 实现柯里化。</p>
<p><strong>利用 bind 实现柯里化</strong></p>
<p><a href="https://juejin.cn/post/6844903909723488264">source</a></p>
<pre><code class="language-javascript">function list() {
  return Array.prototype.slice.call(arguments);
}

var list1 = list(1, 2, 3); // [1, 2, 3]

var leadingThirtysevenList = list.bind(null, 37);

var list2 = leadingThirtysevenList(); 
// [37]

var list3 = leadingThirtysevenList(1, 2, 3); 
// [37, 1, 2, 3]

console.log(list2, list3)
</code></pre>
<h3>实现一个 bind 函数</h3>
<p>利用apply修改this绑定 简易实现 可以参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#polyfill">MDN</a></p>
<pre><code class="language-javascript">let obj = {
	a: 1
}

Function.prototype.myBind = function(context) {
  if (typeof this !== 'function') {
  	throw new TypeError('Error')
  }

  let _this = this
  let args = [...arguments].slice(1)
  
  return function() {
  	let argsSlice = [...arguments].slice()
    return _this.apply(context, args.concat(argsSlice))
  }
}


function log(b, c) {
	console.log(this.a, b, c)
}

console.log('------1------')
log('b1', 'c1')

let logBind = log.bind(obj)
console.log('------2------')
logBind('b2', 'c2')

let logMyBind = log.myBind(obj)
console.log('------3------')
logMyBind('b3', 'c3')

&quot;------1------&quot;
undefined, &quot;b1&quot;, &quot;c1&quot;
&quot;------2------&quot;
1, &quot;b2&quot;, &quot;c2&quot;
&quot;------3------&quot;
1, &quot;b3&quot;, &quot;c3&quot;
</code></pre>
<h3>实现一个 call 函数</h3>
<pre><code class="language-javascript">let obj = {
	a: 1
}

Function.prototype.myCall = function(context = window) {
	context.fn = this
  let args = [...arguments].slice(1)
  let result = context.fn(...args)
  delete context.fn
  return result
}

function log(b, c) {
	console.log(this.a, b, c)
}

log.myCall(obj, 'b', 'c')

// 1, &quot;b&quot;, &quot;c&quot;
</code></pre>
<p>this是 log fn，args  是后面的参数</p>
<h3>实现一个 apply 函数</h3>
<pre><code class="language-javascript">let obj = {
	a: 1
}

Function.prototype.myApply = function (context = window) {
  context.fn = this

  let result
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }

  delete context.fn
  return result
}

function log(b, c) {
	console.log(this.a, b, c)
}

log.myApply(obj, ['b', 'c'])

// 1, &quot;b&quot;, &quot;c&quot;
</code></pre>
<h3>简单说下原型链</h3>
<p><a href="https://github.com/KieSun/Dream/issues/2">https://github.com/KieSun/Dream/issues/2</a></p>
<h3>怎么判断对象类型</h3>
<p><a href="https://www.cnblogs.com/onepixel/p/5126046.html">https://www.cnblogs.com/onepixel/p/5126046.html</a></p>
<ul>
<li>typeof typeof {} // &quot;object&quot;</li>
<li>instanceof new Object() instanceof Object // true</li>
<li>constructor ''.constructor == String // true</li>
<li>toString 可以通过 <code>Object.prototype.toString.call(xx)</code>。这样我们就可以获得类似 <code>[object Type]</code> 的字符串。 Object.prototype.toString.call({}) &quot;[object Object]&quot;</li>
</ul>
<h3>typeof</h3>
<p>以下代码的执行结果是什么？</p>
<pre><code class="language-javascript">typeof typeof 0 // string
</code></pre>
<p><code>typeof 0</code> 返回字符串 <code>number</code>， 因此 <code>typeof 'number'</code> 的结果为 <code>string</code>。</p>
<ul>
<li><code>typeof</code> 可能的返回值</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td><code>undefined</code></td>
</tr>
<tr>
<td>null</td>
<td><code>object</code></td>
</tr>
<tr>
<td>boolean</td>
<td><code>boolean</code></td>
</tr>
<tr>
<td>number</td>
<td><code>number</code></td>
</tr>
<tr>
<td>string</td>
<td><code>string</code></td>
</tr>
<tr>
<td>Symbol()</td>
<td><code>symbol</code></td>
</tr>
<tr>
<td>函数</td>
<td><code>function</code></td>
</tr>
<tr>
<td>其他对象</td>
<td><code>object</code></td>
</tr>
</tbody>
</table>
<ul>
<li>使用 <code>new</code> 关键字</li>
</ul>
<pre><code class="language-javascript">var str = new String('String');
typeof str; // &quot;object&quot;
var func = new Function();
typeof func; // &quot;function&quot;
</code></pre>
<ul>
<li>使用括号</li>
</ul>
<pre><code class="language-javascript">typeof 11 + ' Wisen'; // &quot;number Wisen&quot;
typeof (11 + ' Wisen'); // &quot;string&quot;
</code></pre>
<ul>
<li>未定义变量异常</li>
</ul>
<pre><code class="language-javascript">typeof undeclaredVariable === 'undefined'; // true
typeof newLetVariable; let newLetVariable; // VM90195:1 Uncaught ReferenceError: newLetVariable is not defined
typeof newConstVariable; const newConstVariable = 'hello'; // VM90283:1 Uncaught ReferenceError: Cannot access 'newConstVariable' before initialization
</code></pre>
<ul>
<li>特例</li>
</ul>
<pre><code class="language-javascript">typeof document.all === 'undefined'; // true

typeof document.all // &quot;undefined&quot;
</code></pre>
<h3>箭头函数的特点</h3>
<p><strong>箭头函数表达式</strong>的语法比<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>更简洁，并且没有自己的<code>this</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">MDN</a></p>
<h3>This</h3>
<p>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值（运行时绑定）。<code>this</code> 不能在执行期间被赋值，并且在每次函数被调用时 <code>this</code> 的值也可能会不同。ES5 引入了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a> 方法来设置函数的 <code>this</code> 值，而不用考虑函数如何被调用的。ES2015 引入了<a href="https://wiki.developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，箭头函数不提供自身的 this 绑定（<code>this</code> 的值将保持为闭合词法上下文的值）。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">MDN</a></p>
<pre><code class="language-javascript">function foo() {
	console.log(this.a)
}
var a = 1
foo() // 1

var obj = {
	a: 2,
	foo: foo
}
obj.foo() // 2

// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况

// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向
var c = new foo() // undefined
c.a = 3
console.log(c.a)

// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new
</code></pre>
<h3>async、await 优缺点</h3>
<p><code>async 和 await</code> 相比直接使用 <code>Promise</code> 来说，优势在于处理 <code>then</code> 的调用链，能够更清晰准确的写出代码。解决回调地狱</p>
<p>缺点在于滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p>
<pre><code class="language-javascript">var a = 0
var b = async () =&gt; {
  a = a + await 10
  console.log('2', a) // -&gt; '2' 10
  a = (await 10) + a
  console.log('3', a) // -&gt; '3' 20
}
b()
a++
console.log('1', a) // -&gt; '1' 1
</code></pre>
<ul>
<li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为在 <code>await</code> 内部实现了 <code>generators</code> ，<code>generators</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li>
<li>因为 <code>await</code> 是异步操作，遇到<code>await</code>就会立即返回一个<code>pending</code>状态的<code>Promise</code>对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 <code>console.log('1', a)</code></li>
<li>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 10</code></li>
<li>然后后面就是常规执行代码了</li>
</ul>
<h3>generator 原理</h3>
<p>Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用来异步编程</p>
<pre><code class="language-javascript">// 使用 * 表示这是一个 Generator 函数
// 内部可以通过 yield 暂停代码
// 通过调用 next 恢复执行
function* test() {
  let a = 1 + 2;
  yield 2;
  yield 3;
}
let b = test();
console.log(b.next()); // &gt;  { value: 2, done: false }
console.log(b.next()); // &gt;  { value: 3, done: false }
console.log(b.next()); // &gt;  { value: undefined, done: true }
</code></pre>
<p>从以上代码可以发现，加上 <code>*</code> 的函数执行后拥有了 <code>next</code> 函数，也就是说函数执行后返回了一个对象。每次调用 <code>next</code> 函数可以继续执行被暂停的代码。</p>
<p>实现......</p>
<h3>Promise</h3>
<p>Promise 是 ES6 新增的语法，解决了回调地狱的问题。</p>
<p>可以把 Promise 看成一个状态机。初始是 <code>pending</code> 状态，可以通过函数 <code>resolve</code> 和 <code>reject</code> ，将状态转变为 <code>resolved</code> 或者 <code>rejected</code> 状态，状态一旦改变就不能再次变化。</p>
<h3>如何实现一个 Promise</h3>
<p><a href="https://github.com/xiaotiandada/blog/issues/71">Promise的源码实现</a></p>
<h3>sort函数</h3>
<p>V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 插入，比10大的数组则使用 快排。</p>
<h3>垃圾回收</h3>
<p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p>
<h4>新生代算法</h4>
<p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p>
<p>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p>
<h4>老生代算法</h4>
<p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p>
<p>在讲算法前，先来说下什么情况下对象会出现在老生代空间中：</p>
<ul>
<li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li>
<li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</li>
</ul>
<p>老生代中的空间很复杂，有如下几个空间</p>
<pre><code class="language-typescript">enum AllocationSpace {
  // TODO(v8:7464): Actually map this space's memory as read-only.
  RO_SPACE,    // 不变的对象空间
  NEW_SPACE,   // 新生代用于 GC 复制算法的空间
  OLD_SPACE,   // 老生代常驻对象空间
  CODE_SPACE,  // 老生代代码对象空间
  MAP_SPACE,   // 老生代 map 对象
  LO_SPACE,    // 老生代大空间对象
  NEW_LO_SPACE,  // 新生代大空间对象

  FIRST_SPACE = RO_SPACE,
  LAST_SPACE = NEW_LO_SPACE,
  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,
  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE
};

</code></pre>
<p>在老生代中，以下情况会先启动标记清除算法：</p>
<ul>
<li>某一个空间没有分块的时候</li>
<li>空间中被对象超过一定限制</li>
<li>空间不能保证新生代中的对象移动到老生代中</li>
</ul>
<p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 <a href="https://v8project.blogspot.com/2018/06/concurrent-marking.html">该博客</a> 详细阅读。</p>
<p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p>
<h3>浏览器 Eventloop 和 Node 中的有什么区别</h3>
<p>众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题。</p>
<p>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p>
<pre><code class="language-javascript">console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

console.log('script end');
</code></pre>
<p>以上代码虽然 <code>setTimeout</code> 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 <code>setTimeout</code> 还是会在 <code>script end</code> 之后打印。</p>
<p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 <code>jobs</code>，macrotask 称为 <code>task</code>。</p>
<pre><code class="language-javascript">console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

new Promise((resolve) =&gt; {
    console.log('Promise')
    resolve()
}).then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');
// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout
</code></pre>
<p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务，所以会有以上的打印。</p>
<p>微任务包括 <code>process.nextTick</code> ，<code>promise</code> ，<code>Object.observe</code> ，<code>MutationObserver</code></p>
<p>宏任务包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code></p>
<p>很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。</p>
<p>所以正确的一次 Event loop 顺序是这样的</p>
<ol>
<li>执行同步代码，这属于宏任务</li>
<li>执行栈为空，查询是否有微任务需要执行</li>
<li>执行所有微任务</li>
<li>必要的话渲染 UI</li>
<li>然后开始下一轮 Event loop，执行宏任务中的异步代码</li>
</ol>
<p>通过上述的  Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。</p>
<h4>Node 中的 Event loop</h4>
<p><strong>TODO 记录一下 还没理解...</strong></p>
<p>Node 中的 Event loop 和浏览器中的不相同。</p>
<p>Node 的 Event loop 分为6个阶段，它们会按照顺序反复运行</p>
<pre><code>┌───────────────────────┐
┌─&gt;│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │&lt;──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
</code></pre>
<p><strong>timer</strong></p>
<p>timers 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code></p>
<p>一个 <code>timer</code> 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟。</p>
<p>下限的时间有一个范围：<code>[1, 2147483647]</code> ，如果设定的时间不在这个范围，将被设置为1。</p>
<p>**I/O **</p>
<p>I/O 阶段会执行除了 close 事件，定时器和 <code>setImmediate</code> 的回调</p>
<p><strong>idle, prepare</strong></p>
<p>idle, prepare 阶段内部实现</p>
<p><strong>poll</strong> 轮询</p>
<p>poll 阶段很重要，这一阶段中，系统会做两件事情</p>
<ol>
<li>执行到点的定时器</li>
<li>执行 poll 队列中的事件</li>
</ol>
<p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p>
<ul>
<li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li>
<li>如果 poll 队列为空，会有两件事发生
<ul>
<li>如果有 <code>setImmediate</code> 需要执行，poll 阶段会停止并且进入到 check 阶段执行 <code>setImmediate</code></li>
<li>如果没有 <code>setImmediate</code> 需要执行，会等待回调被加入到队列中并立即执行回调</li>
</ul>
</li>
</ul>
<p>如果有别的定时器需要被执行，会回到 timer 阶段执行回调。</p>
<p><strong>check</strong></p>
<p>check 阶段执行 <code>setImmediate</code></p>
<p><strong>close callbacks</strong></p>
<p>close callbacks 阶段执行 close 事件</p>
<p>并且在 Node 中，有些情况下的定时器执行顺序是随机的</p>
<pre><code>setTimeout(() =&gt; {
    console.log('setTimeout');
}, 0);
setImmediate(() =&gt; {
    console.log('setImmediate');
})
// 这里可能会输出 setTimeout，setImmediate
// 可能也会相反的输出，这取决于性能
// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate
// 否则会执行 setTimeout
</code></pre>
<p>当然在这种情况下，执行顺序是相同的</p>
<pre><code>var fs = require('fs')

fs.readFile(__filename, () =&gt; {
    setTimeout(() =&gt; {
        console.log('timeout');
    }, 0);
    setImmediate(() =&gt; {
        console.log('immediate');
    });
});
// 因为 readFile 的回调在 poll 中执行
// 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调
// 再去 timer 阶段执行 setTimeout
// 所以以上输出一定是 setImmediate，setTimeout
</code></pre>
<p>上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行。</p>
<pre><code>setTimeout(()=&gt;{
    console.log('timer1')

    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)

setTimeout(()=&gt;{
    console.log('timer2')

    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)

// 以上代码在浏览器和 node 中打印情况是不同的
// 浏览器中一定打印 timer1, promise1, timer2, promise2
// node 中可能打印 timer1, timer2, promise1, promise2
// 也可能打印 timer1, promise1, timer2, promise2
</code></pre>
<p>Node 中的 <code>process.nextTick</code> 会先于其他 microtask 执行。</p>
<pre><code>setTimeout(() =&gt; {
  console.log(&quot;timer1&quot;);

  Promise.resolve().then(function() {
    console.log(&quot;promise1&quot;);
  });
}, 0);

process.nextTick(() =&gt; {
  console.log(&quot;nextTick&quot;);
});
// nextTick, timer1, promise1
</code></pre>
<h3>setTimeout 倒计时误差</h3>
<p>JS 是单线程的，所以 <code>setTimeout</code> 的误差其实是无法被完全解决的，原因有很多，可能是回调中的，有可能是浏览器中的各种事件导致。这也是为什么页面开久了，定时器会不准的原因</p>
<p>可以通过一定的办法去减少这个误差。以下是一个相对准备的倒计时实现</p>
<p><strong>TODO 没看懂</strong></p>
<pre><code class="language-javascript">var period = 60 * 1000 * 60 * 2
var startTime = new Date().getTime();
var count = 0
var end = new Date().getTime() + period
var interval = 1000
var currentInterval = interval

function loop() {
  count++
  var offset = new Date().getTime() - (startTime + count * interval); // 代码执行所消耗的时间
  var diff = end - new Date().getTime()
  var h = Math.floor(diff / (60 * 1000 * 60))
  var hdiff = diff % (60 * 1000 * 60)
  var m = Math.floor(hdiff / (60 * 1000))
  var mdiff = hdiff % (60 * 1000)
  var s = mdiff / (1000)
  var sCeil = Math.ceil(s)
  var sFloor = Math.floor(s)
  currentInterval = interval - offset // 得到下一次循环所消耗的时间
  console.log('时：'+h, '分：'+m, '毫秒：'+s, '秒向上取整：'+sCeil, '代码执行时间：'+offset, '下次循环间隔'+currentInterval) // 打印 时 分 秒 代码执行时间 下次循环间隔

  setTimeout(loop, currentInterval)
}

setTimeout(loop, currentInterval)
</code></pre>
<h3>深浅拷贝</h3>
<h4>= 赋值</h4>
<pre><code class="language-javascript">x = y
</code></pre>
<p>原理：引用类型 赋值操作符只是把存放在栈内容中的指针赋值给另外一个变量</p>
<h4>JSON.parse(JSON.stringify(x))</h4>
<pre><code class="language-javascript">let a = [1, 2, 3, 4]
let b = JSON.parse(JSON.stringify(a))

b[0] = 11

console.log('a', a)
console.log('b', b)
</code></pre>
<p><img src="https://user-images.githubusercontent.com/24250627/106392444-ccaa8d00-642c-11eb-9188-6649378bbf05.png" alt="image"></p>
<p>原理：通过 stringify 转成 string，然后通过 parse 转成对象</p>
<p>缺陷 有些属性被忽略了... <a href="https://segmentfault.com/a/1190000017773877">source</a></p>
<pre><code class="language-javascript">let obj = {
    nul: null,
    und: undefined,
    sym: Symbol('sym'),
    str: 'str',
    bol: true,
    num: 45,
    arr: [1, 4],
    reg: /[0-9]/,
    dat: new Date(),
    fun: function() {},  
}
console.log(JSON.parse(JSON.stringify(obj)))
</code></pre>
<p><img src="https://user-images.githubusercontent.com/24250627/106392596-8c97da00-642d-11eb-8f9f-28c33bcade33.png" alt="image"></p>
<p>undefined、symbol、function 忽略掉了，reg 缺内容(或许还有别的也会忽略 没测试全面)</p>
<h4>Object.assign()</h4>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a></p>
<p><img src="https://user-images.githubusercontent.com/24250627/106392923-fcf32b00-642e-11eb-88a4-3ad6b71b32c2.png" alt="image"></p>
<pre><code class="language-javascript">let obj = {
    a: {
        a1: 'a1'
    },
    b: 'b'
}
let ass = Object.assign({}, obj);
ass.a.a1 = 'aaa';
ass.b = 'bbb';
console.log(obj, ass);
</code></pre>
<p>适用于只有一层数据的对象</p>
<h4>展开运算符(...)</h4>
<p><img src="https://user-images.githubusercontent.com/24250627/106393041-a2a69a00-642f-11eb-8c05-86037f4da1bd.png" alt="image"></p>
<pre><code class="language-javascript">let obj = {
    a: {
        a1: 'a1'
    },
    b: 'b'
}
let ass = {...obj};
ass.a.a1 = 'aaa';
ass.b = 'bbb'

console.log('obj', obj)
console.log('ass', ass)
</code></pre>
<p>适用于只有一层数据的对象</p>
<h4>Slice</h4>
<p><img src="https://user-images.githubusercontent.com/24250627/106426558-c81fbc00-64a0-11eb-9d05-7c1fcb0ab8bb.png" alt="image"></p>
<pre><code class="language-javascript">var arr = ['a', 'b', 'c'];
var arrCopy = arr.slice(0);
arrCopy[0] = 'test'
console.log(arr); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
console.log(arrCopy); // [&quot;test&quot;, &quot;b&quot;, &quot;c&quot;]

var arr1 = [{&quot;name&quot;:&quot;weifeng&quot;},{&quot;name&quot;:&quot;boy&quot;}];//原数组
var arr2 = arr1.slice(0);//拷贝数组
arr1[1].name=&quot;girl&quot;;
console.log(arr1);// [{&quot;name&quot;:&quot;weifeng&quot;},{&quot;name&quot;:&quot;girl&quot;}]
console.log(arr2);//[{&quot;name&quot;:&quot;weifeng&quot;},{&quot;name&quot;:&quot;girl&quot;}
</code></pre>
<p>适用于只有一层数据 <a href="https://juejin.cn/post/6844903647856295949">code</a></p>
<h4>Concat</h4>
<p><img src="https://user-images.githubusercontent.com/24250627/106426742-1cc33700-64a1-11eb-9318-ffee1e82143d.png" alt="image"></p>
<pre><code class="language-javascript">var arr = ['a', 'b', 'c'];
var arrCopy = [].concat(arr);
arrCopy[0] = 'test'
console.log(arr); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
console.log(arrCopy); // [&quot;test&quot;, &quot;b&quot;, &quot;c&quot;]

var arr1 = [{&quot;name&quot;:&quot;Roubin&quot;},{&quot;name&quot;:&quot;RouSe&quot;}];//原数组
var arr2 = [].concat(arr1);//拷贝数组
arr1[1].name=&quot;Tom&quot;;
console.log(arr1);//[{&quot;name&quot;:&quot;Roubin&quot;},{&quot;name&quot;:&quot;Tom&quot;}]
console.log(arr2);//[{&quot;name&quot;:&quot;Roubin&quot;},{&quot;name&quot;:&quot;Tom&quot;}]
</code></pre>
<p>适用于只有一层数据 <a href="https://juejin.cn/post/6844903647856295949">code</a></p>
<h4>浅拷贝的实现</h4>
<pre><code class="language-javascript">let data = [1, 2, 3, 4]
let data1 = { a: 1, b: 2, c: 3, d: 4 }
let data2 = [ {a: 1}, { a: 2 }, { a: 3 }, { a: 4 }]
let data3 = { a: { z: 1 }, b: {z : 2}, c: { z: 3 }, d: { z: 4 } }

let shallowCopy = function(obj) {
  if (typeof obj !== 'object') return

  let newObj = obj instanceof Array ? [] : {}
  for (const key in obj) {
    if (Object.hasOwnProperty.call(obj, key)) {
      newObj[key] = obj[key]
    }
  }

  return newObj
}


let dataShallowCopy = shallowCopy(data)
let data1ShallowCopy = shallowCopy(data1)

dataShallowCopy[0] = 100
data1ShallowCopy.a = 100

console.log('dataShallowCopy', data, dataShallowCopy)
console.log('data1ShallowCopy', data1, data1ShallowCopy)

// dataShallowCopy [ 1, 2, 3, 4 ] [ 100, 2, 3, 4 ]
// data1ShallowCopy { a: 1, b: 2, c: 3, d: 4 } { a: 100, b: 2, c: 3, d: 4 }
</code></pre>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/32">code</a></p>
<h4>深拷贝的实现</h4>
<pre><code class="language-javascript">let deepCopy = function(obj) {
  if (typeof obj !== 'object') return

  let newObj = obj instanceof Array ? [] : {}
  for (const key in obj) {
    if (Object.hasOwnProperty.call(obj, key)) {
      newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]
    }
  }

  return newObj
}


let data2DeepCopy = deepCopy(data2)
let data3DeepCopy = deepCopy(data3)

data2DeepCopy[0].a = 100
data3DeepCopy.a.z = 100

console.log('data2DeepCopy', data2, data2DeepCopy)
console.log('data3DeepCopy', data3, data3DeepCopy)

// data2DeepCopy [ { a: 1 }, { a: 2 }, { a: 3 }, { a: 4 } ] [ { a: 100 }, { a: 2 }, { a: 3 }, { a: 4 } ]
// data3DeepCopy { a: { z: 1 }, b: { z: 2 }, c: { z: 3 }, d: { z: 4 } } { a: { z: 100 }, b: { z: 2 }, c: { z: 3 }, d: { z: 4 } }
</code></pre>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/32">code</a></p>
<h4>Lodash</h4>
<p>项目可以使用Lodash提供的方法</p>
<pre><code class="language-javascript">var objects = [{ 'a': 1 }, { 'b': 2 }]; 
var shallow = _.clone(objects);

console.log(shallow[0] === objects[0]);
// =&gt; true

var objects = [{ 'a': 1 }, { 'b': 2 }];
var deep = _.cloneDeep(objects);

console.log(deep[0] === objects[0]);
// =&gt; false
</code></pre>
<blockquote>
<p>用什么方法最终还是需要根据实际情况选择</p>
</blockquote>
<h3>数组去重</h3>
<h4>new Set</h4>
<pre><code class="language-javascript">let arr= [1, 2, 3, 3, 5, 7, 2, 6, 2, 8];
console.log([...new Set(arr
                        
// [1, 2, 3, 5, 7, 6, 8]
</code></pre>
<h4>一维数组</h4>
<pre><code class="language-javascript">function Deduplication(data) {

  if (!Array.isArray(data) ) {
    return data
  }

  let list = []

  for (let i = 0; i &lt; data.length; i++) {
    if (!list.includes(data[i])) {
      list.push(data[i])
    }
  }

  return list
}

let arrDedup = Deduplication(arr)
console.log('arrDedup', arrDedup)

//arrDedup [ 1, 2, 3, 5, 7, 6, 8, 4 ]
</code></pre>
<p>判断和Loop可以用 filter sort find indexOf includes 等等，原理应该差不多</p>
<h4>多维数组</h4>
<pre><code class="language-javascript">function Deduplications(data) {
  if (!Array.isArray(data) ) {
    return data
  }

  let list = []
  const flat = (data) =&gt; {
    for (let i = 0; i &lt; data.length; i++) {
      if (Array.isArray(data[i])) {
        flat(data[i])
      } else {
        list.push(data[i])
      }
    }
    return list
  }

  flat(data)

  return [ ...new Set(list) ]
}
let arrDedups = Deduplications(arrs)
console.log('arrDedups', arrDedups)

//  [ 1, 2, 3, 4, 5, 6 ]
</code></pre>
<p>先平铺数组 然后去重(也还有其他解法)</p>
<h4>Lodash</h4>
<pre><code class="language-javascript">let arr = [2, 1, 2, [ 1, [ 2, 3, [4, 5, 6, 7, 8, [ 0, 10 ] ] ] ] ]
let flatList = _.flattenDeep(arr);
let list = _.uniq(flatList)
console.log('list', list)

// [2, 1, 3, 4, 5, 6, 7, 8, 0, 10]
</code></pre>
<h3>数组降维</h3>
<pre><code class="language-javascript">const flattenDeep = arr =&gt; Array.isArray(arr) ?
      arr.reduce((a, b) =&gt; [...a, ...flattenDeep(b)] , []) : [arr]

console.log(flattenDeep([1, [[2], [3, [4]], 5]]))
// [1, 2, 3, 4, 5]
</code></pre>
<h3>['1', '7', '11'].map(parseInt) 输出结果</h3>
<p>[1, NaN, 3]</p>
<ul>
<li><code>parseInt(string, radix)</code> 将一个字符串转换为 <code>radix</code> 进制的整数。如果 <code>string</code> 无法被转化成数值类型将会返回 <code>NaN</code>。</li>
<li><code>radix</code> 为介于 2-36 之间的整数，通常默认值为 <code>10</code> <a href="https://www.w3school.com.cn/jsref/jsref_parseInt.asp">https://www.w3school.com.cn/jsref/jsref_parseInt.asp</a></li>
<li><code>map</code> 在每次迭代时都会将 <code>value</code>，<code>index</code>，<code>array</code> 三个参数传递到 <code>parseInt()</code> 中，因此 <code>['1', '7', '11'].map(parseInt)</code> 可以扩展为：</li>
</ul>
<pre><code class="language-js">parseInt('1', 0) // 1
parseInt('7', 1) // NaN
parseInt('11', 2) // 3
</code></pre>
<ul>
<li>改写为如下将会按预期执行：</li>
</ul>
<pre><code class="language-js">['1', '7', '11'].map(value =&gt; parseInt(value, 10));
</code></pre>
<h3><code>==</code> 和 <code>===</code> 区别</h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness">JavaScript 中的相等性判断 MDN</a></p>
<p>简而言之，在比较两件事情时，双等号将执行类型转换; 三等号将进行相同的比较，而不进行类型转换 (如果类型不同, 只是总会返回 false );</p>
<p>三个等号 <code>===</code> 表示严格相等，也就是说类型和值都必须相同。两个等号 <code>==</code> 会使其中一边的类型进行强制转换，使等号两边的类型都相等后再对数值进行比较。</p>
<ul>
<li>尽量使用全等操作符。因为其没有隐式转换，这样结果会比较容易预测、计算也会比较快</li>
<li>除了等于操作符，还可以使用 <code>Object.is</code> 进行同值比较。 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is</a> 与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality"><code>==</code></a> 运算<em>不同。</em> <code>==</code> 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换 (这种行为的结果会将 <code>&quot;&quot; == false</code> 判断为 <code>true</code>), 而 <code>Object.is</code>不会强制转换两边的值。 具体可以看MDN</li>
</ul>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>==</th>
<th>===</th>
<th><a href="http://Object.is">Object.is</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>undefined</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>&quot;foo&quot;</td>
<td>&quot;foo&quot;</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>{ foo: &quot;bar&quot; }</td>
<td>x</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>+0</td>
<td>-0</td>
<td>true</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>0</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>&quot;&quot;</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>&quot;&quot;</td>
<td>0</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>&quot;0&quot;</td>
<td>0</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>&quot;17&quot;</td>
<td>17</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>[1,2]</td>
<td>&quot;1,2&quot;</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>new String(&quot;foo&quot;)</td>
<td>&quot;foo&quot;</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>undefined</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>undefined</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>{ foo: &quot;bar&quot; }</td>
<td>{ foo: &quot;bar&quot; }</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>new String(&quot;foo&quot;)</td>
<td>new String(&quot;foo&quot;)</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>0</td>
<td>null</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>0</td>
<td>NaN</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>&quot;foo&quot;</td>
<td>NaN</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>NaN</td>
<td>NaN</td>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
</tbody>
</table>
<h3>x++ ++x</h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a></p>
<p>优先级 ++.. 17 ..++ 18 从右到左进行计算</p>
<h3><code>Promise</code> 状态</h3>
<p><code>Promise</code> 对象用于表示一个异步操作的最终状态（完成或失败）及其返回值。他有以下几种状态：</p>
<ul>
<li>pending：初始状态，完成或失败状态的前一个状态</li>
<li>fulfilled：操作成功完成</li>
<li>rejected：操作失败</li>
</ul>
<p>pending 状态的 Promise 对象会触发 fulfilled/rejected 状态，在其状态处理方法中可以传入参数/失败信息。当操作成功完成时，Promise 对象的 <code>then</code> 方法就会被调用；否则就会触发 <code>catch</code>。</p>
<h3>什么是回调？</h3>
<ul>
<li>回调函数作为实参传入另一个函数内，当某种事件被触发或某些任务被完成时会被调用，通常用于异步编程。</li>
<li>可以使用 <code>Promise</code>、Async/Await 等解决多重回调（callback hell）带来的问题</li>
</ul>
<h3>对比两个对象</h3>
<ul>
<li>严格相等运算符 <code>===</code></li>
<li>宽松相等运算符 <code>==</code></li>
<li><code>Object.is()</code> 函数</li>
<li>Lodash isEqual</li>
</ul>
<h3>跨域</h3>
<p>浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。</p>
<ul>
<li>JSONP</li>
<li>CORS</li>
<li>Document.domain
<ul>
<li><a href="https://blog.csdn.net/huzhenv5/article/details/104884760">https://blog.csdn.net/huzhenv5/article/details/104884760</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></li>
</ul>
</li>
<li>postMessage</li>
<li>Nginx</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000022398875">https://segmentfault.com/a/1190000022398875</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/159060398">https://zhuanlan.zhihu.com/p/159060398</a></p>
<p>平时开发CORS就已经解决问题并且够用了</p>
<h3>Service worker</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API</a></p>
<p><a href="https://developers.google.com/web/tools/workbox">https://developers.google.com/web/tools/workbox</a></p>
<pre><code class="language-javascript">if ('serviceWorker' in navigator) {
  navigator.serviceWorker.getRegistrations().then((registrations) =&gt; {
    for (const registration of registrations) {
      console.info('[pwa] [workbox] Unregistering service worker:', registration)
      registration.unregister()
    }
  })
}

if ('caches' in window) {
  caches.keys()
    .then((keys) =&gt; {
      if (keys.length) {
        console.info('[pwa] [workbox] Cleaning cache for:', keys.join(', '))
        for (const key of keys) {
          caches.delete(key)
        }
      }
    })
}
</code></pre>
<p>workbox</p>
<h3>前端缓存</h3>
<p><a href="https://github.com/xiaotiandada/blog/issues/67">https://github.com/xiaotiandada/blog/issues/67</a> 正在写...</p>
<h3>CORS 是什么？</h3>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享使用额外的 HTTP 头来告诉浏览器，此站点已被授权可以访问来自服务器指定的不同域的资源。从 <code>http://mydomain.com</code> Web 应用程序中使用 Ajax 请求 <code>http://yourdomain.com</code> 资源就是一个跨域请求的例子。</p>
<p>出于安全考虑，浏览器会阻止 JavaScript 发起的 HTTP 跨源请求。 <code>XMLHttpRequest</code> 和 <code>fetch</code> 遵循了同源策略，这意味着使用这些 API 的 Web 应用程序只能从访问同域中的 HTTP 资源。想要通过这些 API 跨域访问资源就需要让跨域的域名被正确的包含在 CORS 头中。</p>
<ul>
<li>跨域时需在请求头中加上 <code>Origin</code>。这样服务器接受到请求后会根据 <code>Origin</code> 检测结果在返回头中加入 <code>Access-Control-</code> 开头的字段。</li>
<li>非简单请求的 CORS，会在正式请求之前，增加一次 HTTP 预检请求去询问服务器该域名是否在白名单之中，以及可以使用哪些 HTTP 动作和头信息字段。只有符合要求后，浏览器才会发出正式的 <code>XMLHttpRequest</code> 请求，否则就抛出异常。</li>
<li>CORS 行为并不是一个错误，他是保护用户安全的一种机制。</li>
<li>CORS 可以阻止用户不小心访问的恶意网站去请求一个合法网站的站点资源，这样用户在合法站点的个人数据不仅会被获取，而且还可能进行一些无中生有的操作。</li>
<li>JSONP 不仅支持跨域请求，而且还支持更多的浏览器。但他只支持 <code>GET</code> 请求。</li>
</ul>
<h3><code>0.1 + 0.2 === 0.3</code> 的计算结果是什么？</h3>
<p>他的计算结果为 <code>false</code>，因为 JavaScript 中的 Math 遵循 IEEE 754 标准使用了 64 位的浮点数。简言之：计算机使用二进制来存储小数，而大部分小数转换成二进制后都是无限循环的值，因此需要进行取舍，这样一来在进行十进制计算时就会导致精度丢失。</p>
<pre><code>0.1 + 0.2 // 0.30000000000000004 
</code></pre>
<p>可以 放大倍数或者使用工具库解决问题 比如 bignumber.js</p>
<h3>osi模型</h3>
<p>七层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<p>tcp ucp属于传输层；</p>
<p>http 属于应用层</p>
<h3>数组方法 <code>map()</code> 和 <code>forEach()</code> 有什么区别？</h3>
<p>这两种方法都是对数组中的元素进行迭代。<code>map()</code> 通过每个元素的回调函数将其映射到新的元素上，最终返回一个新的数组。<code>forEach()</code> 虽然也为每一个元素准备了回调函数，但却不返回新的数组。</p>
<ul>
<li>需要迭代一个数组，使其本身发生变化且不需要返回一个新数组时，可以使用 <code>forEach()</code></li>
<li><code>map()</code> 保持原有数组不变的正确选择</li>
<li><code>map()</code> 运行的较快，且返回的新数组可以让你继续使用 <code>map()</code>、<code>filter()</code>、<code>reduce()</code> 等方法</li>
</ul>
<h3>变量提升</h3>
<pre><code class="language-javascript">var foo = 1
var foobar = () =&gt; {
  console.log(foo)
  var foo = 2
}
foobar()
</code></pre>
<p>由于变量提升（Hoisting），局部变量 <code>foo</code> 将会在调用 <code>console.log</code> 方法之前进行声明。也就是说，作为参数传递给 <code>console.log()</code> 的局部变量 <code>foo</code> 替代了在函数外部声明的全局变量。但是变量初始化（赋值）并不会被提升，因此输出为 <code>undefined</code>，而不是 <code>2</code>。</p>
<ul>
<li>JavaScript 只会将声明提升，初始化并不会被提升</li>
<li>提升指变量和函数声明在编译阶段被放入内存中，在代码中的位置并不会变动</li>
<li>ES6 中的 <code>let</code>、<code>const</code> 不存在提升</li>
</ul>
<pre><code class="language-javascript">const foobar = () =&gt; {
    console.log(foo)
    let foo = 2
}
foobar()  // Uncaught ReferenceError: foo is not defined
</code></pre>
<ul>
<li>函数提升  函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖</li>
</ul>
<pre><code class="language-javascript">function hoistFunction() {
    foo(); // output: I am hoisted

    function foo() {
        console.log('I am hoisted');
    }
}

hoistFunction();

function hoistFunction() {
    function foo() {
        console.log(1);
    }

    foo(); // output: 2

    function foo() {
        console.log(2);
    }
}

hoistFunction();

var foo = 1
var foobar = () =&gt; {
  console.log(foo)
  
  function foo() {
    console.log(1)
  }
  
  var foo = 2
}

foobar()
// function foo() {
  // window.runnerWindow.proxyConsole.log(1)
// }

</code></pre>
<h3>立即执行匿名函数的原因是什么？</h3>
<p>围绕文件中的上下文创建一个闭包环境，为这个文件创建私有的命名空间。可以避免不同的 JavaScript 模块和库在命名上产生冲突。函数被立即调用，就可以将函数的返回值赋给命名空间（库名）。</p>
<pre><code class="language-javascript">const myLibrary = (function() {
})()
myLibrary
</code></pre>
<ul>
<li>立即执行的匿名函数除了提供私有命名空间外，还提供了数据隐藏、封装、多实例等面向对象编程的特性。如：</li>
</ul>
<pre><code class="language-javascript">var makeCounter = function() {};
var Counter1 = makeCounter();
var Counter2 = makeCounter();
</code></pre>
<ul>
<li>以前很多流行的库（如：jQuery）都使用过该技术，但随着 JavaScript 版本的更新，都逐渐被 <code>import</code>，<code>class</code> 取而代之了。</li>
</ul>
<h3>词法作用域和动态作用域的区别？</h3>
<p>词法作用域指的是使用函数位置来确定变量值。于此相对的是动态作用域，他使用函数调用的位置来确定变量值。</p>
<ul>
<li>词法作用语也被成为静态作用域。</li>
<li>在闭包中，JavaScript 依旧遵循词法作用域。</li>
<li>大多数语言都使用词法范围，因为这样的源代码更加容易理解。</li>
<li>JavaScript 实际上没有动态作用域，但 <code>this</code> 机制却和动态作用域类似：关注点都在于函数是如何被调用的。</li>
<li>下列代码中，使用词法作用域将输出 <code>2</code>，动态作用域将输出 <code>3</code>：</li>
</ul>
<pre><code class="language-javascript">function foo() {
	console.log( a ); // 2
}
function bar() {
	var a = 3;
	foo();
}
var a = 2;
bar();
</code></pre>
<h3><code>null</code> 和 <code>undefined</code> 有什么区别？</h3>
<p>在 JavaScript 中有两个值表示无 <code>undefined</code> 和 <code>null</code>。根本的区别在于 <code>null</code> 是显式的，而 <code>undefined</code> 是隐式的。当一个属性不存在或一个变量没有被赋值时，他们的值为 <code>undefined</code>。把 <code>null</code> 赋给一个变量时，就显式的表明这个变量“无值”。实际上，当明确知道没有对象或不应该有值时就使用 <code>null</code>，否则就使用 <code>undefined</code>。</p>
<ul>
<li><code>typeof</code> 结果不同</li>
</ul>
<pre><code class="language-javascript">typeof undefined // &quot;undefined&quot;
typeof null // &quot;object&quot;，尽管返回 `object`，但他依旧是一个原始值，这是 JavaScript 在实现上的一个 bug。
typeof NaN // &quot;number&quot;
</code></pre>
<ul>
<li><a href="https://link.ld246.com/forward?goto=https%3A%2F%2Fhacpai.com%2Farticle%2F1546570870626%3Fr%3DVanessa">等于操作符 <code>==</code> 和 <code>===</code> 有什么区别</a></li>
</ul>
<pre><code class="language-javascript">undefined == null // true
undefined === null // false
</code></pre>
<p>JavaScript 的设计者 Brendan Eich 认为表示“空值”的不应该是一个对象且 <code>null</code> 在计算时会自动转换为 0，很不容易发现错误。因此 <code>undefined</code> 就诞生了。</p>
<p><code>null</code> 常用于以下场景：</p>
<ul>
<li>
<p>作为函数的参数，表示该函数的参数不是对象。</p>
</li>
<li>
<p>作为对象原型链的终点。</p>
</li>
</ul>
<p><code>undefined</code> 常用于以下场景：</p>
<ul>
<li>
<p>变量被声明了，但没有赋值时，就等于 undefined。</p>
</li>
<li>
<p>调用函数时，应该提供的参数没有提供，该参数等于 undefined。</p>
</li>
<li>
<p>对象没有赋值的属性，该属性的值为 undefined。</p>
</li>
<li>
<p>函数没有返回值时，默认返回 undefined。</p>
</li>
</ul>
<h3>arguments</h3>
<p>参数是函数定义时的变量名，而 arguments 的值是函数调用时赋予的。</p>
<pre><code class="language-javascript">function myFunction(parameter1, parameter2) {
  console.log(arguments[0]) // &quot;argument1&quot;
}
myFunction(&quot;argument1&quot;, &quot;argument2&quot;) 
</code></pre>
<ul>
<li><code>arguments</code> 是一个类似数组的对象</li>
<li><code>arguments</code> 对象是函数中都可用的局部变量。</li>
<li>可以使用 <code>Array.from()</code> 或扩展运算符将参数转换为真实数组，如：</li>
</ul>
<pre><code class="language-javascript">var args = Array.from(arguments);
var args = [...arguments];

function foo(...args) {
  console.log(args)
}

foo(1, 2, 3)
</code></pre>
<h3>列举几种创建对象的方法</h3>
<h4>对象字面量</h4>
<p>通常用于存储一次性数据。</p>
<pre><code>const person = {
  name: &quot;John&quot;,
  age: 50,
}
console.log(person.age) 
</code></pre>
<h4>构造函数</h4>
<p>通常用于为一个对象创建多个实例的场景，每个实例都不会受到该对象的其他实例的影响，他们有自己独立的数据。<code>new</code> 关键字必须位于构造函数之前，否则下例中的 <code>name</code> 和 <code>age</code> 将会挂载到 <code>window</code> 上。</p>
<pre><code class="language-javascript">function Person(name, age) {
  this.name = name
  this.age = age
}
Person.prototype.birthday = function() {
  this.age++
}
const person1 = new Person(&quot;John&quot;, 50)
const person2 = new Person(&quot;Sally&quot;, 20)
person1.birthday()
console.log(person1.name, person1.age) // John 51
person2.birthday()
console.log(person2.name, person2.age) // Sally 21
</code></pre>
<h4>工厂模式</h4>
<p>和构造函数类似，都可以创造一个新的实例，但是他可以通过闭包存储私有数据。在函数调用或 <code>this</code> 关键字之前不需要使用 <code>new</code> 操作。工厂模式不使用原型链模式，他将所有属性和方法都做为自己的属性。</p>
<pre><code class="language-javascript">const createPerson = (name, age) =&gt; {
  const birthday = () =&gt; person.age++
  const person = { name, age, birthday }
  return person
}
const person = createPerson(&quot;John&quot;, 50)
person.birthday() 
console.log(person.age) // 51
</code></pre>
<h4><code>Object.create()</code></h4>
<p>设置新创建的对象的原型。<code>Object.create()</code> 的第二个参数可以提供新对象自身定义的可枚举属性。</p>
<pre><code class="language-javascript">const personProto = {
  birthday() {
    this.age++
  }
}
const person = Object.create(personProto, {
  age: {
    value: 50,
    writable: true,
    enumerable: true
  },
 name: {
    value: 'John',
    writable: true,
    enumerable: true
  }
})
person.birthday() 
console.log(person.age, person.name) // 51 &quot;John&quot;
</code></pre>
<ul>
<li>原型链相关的方法可以让一个对象从其他对象中继承属性和方法。</li>
</ul>
<h3>JavaScript 通过值还是引用传递？</h3>
<p>JavaScript 是通过值进行传递的。然而对于对象而言，值是对象的引用。</p>
<ul>
<li>在值传递中，传递给函数的参数是函数被调用时所传实参的拷贝。</li>
<li>在引用传递中，传递给函数的是他的实际参数的隐式引用而不是实参的拷贝</li>
</ul>
<h3>原型继承和经典继承有什么区别？</h3>
<p>在原型继承中，对象实例直接从其他对象继承。通常使用工厂模式或 <code>Object.create()</code> 来创建对象实例。</p>
<p>在经典继承中，对象实例从类中继承他们的属性和函数。通常使用构造函数和 <code>new</code> 关键字来创建对象实例。</p>
<ul>
<li>代码中原型链过长时，应将其分解，以避免出现性能问题。</li>
<li>原生原型<strong>不应该</strong>被扩展，除非为了与新的 JavaScript 特性兼容。</li>
<li>在 ES6 中引入的 <code>class</code> 关键字只是语法糖，他仍然是基于原型的。</li>
<li>在编写复杂的继承代码之前，必须深入理解原型继承的模型。</li>
</ul>
<h3>原始值和引用值的比较</h3>
<p>以下代码将输入什么？</p>
<pre><code class="language-javascript">const a = [1, 2, 3]
const b = [1, 2, 3]
const c = &quot;1,2,3&quot;

console.log(a == c) // true
console.log(a == b) // false
</code></pre>
<p>第一个 <code>console.log</code> 输出为 <code>true</code>，因为 JavaScript 编译器在两个等号时会执行类型转换，a 将进行 <code>a.toString()</code> 转换为 &quot;1,2,3&quot;，所以 a 和 c 相等。</p>
<p>第二个 <code>console.log</code> 输出为 <code>false</code>，因为 a 和 b 是数组对象，对象是通过引用来进行比较的。a 和 b 可以看做 <code>new Array(1, 2, 3)</code>，都是新开辟出来的地址，所以引用肯定是不同的。如下通过引用的代码片断，将会输出 <code>true</code>：</p>
<pre><code class="language-javascript">let d = [1, 2, 3]
let e = d
e.push(4)
console.log(d === e)
</code></pre>
<ul>
<li>JavaScript 在执行计算时会对类型进行自动转换</li>
<li><code>undefined</code>，<code>null</code> ，<code>boolean</code> ，<code>string</code> 和 <code>number</code> 这五类原始类型是通过值进行比较</li>
</ul>
<h3>ASI (automatic semicolon insertion) - 自动插入分号</h3>
<p>执行以下函数将输入什么？</p>
<pre><code class="language-javascript">function greet() {
  return
  {
    message: &quot;hello&quot;
  }
}
</code></pre>
<p>执行 <code>greet()</code> 将输出 <code>undefined</code>。因为 JavaScript 的 ASI ( automatic semicolon insertion )，即自动插入分号会使编译器在语法分析时在 <code>return</code> 关键字后放一个分号，所以在不产生错误的情况下，他将输出 <code>undefined</code>。</p>
<ul>
<li>由于 ASI，通常都使用换行来省略分号 以 <code>var</code>、<code>let</code>、<code>const</code>、<code>import</code>、<code>export</code> 开头的声明语句、表达式语句、debugger<code>、</code>continue<code>、</code>break<code>、</code>return<code>、</code>throw` 等语句</li>
</ul>
<h3>JavaScript 是否需要分号？</h3>
<p>有时候是不需要的，有时候是需要的。 JavaScript 自动插入分号机制，解释器会在大多数语句后自动添加分号。大多数情况下是不需要分号 但是在某些情况下需要分号</p>
<pre><code class="language-javascript">const a = 3
;[1, 2, 3].map(n =&gt; n * 2) 
</code></pre>
<pre><code class="language-javascript">const a = 3
;(function() {
  // ...
})() 
</code></pre>
<p>Error 大部分编辑器会给出明显的报错提示</p>
<pre><code class="language-javascript">VM89097:2 Uncaught ReferenceError: Cannot access 'a' before initialization at &lt;anonymous&gt;:2:8
VM89160:2 Uncaught TypeError: 3 is not a function
</code></pre>
<ul>
<li>根据团队的规范来 如果需要则可以加 不需要则可以不加 通常可以配置eslint来解决这个规范问题</li>
</ul>
<h3>同步和异步代码有什么区别？</h3>
<p>同步意味着每一个操作必须等待前一个操作完成后才能执行。
异步意味着操作不需要等待其他操作完成后才开始执行。</p>
<ul>
<li>JavaScript 中的同步任务是指在主线程上排队执行的任务，只有前一个任务执行完成后才能执行后一个任务；异步任务是指进入任务队列（task queue）而非主线程的任务，只有当任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程中进行执行。</li>
<li>JavaScript 的并发模型是基于 “event loop”。</li>
<li>像 <code>alert</code> 这样的方法回阻塞主线程，以致用户关闭他后才能继续进行后续的操作。</li>
<li>Web Worker 虽然允许 JavaScript 创建多个线程，但子线程完全受主线程控制，且不能操作 DOM。</li>
</ul>
<h3>JavaScript 中的短路计算是什么？</h3>
<p>由于逻辑表达式的运算顺序是从左到右，并且他可以提前结束。使用这一规则便可进行短路计算。</p>
<pre><code class="language-javascript">true || false
</code></pre>
<p>在逻辑运算过程中如果有一个表达式执行抛出异常，程序也不会受到影响，如：</p>
<pre><code class="language-javascript">true || nonexistentFunction()
false &amp;&amp; nonexistentFunction() 
</code></pre>
<p>由于从左到右的执行顺序，我们可以进行多个操作，如：</p>
<pre><code class="language-javascript">true || nonexistentFunction() || window.nothing.wouldThrowError
true || window.nothing.wouldThrowError
true 
</code></pre>
<p>一个常用的场景是设置默认值。如果第一个对象是假值，将会使用第二个对象的值。如：</p>
<pre><code class="language-javascript">const options = {}
const setting = options.setting || &quot;default&quot;
console.log(setting) // default
</code></pre>
<p>另一个常用的场景是当对象为真值时，去执行该对象的相关操作，如：</p>
<pre><code class="language-javascript">addEventListener(&quot;click&quot;, e =&gt; {
  if (e.target.closest(&quot;button&quot;)) {
    handleButtonClick(e)
  }
})
// 以上代码片断等同于以下使用短路计算的代码片断
addEventListener(
  &quot;click&quot;,
  e =&gt; e.target.closest(&quot;button&quot;) &amp;&amp; handleButtonClick(e)
) 
</code></pre>
<p>在上面的示例中，如果 e.target 不存在或他里面不包含和 “button” 相匹配的元素，后面的函数将不会被执行。这是因为第一个对象如果是假值，那么第二个对象就不会被运行。</p>
<h3>什么是闭包？</h3>
<p>一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。<a href="https://link.ld246.com/forward?goto=https%3A%2F%2Fhacpai.com%2Farticle%2F1549635108016%23toc_h4_2">https://link.ld246.com/forward?goto=https%3A%2F%2Fhacpai.com%2Farticle%2F1549635108016%23toc_h4_2</a>)</p>
<pre><code class="language-javascript">function init() {
    var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量
    function displayName() { // displayName() 是内部函数，一个闭包
        alert(name); // 使用了父函数中声明的变量
    }
    displayName();
}
init();
</code></pre>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">MDN</a></p>
<h3>什么是函数式编程？</h3>
<p>函数式编程是一种编程范式，他使用<strong>纯函数</strong>来构建声明方式以避免状态的共享、数据的易变及一些副作用。函数式编程的核心是：同一个函数中只要输入相同，其返回值就必然相等，且不会产生任何副作用。</p>
<ul>
<li>与使用命令式或面向对象编程的代码相比，函数式编程的代码更加简洁、清晰、可预测及易于测试。</li>
<li><code>String.prototype.toUpperCase</code>、<code>Array.prototype.map</code>、<code>Function.prototype.bind</code> 都是 JavaScript 中纯函数的例子，其非纯函数的例子有：<code>Date.now</code>、<code>Math.random</code> 等</li>
</ul>
<h3>命令式编程和声明式编程有什么区别？</h3>
<p>这两种编程可以简单的概括为：</p>
<ul>
<li>命令式编程：<strong>如何</strong>命令计算机完成</li>
<li>声明式编程： 我要完成<strong>什么</strong></li>
</ul>
<h4>命令式编程</h4>
<pre><code>const numbers = [1, 2, 3, 4, 5]
const numbersDoubled = []
for (let i = 0; i &lt; numbers.length; i++) {
  numbersDoubled[i] = numbers[i] * 2
} 
</code></pre>
<p>我们手动循环遍历数组中的元素，然后将每个元素乘以 2 后赋给另外一个数组。</p>
<h4>声明式编程</h4>
<pre><code>const numbers = [1, 2, 3, 4, 5]
const numbersDoubled = numbers.map(n =&gt; n * 2) 
</code></pre>
<p>我们声明一个新的数组，让其中的每一个元素为原有数组中每一个元素的 2 倍。</p>
<h3>Memoization 是什么？</h3>
<p>Memoization 是用来缓存函数调用的输出结果，以便减少后续再次调用时的运算，进而加快运算速度的一种优化技术。Memoization 在再次调用有相同输入的同一函数时将直接返回缓存的该函数的输出结果，但第一次的计算当然是必不可少的。</p>
<pre><code>const memoize = fn =&gt; {
  const cache = new Map()
  return value =&gt; {
    const cachedResult = cache.get(value)
    if (cachedResult !== undefined) return cachedResult
    const result = fn(value)
    cache.set(value, result)
    return result
  }
} 
</code></pre>
<h4>Lodash</h4>
<pre><code class="language-javascript">var object = { 'a': 1, 'b': 2 };
var other = { 'c': 3, 'd': 4 };
 
var values = _.memoize(_.values);
values(object);
// =&gt; [1, 2]
 
values(other);
// =&gt; [3, 4]
 
object.a = 2;
values(object);
// =&gt; [1, 2]
 
// 修改结果缓存。
values.cache.set(object, ['a', 'b']);
values(object);
// =&gt; ['a', 'b']
 
// 替换 `_.memoize.Cache`。
_.memoize.Cache = WeakMap;
</code></pre>
<h3>对比 Mutable 和 Immutable 及 Mutating 和 Non-Mutating</h3>
<ul>
<li>Mutable：对象主题可以被修改</li>
<li>Immutable：对象一旦被创建就不能被修改</li>
<li>Mutating：修改对象主题的方法</li>
<li>Non-Mutating：不会使原始对象发生变化的修改方法</li>
</ul>
<p>在 JavaScript 中，对象是可被修改的，但原始值却是不能被修改的。这意味着可以通过执行某些操作来修改对象的原始引用，但对原始值执行任何操作都不能修改他的初始值。
所有的 <code>String.prototype</code> 方法都不能对初始值产生任何影响，他们都只会返回一个新的字符串。相比而言，<code>Array.prototype</code> 的某些方法也不会修改初始数组的引用，只会产生一个新的数组，但是某些方法却能产生变化。</p>
<pre><code>const myString = &quot;hello!&quot;
// 返回一个新数组，并不会修改初始值
myString.replace(&quot;!&quot;, &quot;&quot;) // &quot;hello&quot;

const originalArray = [1, 2, 3]
// 原始数组被修改
originalArray.push(4) // [1, 2, 3, 4]
// 返回一个新数组，不会修改原始数组
originalArray.concat(4) // [1, 2, 3, 4, 4]
</code></pre>
<ul>
<li>数组中 Mutating 的方法如：<code>copyWithin</code>、<code>fill</code>、<code>pop</code>、<code>push</code>、<code>reverse</code>、<code>shift</code>、<code>sort</code>、<code>splice</code>、<code>unshift</code></li>
<li>数组中 Non-Mutating 的方法如: <code>map</code>、<code>slice</code>、<code>concat</code>、<code>filter</code></li>
<li><a href="https://github.com/immutable-js/immutable-js">https://github.com/immutable-js/immutable-js</a></li>
</ul>
<h3>JavaScript 中唯一自己不等于自己的值是谁？</h3>
<p><code>NaN</code> (Not-a-Number) 无论使用什么比较运算符进行比较时，他是唯一不等于自身的值。<code>NaN</code> 通常是没有意义的数学计算的结果，因此两个 <code>NaN</code> 值被认为相等是没有意义的。</p>
<ul>
<li>简单的实现 isNaN：</li>
</ul>
<pre><code class="language-javascript">const isNotNumber = x =&gt; x !== x
</code></pre>
<ul>
<li><code>isNaN()</code> 和 <code>Number.isNaN()</code> 的区别如下：</li>
</ul>
<pre><code class="language-javascript">isNaN(NaN); // true
isNaN('A String'); // true
isNaN(undefined); // true
isNaN({}); // true
Number.isNaN(NaN); // true
Number.isNaN('A String'); // false
Number.isNaN(undefined); // false
Number.isNaN({}); // false
</code></pre>
<ul>
<li>可以使用 <code>Object.is</code>判断</li>
</ul>
<pre><code class="language-javascript">Object.is(NaN, NaN) // true
</code></pre>
<h3>复合函数</h3>
<p>在<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6">数学</a>中，<strong>复合函数</strong>，又称作<strong>合成函数</strong>（英语：function composition）是指<a href="https://zh.wikipedia.org/wiki/%E9%80%90%E7%82%B9">逐点</a>地把一个<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>作用于另一个函数的结果，所得到的第三个函数。例如，函数 <em>f</em> : <em>X</em> → <em>Y</em> 和 <em>g</em> : <em>Y</em> → <em>Z</em> 可以复合，得到从 <em>X</em> 中的 <em>x</em> 映射到 <em>Z</em> 中 <em>g</em>(<em>f</em>(<em>x</em>)) 的函数。直观来说，如果 <em>z</em> 是 <em>y</em> 的函数，<em>y</em> 是 <em>x</em> 的函数，那么 <em>z</em> 是 <em>x</em> 的函数。得到的复合函数记作 <em>g</em> ∘ <em>f</em> : <em>X</em> → <em>Z</em>，定义为对 <em>X</em> 中的所有 <em>x</em>，(<em>g</em> ∘ <em>f</em> )(<em>x</em>) = <em>g</em>(<em>f</em>(<em>x</em>))。[<a href="https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0#cite_note-1">note 1]</a> 直观地说，复合两个函数是把两个函数链接在一起的过程，内函数的输出就是外函数的输入。<a href="https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0">wiki</a></p>
<pre><code class="language-javascript">compose(...fn) {
  if (fn.length === 0) {
    return arg =&gt; arg
  }

  if (fn.length === 1) {
    return fn[0]
  }

  return fn.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
},
</code></pre>
<h3>什么是纯函数？</h3>
<ul>
<li>给定相同的输入，返回输出结果必须相同</li>
<li>在作用域之外不能改变其他数据或提供给函数的数据。</li>
</ul>
<p>纯函数在满足以上两个条件时，允许在自身内部对自己的变量进行改变。</p>
<h4>纯函数</h4>
<pre><code>const a = (x, y) =&gt; x + y
const b = (arr, value) =&gt; arr.concat(value)
const c = arr =&gt; [...arr].sort((a, b) =&gt; a - b) 
</code></pre>
<h4>非纯函数</h4>
<pre><code>const a = (x, y) =&gt; x + y + Math.random()
const b = (arr, value) =&gt; (arr.push(value), arr)
const c = arr =&gt; arr.sort((a, b) =&gt; a - b) 
</code></pre>
<h3>解释递归及其使用场景</h3>
<p>函数重复调用自身直到满足某个基本条件时。需要条件来打断循环，否则会不停的调用自身</p>
<p><a href="https://blog.csdn.net/Creabine/article/details/79027419">https://blog.csdn.net/Creabine/article/details/79027419</a></p>
<pre><code class="language-javascript">function factorial(n) {
  if(n === 1){
    return n
  }
  return n * factorial(n-1)
}
console.log(factorial(5))
</code></pre>
<h3>静态方法和实例方法的区别</h3>
<ul>
<li>静态方法属于一个类，他不能在实例上使用。</li>
<li>实例方法属于类的原型，他继承 自该类的所有实例并可以在实例上使用。</li>
</ul>
<pre><code>Array.isArray // 数组的静态方法
Array.prototype.push // 数组的实例方法
</code></pre>
<p>如果 <code>Array.isArray</code> 方法做为数组的一个实例方法将没有任何意义，因为当他可以正常运行时，我们已经知道这个他是一个数组了。</p>
<p>实例方法在技术上可以当作静态方法使用，只是实例方法提供了更简洁的语法：</p>
<pre><code>const arr = [1, 2, 3]
arr.push(4)
Array.push(arr, 4) 
</code></pre>
<ul>
<li>使用 ES2015 的类语法创建一个静态方法和实例方法</li>
</ul>
<pre><code>class Foo {
    bar() {
        console.log('instance method')
    }

    static baz() {
        console.log('static method')
    }
}
Foo.baz() // static method
const f = new Foo()
f.bar() // instance method
</code></pre>
<h3>use strict 的作用</h3>
<p>开头包含 'use strict' 可以启用严格模式，该模式强制开启了更为严格的 JavaScript 代码解析和错误处理。他被认为是一种很好的实践，为开发者提供了以下便捷之处：</p>
<ul>
<li>通过抛出错误来消除了一些原有的静默错误，让调试更加容易。</li>
<li>修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。</li>
<li>提高 JavaScript 的安全性，如私有变量的保护等。</li>
<li>简化 <code>eval()</code> 和 <code>arguments</code>，如 <code>arguments</code> 不会随参数的变化而变化等。</li>
</ul>
<pre><code>&quot;use strict&quot;
function f(a){
  a = 42;
  return [a, arguments[0]];
}
var pair = f(17);
console.log(pair) // [42, 17]，非严格模式下输出为 [42, 42]
</code></pre>
<ul>
<li>防止意外的全局变量。</li>
</ul>
<pre><code>&quot;use strict&quot;
mistypedVaraible = 17; // Uncaught ReferenceError: mistypedVaraible is not defined
</code></pre>
<ul>
<li>禁止重新定义。</li>
</ul>
<pre><code>&quot;use strict&quot;;
undefined = 5; // Uncaught TypeError: Cannot assign to read only property 'undefined' of object '#&lt;Window&gt;'
</code></pre>
<ul>
<li>使用 <code>delete</code> 时会抛出错误</li>
</ul>
<pre><code>&quot;use strict&quot;;
delete mistypedVariable; // Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.
</code></pre>
<ul>
<li>强制消除 <code>this</code> 的引用，默认为 <code>undefined</code>。</li>
</ul>
<pre><code>&quot;use strict&quot;;
name = &quot;atatus&quot;;
function testFunction() {
    console.log(this.name);
}
// 非严格模式下输出 atatus
testFunction(); // Uncaught TypeError: Cannot read property 'name' of undefined 
</code></pre>
<ul>
<li>禁用了在 ECMAScript 未来版本中可能会定义的一些语法。</li>
</ul>
<h3>内存泄漏</h3>
<p>定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题 js中可能出现的内存泄漏情况 结果：变慢，崩溃，延迟大等 原因：</p>
<ol>
<li>全局变量</li>
<li>dom清空时，还存在引用</li>
<li>ie中使用闭包</li>
<li>定时器未清理</li>
<li>子元素存在引起的内存泄露</li>
</ol>
<p>避免策略：</p>
<ol>
<li>减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；</li>
<li>注意程序逻辑，避免“死循环”之类的 ；</li>
<li>避免创建过多的对象  原则：不用了的东西要及时归还。</li>
<li>减少层级过多的引用</li>
</ol>
<h3>React, Vue, Angular、UI 库或框架的目的是什么？</h3>
<ul>
<li>组件化 功能复用 减少冗余代码和提高维护性</li>
<li>数据驱动视图 只需要关注数据变化即可</li>
<li>虚拟Dom vue 和react 都使用的虚拟dom性能提升</li>
<li>提供生命周期、插槽、条件语句、Hooks等一些列功能 提高开发效率</li>
</ul>
<h3>虚拟 DOM 是什么，库或者框架中为什么要使用他？</h3>
<p>虚拟 DOM（VDOM）是使用 JavaScript 普通对象来描述真实 DOM 的展现方式</p>
<pre><code class="language-javascript">document.createDocumentFragment()
</code></pre>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment">MDN</a></p>
<ul>
<li>库或者框架中使用虚拟 DOM 主要为了提高性能。</li>
<li>使用虚拟 DOM 可以减少对底层的 DOM 操作</li>
<li>虚拟 DOM 可以将同一时间内多个状态的变化累计计算出最终状态，以便对 DOM 只执行一次更新。</li>
<li>Vue.js 中 Virtual DOM 是借鉴了一个开源库 <a href="https://github.com/snabbdom/snabbdom">snabbdom</a> 的实现，然后加入了一些 Vue.js 特色的东西</li>
</ul>
<h2>React</h2>
<h3>什么是内联条件表达式？</h3>
<p>使用 <code>if</code> 语句或三元表达式 还可以在 JSX 中嵌入表达式</p>
<pre><code>(
    &lt;div&gt;
      &lt;h1&gt;Hello! {isLoggedIn ? 'Vanessa' : 'User'}&lt;/h1&gt;
      {unreadMessages.length &gt; 0 &amp;&amp;
        &lt;h2&gt;
          You have {unreadMessages.length} unread messages.
        &lt;/h2&gt;
      }
    &lt;/div&gt;
 )
</code></pre>
<h3>React 中什么是有状态的组件？</h3>
<p>有状态的组件是一种其行为取决于该状态的组件。这意味着在一个组件的两个实例中，即使给这两个实例赋予相同的属性，他们也不一定会有相同的渲染输出，这和纯函数组件不同。</p>
<pre><code>// Stateful class component
class App extends Component {
  constructor(props) {
    super(props)
    this.state = { count: 0 }
  }
  render() {
    // ...
  }
}

// Stateful function component
function App() {
  const [count, setCount] = useState(0)
  return // ...
} 
</code></pre>
<ul>
<li>有状态的组件包含了他们内部所依赖的状态。</li>
<li>有状态的组件是类组件或者是使用了 useState hook 的函数组件。</li>
<li>有状态的组件在构造器中或使用 <code>useState()</code></li>
</ul>
<pre><code>import {useState} from 'react';

function Counter(){

 let [number,setCount ] = useState(0);

   return (
       &lt;div&gt;
        &lt;h1&gt;{number}&lt;/h1&gt;
        &lt;button onClick={()=&gt;setCount(number+1)} &gt;Increment&lt;/button&gt;
        &lt;button onClick={()=&gt;setCount(number-1)} &gt;Deccrement&lt;/button&gt;
       &lt;/div&gt;
   )
}
</code></pre>
<h3>什么是无状态组件</h3>
<p>无状态组件是本身行为不需要依赖他自身状态的组件。无状态组件可以是函数组件或者类组件。无状态函数组件更易于维护和测试，因为他们可以保证在相同的属性下有相同的输出。当不需要使用生命周期钩子时，应该首先使用无状态函数组件。</p>
<ul>
<li>无状态组件不依赖他自身的状态。</li>
<li>无状态组件可以是类组件或者函数组件。</li>
<li>无状态函数组件可以完全避免使用 <code>this</code> 关键字。</li>
<li>无状态组件有更高的性能。</li>
</ul>
<pre><code>const Component (props)=&gt;(
    &lt;div&gt;
        {props.text}
        ...
    &lt;/div&gt;
)
</code></pre>
<h3>key 是什么？列表中使用时有什么优点？</h3>
<p>Keys 是一种特殊的字符串属性，可以帮助 React 识别哪些项已经被修改过、添加过或删除过。当渲染数组元素时就需要使用 key 来给每一个元素进行固定的标识。每一个元素的 key 必须是唯一的（例如，数据中的 IDs 或最终排序后的索引）。</p>
<pre><code>const todoItems = todos.map(todo =&gt; &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;) 
</code></pre>
<ul>
<li>Keys 为集合中的元素提供来固定的标识，从而帮助 React 来识别增删改。</li>
<li>如果项目的顺序可能会发生变化，则不建议使用索引作为 keys，因为这可能会对性能产生负面影响，并且可能会导致组件的状态出现问题。</li>
<li>如果将列表项单独提出来做为一个组件，在列表组件中 li 标签上的 key 需要提升到 ListItem 组件上</li>
</ul>
<pre><code>function ListItem(props) {
  // Correct! There is no need to specify the key here:
  return &lt;li&gt;{props.value}&lt;/li&gt;;
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =&gt;
    // Correct! Key should be specified inside the array.
    &lt;ListItem key={number.toString()}
              value={number} /&gt;

  );
  return (
    &lt;ul&gt;
      {listItems}
    &lt;/ul&gt;
  );
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  &lt;NumberList numbers={numbers} /&gt;,
  document.getElementById('root')
);
</code></pre>
<h3>React 生命周期的方法有哪些？</h3>
<p><a href="https://zh-hans.reactjs.org/docs/react-component.html#the-component-lifecycle">https://zh-hans.reactjs.org/docs/react-component.html#the-component-lifecycle</a></p>
<p><a href="https://medium.com/coding-hot-pot/react-lifecycle-%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F-a48683ae3922">https://medium.com/coding-hot-pot/react-lifecycle-生命週期-a48683ae3922</a></p>
<h4>组件的生命周期</h4>
<h5>挂载</h5>
<p>当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</p>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#constructor"><strong><code>constructor()</code></strong></a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops"><code>static getDerivedStateFromProps()</code></a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#render"><strong><code>render()</code></strong></a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidmount"><strong><code>componentDidMount()</code></strong></a></li>
</ul>
<blockquote>
<p>注意:</p>
<p>下述生命周期方法即将过时，在新代码中应该<a href="https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html">避免使用它们</a>：</p>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#unsafe_componentwillmount"><code>UNSAFE_componentWillMount()</code></a></li>
</ul>
</blockquote>
<h5>更新</h5>
<p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops"><code>static getDerivedStateFromProps()</code></a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#render"><strong><code>render()</code></strong></a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate"><code>getSnapshotBeforeUpdate()</code></a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate"><strong><code>componentDidUpdate()</code></strong></a></li>
</ul>
<blockquote>
<p>注意:</p>
<p>下述方法即将过时，在新代码中应该<a href="https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html">避免使用它们</a>：</p>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#unsafe_componentwillupdate"><code>UNSAFE_componentWillUpdate()</code></a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#unsafe_componentwillreceiveprops"><code>UNSAFE_componentWillReceiveProps()</code></a></li>
</ul>
</blockquote>
<h5>卸载</h5>
<p>当组件从 DOM 中移除时会调用如下方法：</p>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#componentwillunmount"><strong><code>componentWillUnmount()</code></strong></a></li>
</ul>
<h5>错误处理</h5>
<p>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：</p>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromerror"><code>static getDerivedStateFromError()</code></a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidcatch"><code>componentDidCatch()</code></a></li>
</ul>
<h3>Ref</h3>
<p><a href="https://zh-hant.reactjs.org/docs/refs-and-the-dom.html">https://zh-hant.reactjs.org/docs/refs-and-the-dom.html</a></p>
<p><a href="https://juejin.cn/post/6844903749211652104">https://juejin.cn/post/6844903749211652104</a></p>
<p><strong>React.createRef</strong></p>
<pre><code class="language-react">class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return &lt;div ref={this.myRef} /&gt;;
  }
}
</code></pre>
<p><strong>Callback ref</strong></p>
<pre><code class="language-react">class Test extends React.Component {
  componentDidMount(){
    console.log(this.second);
  // &lt;input value=&quot;second&quot;&gt;
  }
  render() {
    return &lt;input value=&quot;second&quot; ref={(input) =&gt; {this.second = input }} /&gt;
  }
}
</code></pre>
<h3>children</h3>
<p><code>children</code> 是传递给组件属性对象的一部分，他提供了组合组件的能力</p>
<pre><code class="language-react">function GenericBox({ children }: any) {
  console.log('children', children)
  return &lt;div className=&quot;container&quot;&gt;{children}&lt;/div&gt;
}

&lt;GenericBox&gt;
  &lt;span&gt;Hello&lt;/span&gt; &lt;span&gt;World&lt;/span&gt;
&lt;/GenericBox&gt;
</code></pre>
<p><img src="https://user-images.githubusercontent.com/24250627/108600318-844e1180-73d1-11eb-90fa-61affe7941a9.png" alt="image"></p>
<h3>Context</h3>
<p><a href="https://reactjs.org/docs/context.html">https://reactjs.org/docs/context.html</a></p>
<ul>
<li>
<p>Context 提供了一种通过 React 组件树传递数据的方法，他不需要手动传递属性。</p>
</li>
<li>
<p>使用 Context，可以跨越组件进行数据的传递</p>
</li>
</ul>
<h3>React 错误边界</h3>
<p>错误边界是 React 捕获子组件树中所有 JavaScript 错误的组件，他可以记录这些错误，并将错误显示在 UI 上来替代组件树的崩溃。</p>
<p>定义 <code>componentDidCatch</code> 那么他将成为错误边界</p>
<p><a href="https://reactjs.org/docs/error-boundaries.html">https://reactjs.org/docs/error-boundaries.html</a></p>
<pre><code class="language-react">class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false }
  }

  componentDidCatch(error, info) {
    // Display fallback UI
    this.setState({ hasError: true })
    // You can also log the error to an error reporting service
    logErrorToMyService(error, info)
  }

  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;
    }
    return this.props.children
  }
}
</code></pre>
<ul>
<li><code>componentDidCatch</code>：用于错误边界。他允许组件去捕获其子组件树中任意位置的 JavaScript 错误，打印错误，并使用 UI 展现错误信息。</li>
<li>当任何一个子组件在渲染过程中、在一个生命周期的方法中或在构造函数中发生错误时 <code>static getDerivedStateFromError()</code>，<code>componentDidCatch()</code> 将会被调用。</li>
</ul>
<pre><code class="language-react">class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI.
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // You can also log the error to an error reporting service
    logErrorToMyService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;
    }

    return this.props.children; 
  }
}
</code></pre>
<h3>Fragments</h3>
<p><a href="https://reactjs.org/docs/fragments.html">https://reactjs.org/docs/fragments.html</a></p>
<pre><code class="language-react">render() {
  return (
    &lt;React.Fragment&gt;
      &lt;ChildA /&gt;
      &lt;ChildB /&gt;
      &lt;ChildC /&gt;
    &lt;/React.Fragment&gt;
  );
}
</code></pre>
<ul>
<li>可以使用 <code>&lt;&gt;&lt;/&gt;</code> 代替 <code>&lt;React.Fragment/&gt;</code>。<code>&lt;&gt;&lt;/&gt;</code> 只是一个语法糖。</li>
<li><code>&lt;&gt;&lt;/&gt;</code> 语法不能接受键值或属性，以下情况只能使用 <code>&lt;React.Fragment/&gt;</code> (没有实际测试过)</li>
</ul>
<pre><code>function Glossary(props) {
  return (
    &lt;dl&gt;
      {props.items.map(item =&gt; (
        // 没有`key`，将会触发一个key警告
        &lt;React.Fragment key={item.id}&gt;
          &lt;dt&gt;{item.term}&lt;/dt&gt;
          &lt;dd&gt;{item.description}&lt;/dd&gt;
        &lt;/React.Fragment&gt;
      ))}
    &lt;/dl&gt;
  );
}
</code></pre>
<ul>
<li><code>key</code> 是唯一可以传递给 <code>Fragment</code> 的属性 （没有实际测试过）</li>
</ul>
<h3>高阶组件</h3>
<p><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">https://zh-hans.reactjs.org/docs/higher-order-components.html</a></p>
<blockquote>
<p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p>
<p>具体而言，<strong>高阶组件是参数为组件，返回值为新组件的函数。</strong></p>
<pre><code>const EnhancedComponent = higherOrderComponent(WrappedComponent);
</code></pre>
<p>组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p>
</blockquote>
<h3>Portals</h3>
<p><a href="https://reactjs.org/docs/portals.html">https://reactjs.org/docs/portals.html</a></p>
<pre><code class="language-react">render() {
  // React does *not* create a new div. It renders the children into `domNode`.
  // `domNode` is any valid DOM node, regardless of its location in the DOM.
  return ReactDOM.createPortal(
    this.props.children,
    domNode
  );
}
</code></pre>
<h3>React 中如何使用 prop</h3>
<p><code>isRequired</code>。</p>
<p>为组件定义的 <code>propTypes</code>：</p>
<pre><code class="language-react">import PropTypes from &quot;prop-types&quot;

class User extends React.Component {
  static propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number.isRequired
  }

  render() {
    return (
      &lt;h1&gt;Welcome, {this.props.name}&lt;/h1&gt;
      &lt;h2&gt;Age, {this.props.age}
    )
  }
} 
</code></pre>
<ul>
<li>使用 <code>propTypes</code> 并不是必需的，但这是一个非常棒的减少错误的实践</li>
<li>使用 <code>PropTypes.element</code> 可以指定只传递一个子代</li>
<li><code>defaultProps</code> 用来确保 <code>this.props</code> 在父组件没有指定的情况下有一个初始值</li>
<li>类型检查发生在 <code>defaultProps</code> 赋值之后，所以类型检查也会应用在 <code>defaultProps</code> 上。</li>
</ul>
<h3>VUE</h3>
<h4>Vue 组件间通信六种方式</h4>
<p><a href="https://juejin.cn/post/6844903897258000398#heading-2">https://juejin.cn/post/6844903897258000398#heading-2</a></p>
<h4>Virtual Dom</h4>
<p><a href="https://juejin.cn/post/6844903615652610055">https://juejin.cn/post/6844903615652610055</a> TODO: 还没看...</p>
<h2>Node</h2>
<h3>NodeJS 回调的错误处理方式及其优点</h3>
<p>NodeJS 通常使用回调模式，如果在执行期间发生错误，会把错误作为回调的第一个参数传递到回调函数中：</p>
<pre><code>fs.readFile(filePath, function(err, data) {
  if (err) {
    // 错误处理，return 可以让执行停止，这非常重要
    return console.log(err)
  }
  // 使用数据对象
  console.log(data)
}) 
</code></pre>
<p>优点包括如下：</p>
<ul>
<li>如果不需要引用数据，则无需对数据进行处理</li>
<li>API 保持高度的一致性可以带来更多的便捷</li>
<li>能够轻松适配回调模式，从而实现更易于维护的代码</li>
</ul>
<p>从下面的示例中可以看出，如果没有错误，回调函数中的第一个参数将为 null。但是如果出现错误的话，将会创建一个 Error 对象作为回调函数中的唯一参数。回调函数让用户更加容易的知道是否有错误发生。</p>
<p>这种实践也称为 Node.js 的错误约定，这种回调函数的实现称为错误优先回调。</p>
<pre><code>var isTrue = function(value, callback) {
  if (value === true) {
    callback(null, &quot;Value was true.&quot;)
  } else {
    callback(new Error(&quot;Value is not true!&quot;))
  }
}

var callback = function(error, data) {
  if (error) {
    console.log(error)
    return
  }
  console.log(data)
}

isTrue(false, callback) // Error: Value is not true!
isTrue(true, callback) // Value was true.
</code></pre>
<h3>REST</h3>
<p>REST（REpresentational State Transfer）是一种用于网络架构的软件设计模式。RESTful Web 应用程序使用和资源相关的信息方式对数据进行公开。</p>
<p>通常，这个概念用于管理 Web 应用程序中的状态。对于大多数应用程序来说，他们对数据都有读取，创建，更新和销毁这四个共同的操作。数据模块化后形成单独的表，如 <code>posts</code>,<code>users</code>,<code>comments</code>，RESTful API 通过以下方式对数据进行访问：</p>
<ul>
<li>资源标识符。使用端点或 URL 来表示资源。</li>
<li>服务器对资源的操作应该使用 HTTP 方法或动词。常见的 HTTP 方法有 GET，POST，PUT 和 DELETE。</li>
</ul>
<p>以下示例为包含 <code>posts</code> 资源的 HTTP 方法及 URL：</p>
<ul>
<li>读取：<code>/posts/</code>=&gt; GET</li>
<li>创建：<code>/posts/new</code>=&gt; POST</li>
<li>更新：<code>/posts/:id</code>=&gt; PUT</li>
<li>删除：<code>/posts/:id</code>=&gt; DELETE</li>
<li>除 RESTful 以外，GraphQL 也很受欢迎。</li>
</ul>
<h3>如何避免地狱回调？</h3>
<p>如何避免以下这种地狱回调的情况？</p>
<pre><code>getData(function(a) {
  getMoreData(a, function(b) {
    getMoreData(b, function(c) {
      getMoreData(c, function(d) {
        getMoreData(d, function(e) {
          // ...
        })
      })
    })
  })
})
</code></pre>
<p>使用最佳的 <code>async/await</code> 进行替换</p>
<pre><code>async function asyncAwaitVersion() {
  const a = await getData()
  const b = await getMoreData(a)
  const c = await getMoreData(b)
  const d = await getMoreData(c)
  const e = await getMoreData(d)
  // ...
} 
</code></pre>
<h3>Node.js 中的事件循环？</h3>
<p><a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/">https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/</a></p>
<p><a href="https://juejin.cn/post/6844903999506923528">https://juejin.cn/post/6844903999506923528</a></p>
<p>事件循环允许 Node.js 执行非阻塞的 I/O 操作，尽管 JavaScript 是单线程的。</p>
<p>事件循环处理所有的异步回调。回调在一个循环中进行排队，当代码运行时，队列中的每一个回调在接收到响应时将逐个进行运行。当 Node.js 启动时会初始化事件循环，每一个事件循环都有如下顺序的六个循环阶段：</p>
<pre><code>┌───────────────────────────┐
┌─&gt;│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │&lt;─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
</code></pre>
<h2>前端模块化：CommonJS,AMD,CMD,ES6</h2>
<p><a href="https://juejin.cn/post/6844903576309858318">https://juejin.cn/post/6844903576309858318</a></p>
<h3>ES6 模块与 CommonJS 模块的差异</h3>
<h3>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h3>
<ul>
<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>
<li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>
</ul>
<h3>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h3>
<ul>
<li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>
<li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>
</ul>
<p>CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<h2>从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</h2>
<p><a href="https://juejin.cn/post/6844903553795014663">https://juejin.cn/post/6844903553795014663</a></p>
<h2>浏览器相关</h2>
<h3>cookie、localSrorage、session、indexDB</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
<th>indexDB</th>
<th>Web SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>周期</td>
<td>可以服务器生成，可以前端设置。可以设置过期时间</td>
<td>长期</td>
<td>会话周期</td>
<td>长期</td>
<td>长期</td>
</tr>
<tr>
<td>数据存储大小</td>
<td>4K</td>
<td>5M</td>
<td>5M</td>
<td></td>
<td></td>
</tr>
<tr>
<td>与服务端通信</td>
<td>服务端设置的Cookie会携带在 header</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>对于 <code>cookie</code>，我们还需要注意安全性。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</td>
</tr>
<tr>
<td>http-only</td>
<td>不能通过 JS 访问 Cookie，减少 XSS 攻击</td>
</tr>
<tr>
<td>secure</td>
<td>只能在协议为 HTTPS 的请求中携带</td>
</tr>
<tr>
<td>same-site</td>
<td>规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</td>
</tr>
</tbody>
</table>
<h3>怎么判断页面是否加载完成？</h3>
<p>**<code>DOMContentLoaded</code>**当初始HTML文档已完全加载并解析，而无需等待样式表，图像和子帧完成加载时，将触发此事件。</p>
<pre><code class="language-javascript">window.addEventListener('DOMContentLoaded', (event) =&gt; {
    console.log('DOM fully loaded and parsed');
});
</code></pre>
<p>**<code>load</code>**加载整个页面（包括所有相关资源，例如样式表和图像）时，将触发该事件。这与相反<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/DOMContentLoaded_event"><code>DOMContentLoaded</code></a>，后者在页面DOM被加载后立即触发，而无需等待资源完成加载。</p>
<pre><code class="language-javascript">window.addEventListener('load', (event) =&gt; {
  console.log('page is fully loaded');
});
</code></pre>
<h3>重绘（Repaint）和回流（Reflow）</h3>
<p>重绘：不改变布局</p>
<p>回流：需要改变布局</p>
<p>回流一定发生重绘 重绘不一定发生回流</p>
<ul>
<li>
<p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24</a></p>
</li>
<li>
<p><a href="https://juejin.cn/post/6844903682455109640#heading-45%EF%BC%88%E5%BE%88%E5%A4%9A%E4%BA%BA%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%98%AF%EF%BC%8C%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%E5%85%B6%E5%AE%9E%E5%92%8C">https://juejin.cn/post/6844903682455109640#heading-45（很多人不知道的是，重绘和回流其实和</a> Event loop 有关。</p>
</li>
</ul>
<p>TODO: 这里没理解...）</p>
<ul>
<li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model">https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model</a></li>
</ul>
<h4>减少重绘和回流</h4>
<ul>
<li>
<p>使用 <code>translate</code> 替代 <code>top</code></p>
</li>
<li>
<p>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</p>
</li>
<li>
<p>合并多次对DOM和样式的修改，然后一次处理</p>
</li>
<li>
<p>对于复杂动画效果,使用绝对定位让其脱离文档流</p>
</li>
<li>
<p>css3硬件加速（GPU加速）</p>
</li>
<li>
<p>避免触发同步布局事件： 访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。</p>
<pre><code class="language-javascript">function initP() {
    for (let i = 0; i &lt; paragraphs.length; i++) {
        paragraphs[i].style.width = box.offsetWidth + 'px';
    }
}
const width = box.offsetWidth;
function initP() {
    for (let i = 0; i &lt; paragraphs.length; i++) {
        paragraphs[i].style.width = width + 'px';
    }
}
</code></pre>
</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000017329980">https://segmentfault.com/a/1190000017329980</a></p>
<h3>图片优化</h3>
<h5>计算图片大小</h5>
<p>对于一张 100 * 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000 * 1 * 4 / 1024）。</p>
<p>但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。</p>
<p>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</p>
<ul>
<li>减少像素点</li>
<li>减少每个像素点能够显示的颜色</li>
</ul>
<h5>图片加载优化</h5>
<ol>
<li>
<p>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</p>
</li>
<li>
<p>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。还可以返回webp等图片</p>
</li>
<li>
<p>小图使用 base64 格式</p>
</li>
<li>
<p>将多个图标文件整合到一张图片中（雪碧图）</p>
</li>
<li>
<p>选择正确的图片格式：</p>
<ul>
<li>
<p>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好。安卓、PC支持都还不错，IOS移动端需要注意</p>
<pre><code class="language-javascript">// 判断兼容性
const isSupportWebp = process.browser ? !![].map &amp;&amp; document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') === 0 : false
</code></pre>
</li>
<li>
<p>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</p>
</li>
<li>
<p>照片使用 JPEG</p>
</li>
</ul>
</li>
</ol>
<h3>其他文件优化</h3>
<p>CSS 文件放在 <code>head</code> 中</p>
<p>服务端开启文件压缩功能 GZIP</p>
<p>将 <code>script</code> 标签放在 <code>body</code> 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 <code>script</code> 标签放在任意位置然后加上 <code>defer</code> ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 <code>async</code> ，表示加载和渲染后续文档元素的过程将和  JS 文件的加载与执行并行无序进行。</p>
<p>执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 <code>Webworker</code>。<code>Webworker</code> 可以让我们另开一个线程执行脚本而不影响渲染。</p>
<h4>CDN</h4>
<p>静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。</p>
<h4>使用 Webpack 优化项目</h4>
<ul>
<li>对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩</li>
<li>使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码</li>
<li>优化图片，对于小图可以使用 base64 的方式写入文件中</li>
<li>按照路由拆分代码，实现按需加载</li>
<li>给打包出来的文件名添加哈希，实现浏览器缓存文件</li>
</ul>
<h3>Webpack</h3>
<p>...</p>
<h2>网络</h2>
<h3>TCP 3次握手</h3>
<p>在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。</p>
<p>起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后遍进入 LISTEN 状态，此时开始等待客户端发送数据。</p>
<p><strong>第一次握手</strong></p>
<p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入  SYN-SENT 状态，<code>x</code> 表示客户端的数据通信初始序号。</p>
<p><strong>第二次握手</strong></p>
<p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p>
<p><strong>第三次握手</strong></p>
<p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p>
<p>PS：第三次握手可以包含数据，通过 TCP 快速打开（TFO）技术。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同 cookie，下次握手时发出 cookie 达到减少 RTT 的目的。</p>
<p><strong>你是否有疑惑明明两次握手就可以建立起连接，为什么还需要第三次应答？</strong></p>
<p>因为这是为了防止失效的连接请求报文段被服务端接收，从而产生错误。</p>
<p>可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。</p>
<p>PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p>
<h3>TCP 拥塞控制</h3>
<p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p>
<p>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。</p>
<h3>慢开始算法</h3>
<p>慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。</p>
<p>慢开始算法步骤具体如下</p>
<ol>
<li>连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）</li>
<li>每过一个 RTT 就将窗口大小乘二</li>
<li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li>
</ol>
<h3>拥塞避免算法</h3>
<p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p>
<p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：</p>
<ul>
<li>将阈值设为当前拥塞窗口的一半</li>
<li>将拥塞窗口设为 1 MSS</li>
<li>启动拥塞避免算法</li>
</ul>
<h3>快速重传</h3>
<p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：</p>
<p><strong>TCP Taho 实现如下</strong></p>
<ul>
<li>将阈值设为当前拥塞窗口的一半</li>
<li>将拥塞窗口设为 1 MSS</li>
<li>重新开始慢开始算法</li>
</ul>
<p><strong>TCP Reno 实现如下</strong></p>
<ul>
<li>拥塞窗口减半</li>
<li>将阈值设为当前拥塞窗口</li>
<li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）</li>
<li>使用拥塞避免算法</li>
</ul>
<h3>TCP New Ren 改进后的快恢复</h3>
<p><strong>TCP New Reno</strong> 算法改进了之前 <strong>TCP Reno</strong> 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</p>
<p>在 <strong>TCP New Reno</strong> 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</p>
<p>假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p>
<h3>HTTPS 握手</h3>
<p>HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。</p>
<h3>TLS</h3>
<p>TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。</p>
<p>在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。</p>
<p><strong>对称加密</strong>：</p>
<p>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p>
<p><strong>非对称加密</strong>：</p>
<p>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p>
<h4>从输入 URL 到页面加载全过程</h4>
<ol>
<li>首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来</li>
<li>接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</li>
<li>TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据</li>
<li>数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件</li>
<li>首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错</li>
<li>浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件</li>
<li>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 <code>script</code> 标签的话，会判断是否存在 <code>async</code> 或者 <code>defer</code> ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。</li>
<li>初始的 HTML 被完全加载和解析后会触发 <code>DOMContentLoaded</code> 事件</li>
<li>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</li>
<li>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了</li>
</ol>
<h4>HTTP 常用返回码</h4>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</a></p>
<p>HTTP响应状态代码指示特定的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">HTTP</a>请求是否已成功完成。响应分为五类：</p>
<ol>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#information_responses">信息反馈</a>（<code>100</code>– <code>199</code>）</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#successful_responses">成功的回应</a>（<code>200</code>– <code>299</code>）</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages">重定向</a>（<code>300</code>– <code>399</code>）</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses">客户端错误</a>（<code>400</code>– <code>499</code>）</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses">服务器错误</a>（<code>500</code>– <code>599</code>）</li>
</ol>
<p><strong>2XX 成功</strong></p>
<ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>
<li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li>
<li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li>
<li>206 Partial Content，进行范围请求</li>
</ul>
<p><strong>3XX 重定向</strong></p>
<ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li>
<li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li>
<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>
<li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li>
</ul>
<p><strong>4XX 客户端错误</strong></p>
<ul>
<li>400 bad request，请求报文存在语法错误</li>
<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>
<li>404 not found，表示在服务器上没有找到请求的资源</li>
<li>429 Too Many Requests 用户在给定的时间内发送了太多请求（“速率限制”）</li>
</ul>
<p><strong>5XX 服务器错误</strong></p>
<ul>
<li>500 internal sever error，表示服务器端在执行请求时发生了错误</li>
<li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li>
<li>502 Bad Gateway 此错误响应意味着服务器在充当网关以获取处理请求所需的响应的同时，获得了无效的响应。</li>
<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li>
</ul>
<h3>数据结构算法</h3>
<p><a href="https://github.com/xiaotiandada/blog/issues/48">https://github.com/xiaotiandada/blog/issues/48</a></p>
<h2>Security</h2>
<h3>什么是跨站点脚本攻击（XSS）</h3>
<p>XSS 是指客户端代码注入，攻击者将带有恶意脚本的代码注入到合法的网站或 web 应用程序中。这通常发生在应用程序对用户的输入不进行验证时，这样恶意代码就会轻松的注入到动态的 HTML 内容中。</p>
<ul>
<li>
<p>可以使用工具库过滤xss <a href="https://www.npmjs.com/package/xss">https://www.npmjs.com/package/xss</a></p>
</li>
<li>
<p>恶意的脚本有权限访问到通常用于存储会话令牌的 cookie。</p>
</li>
<li>
<p>当页面中注入的恶意脚本执行时，就可以对该页面中的 DOM 进行任意操作。这样一来，攻击者不仅可以插入与网站相似的内容或操作，也可以窜改网站上原有的实际内容。该脚本还可以使用 AJAX 发送带有任意内容的 HTTP 请求到任意一台服务器上。</p>
</li>
<li>
<p>在客户端，可以使用 <code>textContent</code> 来代替 <code>innerHTML</code> 以阻止浏览器运行通过 HTML 解析器执行内部脚本得到的字符串。</p>
</li>
<li>
<p>在服务器端，转义 HTML 标签可以阻止浏览器将用户的输入解析为真实的 HTML，这样也不会执行脚本。但如果你想真实的展现用户的输入，那就只能对会被注入的标签、标签属性进行过滤。</p>
</li>
</ul>
<h2>其他</h2>
<h3>什么是大 O 符号？</h3>
<p>大 O 符号在计算机科学中 用来描述算法的时间复杂度。执行速度快且复杂性低的算法视为优秀的算法。
算法的运行次数并不是每次都相同，大部分取决于所提供的数据。在某些情况下，他们执行的很快，但某些情况下，他们却执行的很慢（哪怕他们的数据是一样多）。</p>
<p>以下示例中，我们假设基准时间为：1element = 1ms</p>
<h4>O(1)</h4>
<pre><code>arr[arr.length - 1] // 1000 elements = 1ms
</code></pre>
<p>时间复杂度恒定。无论数组有多少元素，理论（不考虑机器性能、当前环境等因素）上他执行的时间总量是相同的。</p>
<h4>O(N)</h4>
<pre><code>arr.filter(fn) // 1000 elements = 1000ms
</code></pre>
<p>线性时间复杂度。执行时间将随数组元素个数呈线性增加。如果数组拥有 1000 个元素且函数运行需要花费 1ms，那么 7000 个元素需要执行 7ms。这是因为函数在返回结果之前必须迭代数组中的所有元素。</p>
<h4>O([1, N])</h4>
<pre><code>arr.some(fn) // 1000 elements = 1ms &lt;= x &lt;= 1000ms
</code></pre>
<p>执行时间的长短取决于提供给函数的数据，他需要的时间可能很短，也可能很长。最好的情况是 O(1)，最坏的情况是 O(N)。</p>
<h4>O(NlogN)</h4>
<pre><code>arr.sort(fn) // 1000 elements ~= 10000ms
</code></pre>
<p>浏览器通常为 <code>sort()</code> 方法使用快速排序算法进行实现，快速排序的平均时间复杂度为 O(NlogN)。这对于数据很多的集合非常有效。</p>
<h4>O(N^2)</h4>
<pre><code>for (let i = 0; i &lt; arr.length; i++) {
  for (let j = 0; j &lt; arr.length; j++) {
    // 1000 elements = 1000000ms
  }
} 
</code></pre>
<p>执行时间随元素数量呈二次方增长。这通常是由于使用了嵌套循环。</p>
<h4>O(N!)</h4>
<pre><code>// 1000 elements = Infinity ms
const permutations = arr =&gt; {
  if (arr.length &lt;= 2) return arr.length === 2 ? [arr, [arr[1], arr[0]]] : arr
  return arr.reduce(
    (acc, item, i) =&gt;
      acc.concat(
        permutations([...arr.slice(0, i), ...arr.slice(i + 1)]).map(val =&gt; [
          item,
          ...val
        ])
      ),
    []
  )
} 
</code></pre>
<p>数组中即使只增加一个元素，也会使执行时间增加的非常长。</p>
<ul>
<li>嵌套循环的执行时间会随着元素的增长呈指数增长，因此遇到嵌套循环需考虑到性能问题。</li>
</ul>
<p>...</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[HTTP 缓存  Cache-Control]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/67</link>
            <guid>https://github.com/xiaotiandada/blog/issues/67</guid>
            <pubDate>Tue, 07 Jun 2022 12:48:10 GMT</pubDate>
            <description><![CDATA[<h2>Cache-Control</h2>
<ul>
<li><a href="http://www.xiaoxiaoguo.cn/protocol/http-Cache-Control.html#%E5%89%8D%E8%A8%80">浅谈http中的Cache-Control</a></li>
<li><a href="https://vercel.com/docs/project-configuration#project-configuration/headers">vercel headers</a></li>
<li><a href="https://segmentfault.com/a/1190000021560126">网站 cache control 最佳实践</a></li>
<li><a href="https://juejin.cn/post/6844903683046506504">缓存头Cache-Control的含义和使用</a></li>
<li><a href="https://www.cnblogs.com/kevingrace/p/10459429.html">Nginx下关于缓存控制字段cache-control的配置说明 - 运维小结</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching">HTTP 缓存</a></li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[tribute 实现@(艾特)功能]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/66</link>
            <guid>https://github.com/xiaotiandada/blog/issues/66</guid>
            <pubDate>Fri, 22 Jan 2021 16:27:58 GMT</pubDate>
            <description><![CDATA[<p>利用 <a href="https://github.com/zurb/tribute">https://github.com/zurb/tribute</a> 实现一个前端@的功能 大概长这样。</p>
<p><img src="https://user-images.githubusercontent.com/24250627/105509577-983a2100-5d08-11eb-87e5-7990cf20dc96.png" alt="image"></p>
<p>因为前端是Vue(Nuxt)所以用了一个别人封装好的库 <a href="https://github.com/syropian/vue-tribute">https://github.com/syropian/vue-tribute</a></p>
<h2>在Nuxt里面用？</h2>
<blockquote>
<p>如果你不需要在Nuxt里面用就可以跳过</p>
</blockquote>
<pre><code class="language-javascript">// import Tribute from 'tributejs'
let Tribute

if (process.client) {
  Tribute = require('tributejs')
}

const VueTribute = {
  name: 'vue-tribute',
  props: {
    options: {
      type: Object,
      required: true
    }
  },
  watch: {
    options: {
      immediate: false,
      deep: true,
      handler() {
        if (this.tribute) {
          setTimeout(() =&gt; {
            var $el = this.$slots.default[0].elm
            this.tribute.detach($el)

            setTimeout(() =&gt; {
              $el = this.$slots.default[0].elm
              this.tribute = new Tribute(this.options)
              this.tribute.attach($el)
              $el.tributeInstance = this.tribute
            }, 0)
          }, 0)
        }
      }
    }
  },
  mounted() {
    if (process.client) {
      if (typeof Tribute === 'undefined') {
        throw new Error('[vue-tribute] cannot locate tributejs!')
      }
  
      const $el = this.$slots.default[0].elm
  
      this.tribute = new Tribute(this.options)
  
      this.tribute.attach($el)
  
      $el.tributeInstance = this.tribute
  
      $el.addEventListener('tribute-replaced', e =&gt; {
        e.target.dispatchEvent(new Event('input', { bubbles: true }))
      })
    }
  },
  beforeDestroy() {
    const $el = this.$slots.default[0].elm

    if (this.tribute) {
      this.tribute.detach($el)
    }
  },
  render(h) {
    return h(
      'div',
      {
        staticClass: 'v-tribute'
      },
      this.$slots.default
    )
  }
}
if (process.client) {
  if (typeof window !== 'undefined' &amp;&amp; window.Vue) {
    window.Vue.component(VueTribute.name, VueTribute)
  }
}

export default VueTribute
</code></pre>
<p>因为Nuxt的关系 我基于源码又做了一层封装(加了一些判断而已)。</p>
<h2>使用</h2>
<pre><code class="language-vue">&lt;client-only&gt;
      &lt;vue-tribute
        :options=&quot;tributeOptions&quot;
        @tribute-no-match=&quot;noMatchFound&quot;
        @tribute-replaced=&quot;tributeReplaced&quot;
      &gt;
        &lt;div
          id=&quot;tributeShare&quot;
          class=&quot;content-editable&quot;
          contenteditable=&quot;true&quot;
          placeholder=&quot;谈谈感想&quot;
        /&gt;
      &lt;/vue-tribute&gt;
&lt;/client-only&gt;
</code></pre>
<h2>搜索用户</h2>
<p>最主要的是这个<strong>options</strong>配置，然后 tribute 有几种输入框，具体看Demo就知道了 这里说一下怎么搜索</p>
<pre><code class="language-javascript">      tributeOptions: {
        collection: [
          {
            trigger: '@',
            values: (query, cb) =&gt; {
              console.log('query', query)
              if (!query) {
                return cb([])
              }

              return this.searchUser(query, cb)
            },
            loadingItemTemplate: '&lt;div style=&quot;padding: 16px&quot;&gt;Loading&lt;/div&gt;',
            lookup: 'key',
            fillAttr: 'key',
            selectTemplate: function (item) {
              console.log('item', item)
              return `&lt;a
                  class=&quot;tribute-mention&quot;
                  contenteditable=&quot;false&quot;
                  href=&quot;javascript:;&quot;
                  title=&quot;${item.original.value}&quot;
                  data-user=&quot;${item.original.id}&quot;&gt;@${item.original.value}&lt;/a&gt;`
            },
          },
        ],
      },

// ...

    searchUser: debounce(async function (val, cb) {
      const list = await search(params)
        return cb(list)
      } else {
        return cb([])
      }
    }, 300),
</code></pre>
<p>搜索通过 values 定义的Func来执行 <strong>query</strong> 是输入的内容 利用cb设置数据</p>
<h2>设置用户显示模版</h2>
<p>可以自定义Temp，我这里返回了一个 a Tag，默认是 span  我为了方便改成了 a。
并且设置了 data-user 自定义数据 方便后续做渲染操作。</p>
<pre><code class="language-javascript">return `&lt;a
class=&quot;tribute-mention&quot;
contenteditable=&quot;false&quot;
href=&quot;javascript:;&quot;
title=&quot;${item.original.value}&quot;
data-user=&quot;${item.original.id}&quot;&gt;@${item.original.value}&lt;/a&gt;`
</code></pre>
<h2>Xss过滤</h2>
<p>为了避免用户插入HTML等提交，这里用 <a href="https://github.com/leizongmin/js-xss">https://github.com/leizongmin/js-xss</a> 过滤，显示的时候也需要过滤一次 避免用户通过接口提交（也可以用其他的办法）</p>
<p>这里只通过a标签 因为a标签需要做用户跳转的</p>
<pre><code class="language-javascript">// 过滤分享内容
const whiteListShare = {
  a: [ 'class', 'contenteditable', 'href', 'title', 'data-user', 'target' ]
}
export const Fn = (html, whiteList = whiteListShare) =&gt; {
  return xss(html, {
    whiteList: whiteList,
    stripIgnoreTag: true,
    stripIgnoreTagBody: ['script']
  })
}
</code></pre>
<h2>渲染</h2>
<p>因为搜索用户的时候已经做了a标签处理只需要设置属性就可以</p>
<pre><code class="language-javascript">    ele.setAttribute('href', 'xxx')
</code></pre>
<h2>Emoji</h2>
<p><a href="https://github.com/jm-david/emoji-mart-vue">https://github.com/jm-david/emoji-mart-vue</a> 可以考虑用这个 选择很多</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Egg set-cookie 与 Axios   HttpOnly]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/65</link>
            <guid>https://github.com/xiaotiandada/blog/issues/65</guid>
            <pubDate>Thu, 28 Jan 2021 12:19:14 GMT</pubDate>
            <description><![CDATA[<h2>参考文章</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies</a></li>
<li><a href="https://eggjs.org/zh-cn/core/cookie-and-session.html">https://eggjs.org/zh-cn/core/cookie-and-session.html</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/157">https://github.com/mqyqingfeng/Blog/issues/157</a></li>
<li><a href="https://github.com/eggjs/egg/issues/2721">https://github.com/eggjs/egg/issues/2721</a></li>
<li><a href="https://github.com/eggjs/egg/blob/master/config/config.default.js#L57">https://github.com/eggjs/egg/blob/master/config/config.default.js#L57</a></li>
<li><a href="https://eggjs.org/en/tutorials/proxy.html#mobileAside">https://eggjs.org/en/tutorials/proxy.html#mobileAside</a></li>
</ul>
<p>代码都在这儿：<a href="https://github.com/xiaotiandada/cli-ant-temp">https://github.com/xiaotiandada/cli-ant-temp</a></p>
<h2>环境</h2>
<p>前后分离项目set-cookie</p>
<h2>Axios 配置</h2>
<pre><code class="language-javascript">const client = axios.create({
  baseURL: process.env.VUE_APP_API,
  timeout: 1000 * 30,
  headers: {
  },
  withCredentials: true,
})
</code></pre>
<p>需要设置<code>withCredentials: true</code> axios默认是发送请求的时候不会带上cookie的</p>
<h2>Egg 配置</h2>
<p>利用 cors 跨域</p>
<pre><code class="language-javascript">// ...
  const domainWhiteList = [ 'http://localhost:8080', 'http://127.0.0.1:8080' ];

  config.security = {
    domainWhiteList,
    csrf: {
      enable: false,
    },
  };

  config.cors = {
    origin: ctx =&gt; {
      if (domainWhiteList.includes(ctx.request.header.origin)) {
        return ctx.request.header.origin;
      }
    },
    allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH,OPTIONS',
    credentials: true,
  };
// ...
</code></pre>
<h2>Egg get</h2>
<pre><code class="language-typescript"> public async add() {
    const ctx = this.ctx;
    let count: any = ctx.cookies.get('count');
    console.log('count', count);
    console.log('token', ctx.cookies.get('access-token'));

    count = count ? Number(count) : 0;
    const countCookie: any = ++count;
    ctx.cookies.set('count', countCookie, {
      sameSite: 'none',
    });
    ctx.body = count;
 }
</code></pre>
<h2>Egg post</h2>
<pre><code class="language-typescript">  public async signIn() {
    const { ctx } = this;
    const { account, password } = ctx.request.body;
    const payload = {
      account,
      password,
    };
    const secret = 'xxx';
    const token = jwt.encode(payload, secret);
    ctx.cookies.set('access-token', token, {
      sameSite: 'none',
      maxAge: ms('7d'),
    });
    ctx.body = {
      data: token,
    };
  }
</code></pre>
<p><img src="https://user-images.githubusercontent.com/24250627/105119172-c520e500-5b0a-11eb-95bb-f4a56bb581c6.png" alt="image"></p>
<h2>问题</h2>
<p>部署到线上需要开启 <code>sameSite: 'none'</code> , sameSite 需要开启 <code>secure: true</code></p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/157">参考文章</a></p>
<pre><code class="language-javascript">      ctx.cookies.set('access-token', accessToken, {
        sameSite: 'none',
        secure: true,
        maxAge: ms('7d'),
      });
</code></pre>
<pre><code>HTTP 接口不支持 SameSite=none
如果你想加 SameSite=none 属性，那么该 Cookie 就必须同时加上 Secure 属性，表示只有在 HTTPS 协议下该 Cookie 才会被发送。
</code></pre>
<p>实际部署到线上会报错 <code>Cannot send secure cookie over unencrypted connection</code></p>
<p>解决方案</p>
<p><img src="https://user-images.githubusercontent.com/24250627/105142637-cca9b380-5b35-11eb-8747-0e29850e761f.png" alt="image"></p>
<p>应该设置Nginx等(<a href="https://caddyserver.com/">caddy</a>)可以解决问题，但是我这里是设置Egg config的 <a href="https://eggjs.org/en/tutorials/proxy.html#mobileAside">proxy</a> 解决这个问题</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[使用 MonoRepo 管理前端项目]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/64</link>
            <guid>https://github.com/xiaotiandada/blog/issues/64</guid>
            <pubDate>Tue, 19 Jan 2021 06:41:29 GMT</pubDate>
            <description><![CDATA[<p>2021-01-02 17:42:28</p>
<p>在工作中，我们可能会遇到一些项目管理方面的问题。在单个项目管理的时候，大家都知道该怎么管理。一旦涉及到多个项目管理，很多人就不一定能够管理好了。 --- 引用</p>
<h3>参考文章</h3>
<ul>
<li>
<p><a href="https://mp.weixin.qq.com/s/GzwABWH8GXYVp9X1zhz9lA">https://mp.weixin.qq.com/s/GzwABWH8GXYVp9X1zhz9lA</a></p>
</li>
<li>
<p><a href="https://classic.yarnpkg.com/en/docs/workspaces">https://classic.yarnpkg.com/en/docs/workspaces</a></p>
</li>
</ul>
<h3>Repo Demo</h3>
<ul>
<li><a href="https://github.com/xiaotiandada/monorepo">https://github.com/xiaotiandada/monorepo</a></li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[Node.js 开发简单的脚手架工具]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/63</link>
            <guid>https://github.com/xiaotiandada/blog/issues/63</guid>
            <pubDate>Fri, 22 Jan 2021 16:34:04 GMT</pubDate>
            <description><![CDATA[<p>2020-12-30 13:28:16</p>
<p>像我们熟悉的 vue-cli，react-native-cli 等脚手架，只需要输入简单的命令，即可快速帮我们生成一个初始项目。在实际工作中，我们可以定制一个属于自己的脚手架，来提高自己的工作效率。</p>
<p>为什么需要需要脚手架？</p>
<ul>
<li>减少重复性的工作，不再需要复制其他项目再删除无关代码，或者从零创建一个项目和文件。</li>
<li>根据交互动态生成项目结构和配置文件等。</li>
<li>多人协作更为方便，不需要把文件传来传去。</li>
</ul>
<!-- more -->
<blockquote>
<p><a href="https://segmentfault.com/a/1190000015222967">👆 引用</a></p>
</blockquote>
<h3>参考文章</h3>
<p><a href="https://segmentfault.com/a/1190000015222967">https://segmentfault.com/a/1190000015222967</a></p>
<p><a href="https://aotu.io/notes/2016/08/09/command-line-development/index.html">https://aotu.io/notes/2016/08/09/command-line-development/index.html</a></p>
<p>主要看了上面两篇文章，还有一些其他的文章可以参考</p>
<p><a href="https://segmentfault.com/a/1190000038669035">https://segmentfault.com/a/1190000038669035</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/31988855">https://zhuanlan.zhihu.com/p/31988855</a></p>
<h3>download-git-repo 不会写 Repo Address？</h3>
<p><a href="https://segmentfault.com/q/1010000012493731/a-1020000015334943">https://segmentfault.com/q/1010000012493731/a-1020000015334943</a></p>
<h3>结果</h3>
<p><a href="https://www.npmjs.com/package/cli-ant">https://www.npmjs.com/package/cli-ant</a></p>
<pre><code class="language-shell">npm i cli-ant -g

% cli-ant init brick
? 请输入项目描述 project
? 请输入作者名称 xiaotian
? 请选择模版 Vue
? 请选择模版 Vue2
✔ 正在下载模板...
✔ 项目创建成功
</code></pre>
<p>具体代码可以在 <a href="https://github.com/xiaotiandada/cli-ant">repo</a> 里面看 写得不好的地方多多指教！！！ ❤️</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[图片帧动画]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/62</link>
            <guid>https://github.com/xiaotiandada/blog/issues/62</guid>
            <pubDate>Tue, 19 Jan 2021 06:40:40 GMT</pubDate>
            <description><![CDATA[<p>2020-11-16 23:16:37</p>
<p>切换img图片完成帧动画效果</p>
<!-- more -->
<iframe src="https://codesandbox.io/embed/tupianzhengdonghua-kb2hh?fontsize=14&hidenavigation=1&theme=dark&view=preview"
     style="width:100%; height:200px; border:0; border-radius: 4px; overflow:hidden;"
     title="图片帧动画"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
<pre><code class="language-javascript">// 加载所有图片资源
await Promise.all(
  this.layerConfig.map(async (v) =&gt; {
    console.log(&quot;v&quot;, v);
    return Promise.all(
      v.images.map(async (i, index) =&gt; {
        const img = document.createElement(&quot;img&quot;);
        img.src = i.src;
        await new Promise((resolve) =&gt; (img.onload = resolve));
        v.images[index].img = img;
      })
    );
  })
</code></pre>
<p>利用Promise先加载完所有图片</p>
<pre><code class="language-javascript">// 初始化图层
const layers = layerConfig.map((v) =&gt; {
  const layer = document.createElement(&quot;div&quot;);
  layer.classList.add(&quot;layer&quot;);
  container.appendChild(layer);
  return layer;
});

// 切换下一帧的方法
const changeToNextFrame = (layer, images, i) =&gt; {
  setTimeout(() =&gt; {
    const next = i === images.length - 1 ? 0 : i + 1;
    layer.removeChild(layer.firstChild);
    layer.appendChild(images[next].img);
    changeToNextFrame(layer, images, next);
  }, images[i].duration);
};

// 初始化图层内图片和帧动画
layerConfig.map((v, i) =&gt; {
  const a = v.images[0].img;
  layers[i].appendChild(a);
  if (v.images.length &gt; 1 &amp;&amp; v.loopTime &gt; 0) {
    changeToNextFrame(layers[i], v.images, 0);
  }
});
</code></pre>
<ol>
<li>生成图层添加到页面</li>
<li>添加图层图片和动画</li>
<li>用SetTimeout切换图片</li>
</ol>
]]></description>
        </item>
        <item>
            <title><![CDATA[bilibili banner动画研究【一】]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/61</link>
            <guid>https://github.com/xiaotiandada/blog/issues/61</guid>
            <pubDate>Tue, 19 Jan 2021 06:40:19 GMT</pubDate>
            <description><![CDATA[<p>2020-11-16 21:52:56</p>
<p><img src="https://i.imgur.com/2BWZJjY.jpg?1" alt="动画效果"></p>
<p><a href="https://www.bilibili.com/">https://www.bilibili.com/</a> 后面可能会被更新掉</p>
<blockquote>
<p>为什么叫一？ 说不能还有别的好玩的动画学习！</p>
</blockquote>
<!-- more -->
<iframe src="https://codesandbox.io/embed/bilibili-bannner-w49d7?fontsize=14&hidenavigation=1&theme=dark&view=preview"
     style="width:100%; height:200px; border:0; border-radius: 4px; overflow:hidden;"
     title="bilibili bannner"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
<p>主要两个组件完成，代码我也是复制b站大佬的🍑 然后自己理解理解思路</p>
<h3>Banner.vue</h3>
<pre><code class="language-javascript">  computed: {
    locs() {
      return {
    		//...
        pic:
          &quot;http://i0.hdslb.com/bfs/archive/0b7eef054547750e6bfeff6f36c83e83d2a058fb.png&quot;,
        litpic:
          &quot;http://i0.hdslb.com/bfs/archive/622017dd4b0140432962d3ce0c6db99d77d2e937.png&quot;,
				//...
      };
    },
    bannerImg() {
      return (this.locs &amp;&amp; this.locs.pic).trim();
    },
    logoImg() {
      return (this.locs &amp;&amp; this.locs.litpic).trim();
    },
  },
</code></pre>
<p>返回一张静止的页面，在没有加载完成或者不支持的时候显示</p>
<pre><code class="language-javascript">// 解析数据 提前定义好的具体看代码
this.layerConfig = JSON.parse('[...]');
</code></pre>
<p>解析banner数据</p>
<pre><code class="language-javascript">// 只有在启用了动画banner的配置，且浏览器支持css filter时才加载动画banner的图片资源
this.animatedBannerSupport =
  typeof CSS !== &quot;undefined&quot; &amp;&amp;
  CSS.supports &amp;&amp;
  CSS.supports(&quot;filter: blur(1px)&quot;);
</code></pre>
<p>查看是否支持一些需要的条件</p>
<pre><code class="language-javascript">// 根据每帧时长计算循环时间
this.layerConfig.map((v) =&gt; {
  v.loopTime = v.images.reduce((p, c) =&gt; p + (c.duration || 0), 0);
});
</code></pre>
<p>统计所有Time 利用 Reduce 累计</p>
<pre><code class="language-javascript">try {
  // 加载所有图片资源
  await Promise.all(
    this.layerConfig.map(async (v) =&gt; {
      console.log(&quot;v&quot;, v);
      return Promise.all(
        v.images.map(async (i, index) =&gt; {
          const img = document.createElement(&quot;img&quot;);
          img.src = i.src;
          await new Promise((resolve) =&gt; (img.onload = resolve));
          v.images[index].img = img;
        })
      );
    })
  );
  console.log(&quot;this.layerConfig&quot;, this.layerConfig);
  // 切换为动画banner
  this.animatedBannerLoaded = true;
} catch (e) {
  console.log(&quot;load animated banner images error&quot;, e);
}
</code></pre>
<p>利用Promise加载所有图片资源，两个Promise是因为images里面也是一个数组</p>
<p>可以用这种方法提前加载图片 这样切换的时候就不会很卡顿 嗯 学习了！</p>
<h3>AnimatedBanner</h3>
<pre><code class="language-javascript">props: {
  layerConfig: {
    type: Array,
      required: true,
  },
},
</code></pre>
<p>接收父组件处理好的数组数据</p>
<pre><code class="language-javascript">const layerConfig = this.layerConfig;
if (!layerConfig.length) {
  this.$emit(&quot;error&quot;);
}

const container = this.$refs[&quot;container&quot;];
let containerHeight = container.clientHeight;
let containerWidth = container.clientWidth;
let containerScale = containerHeight / 155;

// 加载图片资源移动到组件外部， 这里只设置图片宽高
layerConfig.forEach((v) =&gt; {
  v.images.forEach((i, index) =&gt; {
    const img = v.images[index].img;
    img.dataset.height = img.height;
    img.dataset.width = img.width;
    img.height =
      img.dataset.height * containerScale * (v.initial.scale || 1);
    img.width = img.dataset.width * containerScale * (v.initial.scale || 1);
  });
});
</code></pre>
<p>如果没有调用$emit告诉父组件显示静态图片</p>
<p>获取容器和宽高缩放等属性，并且设置父组件获取图片的宽高等属性 并且根据缩放比例计算</p>
<pre><code class="language-javascript">// 初始化图层
const layers = layerConfig.map((v) =&gt; {
  const layer = document.createElement(&quot;div&quot;);
  layer.classList.add(&quot;layer&quot;);
  container.appendChild(layer);
  return layer;
});
</code></pre>
<p>初始化图层到container</p>
<pre><code class="language-javascript">// 初始状态
const iaf = () =&gt; {
  try {
    layers.map((layer, i) =&gt; {
      // console.log(&quot;layer log&quot;, i, layer);
      const v = layerConfig[i];
      const a = layer.firstChild;
      // console.log(&quot;a&quot;, a);
      let rotateStr = &quot;&quot;;
      let translateStr = &quot;&quot;;
      if (v.initial.rotate) {
        rotateStr = `rotate(${v.initial.rotate}deg)`;
      }
      if (v.initial.translate) {
        const base = v.initial.translate || [0, 0];
        translateStr = `translate(${base[0]}px, ${base[1]}px)`;
      }
      a.style.transform = `${translateStr} ${rotateStr}`;
      if (v.initial.blur) {
        a.style.filter = `blur(${Math.abs(v.initial.blur)}px)`;
      }
    });
  } catch (e) {
    console.error(e);
    this.$emit(&quot;error&quot;);
  }
};

// 切换下一帧的方法
const changeToNextFrame = (layer, images, i) =&gt; {
  setTimeout(() =&gt; {
    const next = i === images.length - 1 ? 0 : i + 1;
    layer.removeChild(layer.firstChild);
    layer.appendChild(images[next].img);
    changeToNextFrame(layer, images, next);
    requestAnimationFrame(af);
  }, images[i].duration);
};

// 初始化图层内图片和帧动画
layerConfig.map((v, i) =&gt; {
  const a = v.images[0].img;
  layers[i].appendChild(a);
  requestAnimationFrame(iaf);
  if (v.images.length &gt; 1 &amp;&amp; v.loopTime &gt; 0) {
    changeToNextFrame(layers[i], v.images, 0);
  }
});
</code></pre>
<p>初始化图层图片和一些默认样式并且开始帧动画</p>
<p>利用定时器loop toggle img 删除第一个元素然后添加下一帧图片然后再调用自己</p>
<pre><code class="language-javascript">document.addEventListener(&quot;mouseleave&quot;, this.handleMouseLeave);
window.addEventListener(&quot;mousemove&quot;, this.handleMouseMove);
window.addEventListener(&quot;resize&quot;, this.handleResize);

beforeDestroy() {
  document.removeEventListener(&quot;mouseleave&quot;, this.handleMouseLeave);
  window.removeEventListener(&quot;mousemove&quot;, this.handleMouseMove);
  window.removeEventListener(&quot;resize&quot;, this.handleResize);
},
</code></pre>
<p>监听一些事件</p>
<pre><code class="language-javascript">this.handleMouseMove = (e) =&gt; {
  const offsetY = document.documentElement.scrollTop + e.clientY;
  console.log(&quot;offsetY&quot;, offsetY, e);
  if (offsetY &lt; containerHeight) {
    if (!entered) {
      entered = true;
      enterX = e.clientX;
    }
    displace = (e.clientX - enterX) / containerWidth;
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(af);
  } else {
    if (entered) {
      entered = false;
      handleLeave();
    }
  }
};
</code></pre>
<p>鼠标经过容器执行af 先取消再继续，不在容器内调用 handleLeave</p>
<pre><code class="language-javascript">enterX = e.clientX;
displace = (e.clientX - enterX) / containerWidth;
</code></pre>
<p>这两个的含义其实我还没太理解 后续需要用 displace 参与计算 应该就是用来判断往左还是右边的</p>
<pre><code class="language-javascript">// 根据鼠标位置改变状态
const af = (t) =&gt; {
  try {
    layers.map((layer, i) =&gt; {
      const v = layerConfig[i];
      const a = layer.firstChild;
      if (!v.offset || !a) {
        return;
      }

      const baseRotate = v.initial.rotate || 0;
      const baseTranslate = v.initial.trannslate || [0, 0];
      let scaleStr = ``;
      let rotateStr = `rotate(${v.initial.rotate || 0}deg)`;
      let translateStr = `translate(${baseTranslate[0]}px, ${baseTranslate[1]}px)`;

      console.log(
        &quot;rotateStr translateStr&quot;,
        rotateStr,
        translateStr,
        v.offset
      );

      if (v.offset.scale) {
        const itp =
              v.offsetCurve &amp;&amp; v.offsetCurve.scale
        ? curveParameterToFunc(v.offsetCurve.scale)
        : (x) =&gt; x;
        const offset = v.offset.scale * itp(displace);
        scaleStr = `scale(${1 + offset})`;
      }
      if (v.offset.rotate) {
        const itp =
              v.offsetCurve &amp;&amp; v.offsetCurve.rotate
        ? curveParameterToFunc(v.offsetCurve.rotate)
        : (x) =&gt; x;
        const offset = v.offset.rotate * itp(displace);
        rotateStr = `rotate(${baseRotate + offset}deg)`;
      }
      if (v.offset.translate) {
        const itp =
              v.offsetCurve &amp;&amp; v.offsetCurve.translate
        ? curveParameterToFunc(v.offsetCurve.translate)
        : (x) =&gt; x;
        const offset = v.offset.translate.map((v) =&gt; itp(displace) * v);
        const translate = baseTranslate.map(
          (x, i) =&gt;
          (x + offset[i]) * containerScale * (v.initial.scale || 1)
        );
        translateStr = `translate(${translate[0]}px, ${translate[1]}px)`;
      }
      a.style.transform = `${scaleStr} ${translateStr} ${rotateStr}`;
      if (v.offset.blur) {
        const itp =
              v.offsetCurve &amp;&amp; v.offsetCurve.blur
        ? curveParameterToFunc(v.offsetCurve.blur)
        : (x) =&gt; x;
        const blurOffset = itp(displace) * v.offset.blur;
        a.style.filter = `blur(${Math.abs(
          (v.initial.blur || 0) + blurOffset
        )}px)`;
      }
    });
  } catch (e) {
    console.error(e);
    this.$emit(&quot;error&quot;);
  }
};
</code></pre>
<p>关键代码在这里...</p>
<ol>
<li>
<p>判断有没有元素</p>
</li>
<li>
<p>获取一些初始的style</p>
</li>
<li>
<p>然后判断有没有offset scale rotate translate blur 然后执行动画</p>
</li>
<li>
<p>判断有没有 offset curve 如果有用 cubicBezier 没有就用默认参数</p>
</li>
<li>
<p>往右边 x2 &gt; x1 / width 正数</p>
<ol>
<li>
<p>Scale 默认是 1</p>
<pre><code class="language-javascript">const offset = v.offset.scale * itp(displace);
scaleStr = `scale(${1 + offset})`;
</code></pre>
</li>
<li>
<p>Rotate 根据上面定义的默认参数然后加上新角度</p>
<pre><code class="language-javascript">const offset = v.offset.rotate * itp(displace);
rotateStr = `rotate(${baseRotate + offset}deg)`;
</code></pre>
</li>
<li>
<p>Translate 根据比例计算</p>
<pre><code class="language-javascript">const offset = v.offset.translate.map((v) =&gt; itp(displace) * v);
const translate = baseTranslate.map(
  (x, i) =&gt;
  (x + offset[i]) * containerScale * (v.initial.scale || 1)
);
translateStr = `translate(${translate[0]}px, ${translate[1]}px)`;
</code></pre>
<p>因为是个arr所以map loop，后面的 * 容器比例 * 初始化scale 应该是适配缩放的比例然后变化位置</p>
<pre><code class="language-javascript">a.style.transform = `${scaleStr} ${translateStr} ${rotateStr}`;
</code></pre>
<p>最后设置属性</p>
</li>
<li>
<p>blur 初始的blur + 变化后的blur</p>
<pre><code class="language-javascript">const blurOffset = itp(displace) * v.offset.blur;
a.style.filter = `blur(${Math.abs(
  (v.initial.blur || 0) + blurOffset
)}px)`;
</code></pre>
</li>
</ol>
</li>
</ol>
<pre><code class="language-javascript">const handleLeave = () =&gt; {
  const now = performance.now();
  const timeout = 200;
  const tempDisplace = displace;
  cancelAnimationFrame(raf);
  const leaveAF = (t) =&gt; {
    if (t - now &lt; timeout) {
      displace = tempDisplace * (1 - (t - now) / 200);
      af(t);
      requestAnimationFrame(leaveAF);
    } else {
      displace = 0;
      af(t);
    }
  };
  raf = requestAnimationFrame(leaveAF);
};
</code></pre>
<p>鼠标离开后 在200time内displace会逐渐变小或扩大 取决于正数还是负数 超过时间后会设置为 0 然后调用动画恢复默认参数</p>
<pre><code class="language-javascript">this.handleResize = () =&gt; {
  containerHeight = container.clientHeight;
  containerWidth = container.clientWidth;
  containerScale = containerHeight / 155;
  layerConfig.forEach((lc) =&gt; {
    lc.images.forEach((i) =&gt; {
      const img = i.img;
      img.height =
        img.dataset.height * containerScale * (lc.initial.scale || 1);
      img.width =
        img.dataset.width * containerScale * (lc.initial.scale || 1);
    });
  });
  cancelAnimationFrame(raf);
  raf = requestAnimationFrame((t) =&gt; {
    af(t);
  });
};
</code></pre>
<p>设置容器的样式参数然后取消动画再开始动画赋值给raf</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[JFIF图片格式上传]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/60</link>
            <guid>https://github.com/xiaotiandada/blog/issues/60</guid>
            <pubDate>Tue, 19 Jan 2021 06:40:01 GMT</pubDate>
            <description><![CDATA[<p>2020-11-13 00:01:44</p>
<p>图片存储格式之一，由<a href="https://baike.baidu.com/item/JPEG">JPEG</a>格式衍生而来，后缀为&quot;.jfif&quot;。<a href="https://baike.baidu.com/item/jfif">JFIF</a></p>
<!-- more -->
<p>了解到一种新的图片格式JFIF 但是这种图片格式上传是导致失败 <code>Invalid filename</code></p>
<p>最后解决方案时候在前端上传的时候转换文件</p>
<p>如果没有图片的话可以在这里转换 <a href="https://convertio.co/zh/">https://convertio.co/zh/</a></p>
<p>前端：React Ant</p>
<p>后端：Nodejs Egg oss</p>
<blockquote>
<p>后端代码忽略了 参考: <a href="https://github.com/eggjs/egg-oss">https://github.com/eggjs/egg-oss</a></p>
</blockquote>
<p>前端用Ant的Upload <a href="https://ant.design/components/upload-cn/">https://ant.design/components/upload-cn/</a></p>
<p>这里有篇介绍格式转换的 <a href="https://blog.csdn.net/qq_21937107/article/details/91424611">https://blog.csdn.net/qq_21937107/article/details/91424611</a></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>类型</th>
<th>默认值</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>transformFile</td>
<td>在上传之前转换文件。支持返回一个 Promise 对象</td>
<td>function(file): string...</td>
<td>-</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-typescript">function blobToFile(blob: any, fileName: string) {
  blob.lastModifiedDate = new Date();
  blob.name = fileName;
  return blob;
}

async function transformFile(file: File): Promise&lt;string | Blob | File&gt; {
  // https://blog.csdn.net/qq_21937107/article/details/91424611
  // base64 to blob then file
  console.log('file', file)
  try {
    const fileImg = await imageConversion.filetoDataURL(file)
    const blob = await imageConversion.dataURLtoFile(fileImg)

    const fileName = file.name.split('.')
    let fileType = fileName[fileName.length - 1]

    // 如果文件类型是 jfif 使用 jpg 否则使用默认
    if (fileType === 'jfif') {
      fileType = 'jpg'
    }
    const result = blobToFile(blob, `${fileName[0] || Date.now()}.${fileType}`)
    console.log('result', result)

    return result
  } catch (e) {
    console.log('e', e)
    return file
  }
}
</code></pre>
<p>利用 <a href="https://github.com/WangYuLue/image-conversion">imageConversion</a> 逻辑就是 File transform base64 to blob then file</p>
<pre><code class="language-typescript">// to base64
const fileImg = await imageConversion.filetoDataURL(file)
// to blob
const blob = await imageConversion.dataURLtoFile(fileImg)
// then file
blobToFile(blob, fileName)
</code></pre>
<p>JFIF上传成功包括WEBP IOS预览也正常</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Front-end and Ethereum interaction]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/59</link>
            <guid>https://github.com/xiaotiandada/blog/issues/59</guid>
            <pubDate>Tue, 19 Jan 2021 06:39:46 GMT</pubDate>
            <description><![CDATA[<p>留个坑…</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[ mvvm learn]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/58</link>
            <guid>https://github.com/xiaotiandada/blog/issues/58</guid>
            <pubDate>Tue, 19 Jan 2021 06:39:34 GMT</pubDate>
            <description><![CDATA[<p>2020-10-26 23:52:23</p>
<ol>
<li><a href="https://github.com/DMQ/mvvm">剖析Vue实现原理 - 如何实现双向绑定mvvm</a></li>
<li><a href="https://www.bilibili.com/video/BV1k4411C73b">最通俗易懂的MVVM原理</a></li>
<li><a href="https://github.com/xiaotiandada/mvvm">Repo</a></li>
</ol>
<!-- more -->
<h4>MVVM 模块</h4>
<p>VUE 模块主要负责所有模块的数据和初始化一些功能 比如执行编译模版、Computed、Methods、挂载 $data</p>
<h4>编译模版</h4>
<ol>
<li>在 fragment里面处理数据 需要判断是元素节点还是文字</li>
</ol>
<pre><code class="language-javascript">// 编译模版
new Compiler(this.$el || document.body, this)

// 在 fragment 里面处理元素
// 把所有 node 移动到 fragment 里面
this.$fragment = this.node2fragment(this.$el)

node2fragment(node) {
  // 创建 fragment
  let fragment = document.createDocumentFragment()
  let child

  // 拷贝
  while (child = node.firstChild) {
    fragment.appendChild(child)
  }

  return fragment
}
</code></pre>
<ol start="2">
<li>编译元素 判断指令 分为事件指令和普通指令 v-model v-html v-class v-on:click ...</li>
<li>根据指令处理相关的变量显示到页面上</li>
</ol>
<h4>数据劫持</h4>
<ol>
<li>
<p>劫持 所有 data 数据，并且新数据也需要劫持</p>
<pre><code class="language-javascript">class Observer {
  constructor(data) {
    this.observer(data)
  }
  // ...
}
</code></pre>
</li>
</ol>
<h4>监听 观察者 Watcher</h4>
<ol>
<li>
<p>观察者 Watcher 数据变化更新视图</p>
<pre><code class="language-javascript">class Watcher {
  constructor(vm, expr, cb) {
    this.vm = vm
    this.expr = expr
    this.cb = cb

    // old value
    this.oldValue = this.get()
  }
  get() {
    Dep.target = this
    let value = CompileUtil.getVal(this.vm, this.expr)
    Dep.target = null
    return value
  }
  update() {
    let newVal = CompileUtil.getVal(this.vm, this.expr)
    if (newVal !== this.oldValue) {
      this.cb(newVal)
    }
  }
}
</code></pre>
</li>
<li>
<p>维护 Dep 订阅者 Observer Set  的时候通知所有观察者</p>
<pre><code class="language-javascript">class Dep {
  constructor() {
    this.subs = []
  }
  // 添加
  addSub(watcher) {
    this.subs.push(watcher)
  }
  // 发布
  notify() {
    this.subs.forEach(w =&gt; w.update())
  }
}
</code></pre>
</li>
<li>
<p>Compile 里面 new Watcher 和 Observer 绑定起来</p>
<pre><code class="language-javascript">new Watcher(vm, expr, (newVal) =&gt; {
  console.log(`${dir} watcher`, newVal)
  fn(node, newVal)
})
</code></pre>
<pre><code class="language-javascript">// set 的时候 通知所有 Watcher
defineReactive(obj, key, value) {
  // 处理value是对象
  this.observer(value)

  let dep = new Dep()

  Object.defineProperty(obj, key, {
    get() {
      Dep.target &amp;&amp; dep.addSub(Dep.target)
      return value
    },
    set: (newVal) =&gt; {
      console.log('newVal', newVal)
      if (newVal !== value) {
        // 新value处理数据劫持
        this.observer(newVal)

        value = newVal

        dep.notify()
      }
    }
  })
}
</code></pre>
</li>
</ol>
<p>------------------ all code ------------------</p>
<pre><code class="language-javascript">class Dep {
  constructor() {
    this.subs = []
  }
  // 添加
  addSub(watcher) {
    this.subs.push(watcher)
  }
  // 发布
  notify() {
    this.subs.forEach(w =&gt; w.update())
  }
}

class Watcher {
  constructor(vm, expr, cb) {
    this.vm = vm
    this.expr = expr
    this.cb = cb

    // old value
    this.oldValue = this.get()
  }
  get() {
    Dep.target = this
    let value = CompileUtil.getVal(this.vm, this.expr)
    Dep.target = null
    return value
  }
  update() {
    let newVal = CompileUtil.getVal(this.vm, this.expr)
    if (newVal !== this.oldValue) {
      this.cb(newVal)
    }
  }
}

// 数据劫持
class Observer {
  constructor(data) {
    this.observer(data)
  }
  observer(data) {
    if (data &amp;&amp; typeof data === 'object') {
      for (const key in data) {
        this.defineReactive(data, key, data[key])
      }
    }
  }
  defineReactive(obj, key, value) {
    // 处理value是对象
    this.observer(value)

    let dep = new Dep()

    Object.defineProperty(obj, key, {
      get() {
        Dep.target &amp;&amp; dep.addSub(Dep.target)
        return value
      },
      set: (newVal) =&gt; {
        console.log('newVal', newVal)
        if (newVal !== value) {
          // 新value处理数据劫持
          this.observer(newVal)

          value = newVal

          dep.notify()
        }
      }
    })
  }
}

const CompileUtil = {
  // 根据 expr 获取数据
  getVal(vm, expr) {
    return expr.split('.').reduce((data, current) =&gt; {
      return data[current]
    }, vm.$data)
  },
  // 根据 expr 设置 value
  setVal(vm, expr, value) {
    expr.split('.').reduce((data, current, index, arr) =&gt; {
      if (index === arr.length - 1) {
        return data[current] = value
      }
      return data[current]
    }, vm.$data)
  },
  model(node, expr, vm) {
    this.bind(node, expr, vm, 'model')

    node.addEventListener('input', e =&gt; {
      let value = e.target.value
      this.setVal(vm, expr, value)
    })
  },
  text(node, expr, vm) {
    this.bind(node, expr, vm, 'text')
  },
  html(node, expr, vm) {
    this.bind(node, expr, vm, 'html')
  },
  class(node, expr, vm) {
    this.bind(node, expr, vm, 'class')
  },
  bind(node, expr, vm, dir) {
    let fn = this.updater[dir + 'Updater']
    let value = this.getVal(vm, expr)

    new Watcher(vm, expr, (newVal) =&gt; {
      console.log(`${dir} watcher`, newVal)
      fn(node, newVal)
    })

    fn(node, value)
  },
  // 事件处理
  eventHander(node, expr, vm, dir) {
    node.addEventListener(dir, e =&gt; {
      vm.$data[expr].call(vm, e)
    }, false)
  },
  updater: {
    modelUpdater(node, value) {
      node.value = value
    },
    textUpdater(node, value) {
      node.textContent = value
    },
    htmlUpdater(node, value) {
      node.innerHTML = value
    },
    classUpdater(node, value) {
      let className = node.className
      className = className.replace(/\s$/, '')
      const space = className &amp;&amp; String(value) ? ' ' : ''
      node.className = className + space + value
    }
  }
}

class Compiler {
  constructor(el, vm) {
    this.$vm = vm
    this.$el = this.isElementNode(el) ? el : document.querySelector(el)

    if (this.$el) {
      // 处理节点到fragment里
      this.$fragment = this.node2fragment(this.$el)
      // console.log('fragment', this.$fragment)

      // 编译模版
      this.compile(this.$fragment)

      // 把内容添加到页面中
      this.$el.appendChild(this.$fragment)
    }
  }

  compile(node) {
    let childNodes = node.childNodes
    ;[...childNodes].forEach(child =&gt; {
      // 如果是元素节点
      if (this.isElementNode(child)) {
        this.compileElement(child)
      } else if (this.isTextNode(child)) {
        // 如果是文字
        this.compileText(child)
      }

      // 继续遍历子节点
      if (node.childNodes &amp;&amp; node.childNodes.length) {
        this.compile(child)
      }
    });
  }

  // 编译元素
  compileElement(node) {
    let attributes = node.attributes
    ;[...attributes].forEach(attr =&gt; {
      let { name, value: expr } = attr
      // 指令
      if (this.isDirective(name)) {
        let [, directive] = name.split('-')

        // 事件指令
        if (this.isEventDirective(directive)) {
          let [, eventName] = directive.split(':')
          CompileUtil.eventHander(node, expr, this.$vm, eventName)
          node.removeAttribute(name)
        } else {
          // 普通
          CompileUtil[directive] &amp;&amp; CompileUtil[directive](node, expr, this.$vm)
        }

        // 解析后删除属性
        if (CompileUtil[directive]) {
          node.removeAttribute(name)
        }
      }
    })
  }
  // 编译文本
  compileText(node) {
    let content = node.textContent
    let reg = /\{\{(.+?)\}\}/
    if (reg.test(content)) {
      // RegExp.$1.trim() === {{ a }} 的 a
      CompileUtil.text(node, RegExp.$1.trim(), this.$vm)
    }
  }

  // 把所有 node 移动到 fragment 里面
  node2fragment(node) {
    // 创建 fragment
    let fragment = document.createDocumentFragment()
    let child

    // 拷贝
    while (child = node.firstChild) {
      fragment.appendChild(child)
    }

    return fragment
  }
  // 是否为指令
  isDirective(attrName) {
    return  attrName.startsWith('v-')
  }
  // 是否为事件
  isEventDirective(dir) {
    return  dir.startsWith('on')
  }
  // 判断是不是元素节点
  isElementNode(node) {
    return node.nodeType === 1
  }
  isTextNode(node) {
    return node.nodeType === 3
  }
}

class Vue {
  constructor(options) {
    this.$el = options.el
    this.$data = options.data
    this.$computed = options.computed
    this.$methods = options.methods

    new Observer(this.$data)

    // 先挂载到 $data 里面
    this.initComputed(this.$computed)
    this.initMethods(this.$methods)

    // 再挂载到 this 里面
    this.proxyVm(this.$data)

    // 编译模版
    new Compiler(this.$el || document.body, this)
  }

  // 代理 data 访问vm的属性代理访问vm._data的属性
  proxyVm(data) {
    for (const key in data) {
      Object.defineProperty(this, key, {
        configurable: false,
        enumerable: true,
        get() {
          return data[key]
        },
        set(newVal) {
          data[key] = newVal
        }
      })
    }
  }

  // 添加 computed
  initComputed(computed) {
    if (typeof computed === 'object') {
      for (const key in computed) {
        Object.defineProperty(this.$data, key, {
          get() {
            return computed[key].call(this)
          },
          set() {}
        })
      }
    }
  }

  // 添加 methods
  initMethods(methods) {
    if (typeof methods === 'object') {
      for (const key in methods) {
        Object.defineProperty(this.$data, key, {
          get() {
            return methods[key]
          },
          set() {}
        })
      }
    }
  }
}
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
    .red {
      color: red;
    }
    .fs {
      font-size: 20px;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;
        {{ message }}
      &lt;/li&gt;
      &lt;li&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;school.name&quot;&gt;
        {{ school.name }}{{ school.age }}
      &lt;/li&gt;
      &lt;li&gt;
        {{ sayName }}
      &lt;/li&gt;
      &lt;li&gt;&lt;button v-on:click=&quot;change&quot;&gt;Change&lt;/button&gt;&lt;/li&gt;
      &lt;li v-html=&quot;html&quot;&gt;&lt;/li&gt;
      &lt;li v-class=&quot;class&quot;&gt;red&lt;/li&gt;
      &lt;li class=&quot;fs&quot; v-class=&quot;class&quot;&gt;red&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    let vm = new Vue({
      el: '#app',
      data: {
        message: 'hello world',
        school: {
          name: 'xiao',
          age: 18
        },
        html: '&lt;h1&gt;Hello&lt;/h1&gt;',
        class: 'red'
      },
      computed: {
        sayName() {
          return this.school.name + 'hhhh'
        }
      },
      methods: {
        change() {
          this.school.name = 'vue event change name'
        }
      }
    })

    window.vm = vm
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[CSS Grid 学习]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/57</link>
            <guid>https://github.com/xiaotiandada/blog/issues/57</guid>
            <pubDate>Tue, 19 Jan 2021 06:39:15 GMT</pubDate>
            <description><![CDATA[<p>2020-08-06 00:28:58</p>
<p><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程 </a></p>
<p><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/">写给自己看的display: grid布局教程</a></p>
<!-- more -->
<p>练习时候顺便敲的 就顺带贴进来了~</p>
<pre><code class="language-html">  &lt;!-- https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html --&gt;
  &lt;div class=&quot;item&quot;&gt;
    &lt;div&gt;
      &lt;p&gt;1&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;p&gt;2&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;p&gt;3&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;p&gt;4&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;p&gt;5&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;p&gt;6&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;p&gt;7&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;p&gt;8&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;p&gt;9&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<pre><code class="language-css">.item {
  display: grid;
  /* grid-template-columns: repeat(auto-fill, 100px); */
  /* grid-template-columns: 1fr 2fr; */
  /* grid-template-columns: 1fr 1fr minmax(100px, 1fr); */
  /* grid-template-columns: 100px auto 100px; */
  /* grid-template-rows: repeat(3, 33.33%); */
  /* grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; */
  /* grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4]; */
  /* grid-template-columns: 70% 30%; */
  /* grid-template-columns: repeat(12, 1fr); */
  grid-template-columns: repeat(3, 100px);
  grid-template-rows: repeat(3, 100px);
  /* column-gap: 20px; */
  /* row-gap: 20px; */
  grid-template-areas:
    'a b c '
    'd e f '
    'g h i';
  /* grid-template-areas:
    'a a a'
    'b b b'
    'c c c'; */
  /* grid-template-areas: &quot;header header header&quot;
    &quot;main main sidebar&quot;
    &quot;footer footer footer&quot;; */
  /* grid-template-areas: 'a . c'
    'd . f'
    'g . i'; */
  /* grid-auto-flow: row; */
  /* grid-auto-flow: row dense; */
  place-content: center;
}

.item&gt;div {
  /* justify-content: center; */
  /* align-items: center; */
  display: grid;
  place-items: center center;
  /* justify-self: center; */
  /* align-self: center; */
  place-self: center;
}

.item div:nth-child(1) {
  background-color: red;
  /* grid-column-start: 1; */
  /* grid-column-end: 3; */
  grid-column-start: span 2;
  grid-area: e;
}

.item div:nth-child(2) {
  background-color: rgb(65, 107, 175);
  /* grid-column-start: 1; */
  /* grid-column-end: 3; */
}

.item div:nth-child(3) {
  background-color: rgb(81, 231, 81);
}

.item div:nth-child(4) {
  background-color: rgb(88, 23, 107);
}

.item div:nth-child(5) {
  background-color: rgb(50, 179, 129);
}

.item div:nth-child(6) {
  background-color: rgb(24, 70, 52);
}

.item div:nth-child(7) {
  background-color: rgb(175, 65, 133);
}

.item div:nth-child(8) {
  background-color: rgb(109, 110, 117);
  /* grid-column-start: 2; */
  /* grid-row-start: 4; */
}

.item div:nth-child(9) {
  background-color: rgb(161, 134, 69);
  /* grid-row-start: 5; */
  /* grid-column-start: 3; */
}
</code></pre>
<p>未完待续...</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[node 服务号 微信扫码登录]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/56</link>
            <guid>https://github.com/xiaotiandada/blog/issues/56</guid>
            <pubDate>Tue, 19 Jan 2021 06:38:58 GMT</pubDate>
            <description><![CDATA[<p>暂时留个坑……</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[elasticsearch node 简单使用]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/55</link>
            <guid>https://github.com/xiaotiandada/blog/issues/55</guid>
            <pubDate>Tue, 19 Jan 2021 06:38:40 GMT</pubDate>
            <description><![CDATA[<p>2020-08-02 22:20:54</p>
<p>elasticsearch node 简单的使用 <a href="https://github.com/xiaotiandada/brick">repo</a></p>
<p><a href="https://juejin.im/entry/6844903607775526919">https://juejin.im/entry/6844903607775526919</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/16.x/api-reference-6-8.html#api-search-6-8">https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/16.x/api-reference-6-8.html#api-search-6-8</a></p>
<p><a href="https://www.npmjs.com/package/elasticsearch">https://www.npmjs.com/package/elasticsearch</a></p>
<p><a href="https://www.npmjs.com/package/egg-es">https://www.npmjs.com/package/egg-es</a></p>
<!-- more -->
<h5>前置条件</h5>
<ol>
<li>elasticsearch 环境</li>
<li>node(用了 egg) 环境</li>
</ol>
<h6>填充数据</h6>
<p>开始选择用了 <a href="https://www.npmjs.com/package/elasticsearch">elasticsearch</a> 包利用 <strong>js</strong> 直接填充<strong>城市 cities</strong>数据</p>
<p><a href="https://juejin.im/entry/6844903607775526919">https://juejin.im/entry/6844903607775526919</a></p>
<blockquote>
<p>这里有一些 index、type、id 需要相同 这样才能正确的使用和填充数据删除之类的</p>
</blockquote>
<pre><code class="language-javascript">const elasticsearch = require(&quot;elasticsearch&quot;);
// 所有城市数据
const cities = require('./cities.json')
const axios = require('axios')

// init apiVersion 需要和本地一样
const client = new elasticsearch.Client({
    host: &quot;localhost:9200&quot;,
    log: &quot;trace&quot;,
    apiVersion: &quot;6.8&quot;, // use the same version of your Elasticsearch instance
});
const sleep = time =&gt; new Promise(reslove =&gt; setTimeout(reslove, time))

const init = async () =&gt; {
    try {
        await client.ping({
            requestTimeout: 30000
        });
    } catch (e) {
        console.log('e', e)
    }
}
init()

// 创建索引
// -&gt; POST http://localhost:9200/es_user/_doc/1/_create
const createFunc = async () =&gt; {
    try {
        await client.create({
            index: 'es_user',
            type: '_doc',
            id: '1',
            body: {}
        });
    } catch (error) {
        console.log('create error', error)
    }
}

// 删除
// -&gt; DELETE http://localhost:9200/es_user/_doc/1
const deleteFunc = async () =&gt; {
    try {
        await client.delete({
            index: 'es_user',
            type: '_doc',
            id: '1',
        });
    } catch (error) {
        console.log('delete error', error)
    }
}

// 填充数据
const push = (cities, start, end) =&gt; {
    var bulk = [];
    cities.slice(start, end).forEach(city =&gt; {
        bulk.push({
            index: {
                _index: 'es_user',
                _type: '_doc',
            }
        })
        bulk.push(city)
    })

    // console.log('bulk: go', bulk)

    // 对传递的数据执行批量索引
    client.bulk({
        body: bulk
    }, function (err, response) {
        if (err) {
            console.log(&quot;Failed Bulk operation&quot;.red, err)
        } else {
            console.log(&quot;Successfully imported %s&quot;.green, cities.length);
        }
    });

}

// 开始冲
// 这里为什么这样写....
const go = async () =&gt; {
	  // 1. 因为例子的json的数据非常大按照官方的建议说 1000-5000个数据 所以我这里拆了一下
    let citiesLen = Math.ceil(cities.length / 1000)
    for (let i = 0; i &lt;= citiesLen; i++) {
	      // 2. 因为有时候老是提示没有权限 然后这里直接 设置一下(可以忽略的 因为第一次不太会)
        await axios({
            method: 'put',
            url: 'http://localhost:9200/_all/_settings',
            headers: {
                'Content-Type': 'application/json'
            },
            data: {
                &quot;index.blocks.read_only_allow_delete&quot;: false
            }
        })
	      // 2. 让他停一会儿 懒得用 async map (可以在npm search)
        await sleep(300)
	      // 3. 开始填充数据 
        push(cities, i * 1000, (i+1) * 1000)
    }
}

// deleteFunc()
// createFunc()
// go()
</code></pre>
<h5>写接口</h5>
<p>node用了egg初始化的项目</p>
<h6>router</h6>
<pre><code class="language-javascript">// elasticsearch
router.get('/api/search', controller.elasticsearch.search);
</code></pre>
<h6>func</h6>
<pre><code class="language-javascript">// 因为用了 egg 为了方便 用 egg-es 
// https://www.npmjs.com/package/egg-es
// 文档的方法⬇️⬇️⬇️ 

// Usage
// {app_root}/config/plugin.js
exports.elasticsearch = {
  enable: true,
  package: 'egg-es',
};

// Configuration
// {app_root}/config/config.default.js
exports.elasticsearch = {
  host: 'localhost:9200',
  apiVersion: '6.3'
};

export default class Elasticsearch extends Service {
  public async search(wd: string) {
    try {
      // https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/16.x/api-reference-6-8.html#api-search-6-8
      // search doc 因为body还没有理解 赞赏用了简单的搜索🔍
      const response = await this.app.elasticsearch.search({
        index: 'es_user',
        body: {
          query: {
            match: {
              name: wd,
            },
          },
        }
      })
      console.log('response', response)
      // 格式化一下数据
      const list = response.hits.hits.map((i: { _source: object[] }) =&gt; i._source)
      return {
        count: response.hits.total || 0,
        list,
      }
    } catch (e) {
      console.log('search e', e)
      return ''
    }
  }
}

</code></pre>
<p>数据都已经有了, 前端大伙随便搞搞就好了 后面还有很多功能还没有使用 <strong>分词、过滤、什么什么吧啦吧啦</strong> 后面用到了继续写文章介绍</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[You Don't Need JavaScript]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/54</link>
            <guid>https://github.com/xiaotiandada/blog/issues/54</guid>
            <pubDate>Tue, 19 Jan 2021 06:38:13 GMT</pubDate>
            <description><![CDATA[<p>2020-07-29 00:14:56</p>
<p><a href="https://github.com/xiaotiandada/You-Dont-Need-JavaScript">You-Dont-Need-JavaScript</a> 学习 可以根据 <strong>fork</strong> 的地址找到原库</p>
<!-- more -->
<h5>checkbox-counter</h5>
<p><a href="https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/counter">https://developer.cdn.mozilla.net/zh-CN/docs/Web/CSS/counter</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/counter-increment">https://developer.mozilla.org/zh-CN/docs/Web/CSS/counter-increment</a></p>
<p>计数器统计 主要利用了 counter-increment counter css 属性</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[ You-Dont-Need-Lodash-Underscore]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/53</link>
            <guid>https://github.com/xiaotiandada/blog/issues/53</guid>
            <pubDate>Tue, 19 Jan 2021 06:37:43 GMT</pubDate>
            <description><![CDATA[<p>2020-07-12 16:56:33</p>
<p>You-Dont-Need-Lodash-Underscore 学习</p>
<p><a href="https://github.com/xiaotiandada/You-Dont-Need-Lodash-Underscore">repo</a> 可以根据 <strong>fork</strong> 的地址找到原库</p>
<p>这是一个非常优秀的开源项目 自己阅读 <strong>Code</strong> 来学习 遇到无法一下就看明白的 <strong>Code</strong> 在 <code>main.js</code> 里面运行了一次 有 <code>debounce</code> <code>throttle</code> 用到了 <strong>Browser</strong> 环境 代码在 <code>index.html</code>里面 🎉🎉🎉</p>
<!-- more -->
<pre><code class="language-javascript">// https://github.com/xiaotiandada/You-Dont-Need-Lodash-Underscore

// Array

{
  const chunk = (input, size) =&gt; {
    return input.reduce((arr, item, idx) =&gt; {
      return idx % size === 0
        ? [...arr, [item]]
        : [...arr.slice(0, -1), [...arr.slice(-1)[0], item]];
    }, []);
  };
  
  console.log(chunk(['a', 'b', 'c', 'd', 'e', 'f'], 3))
}

{
  let arrays = [[1, 2, 3, 4, 5], [5, 2, 10]];
  const difference = array =&gt; array.reduce((a, b) =&gt; a.filter(i =&gt; !b.includes(i)))

  console.log(difference(arrays))
}


{
  const flattenDeep = arr =&gt; Array.isArray(arr) ? arr.reduce((a, b) =&gt; a.concat(flattenDeep(b)), []) : [arr]

  console.log(flattenDeep([1, [[2], [3, 4]], 5]))
}

{
  // flat

  const flattenDeep = arr =&gt; arr.flatMap(subArray =&gt; Array.isArray(subArray) ? flattenDeep(subArray) : subArray)

  console.log(flattenDeep([1, [[2], [3, 4]], 5]))

}

{
  let arrays = [[1, 2, 3], [101, 2, 1, 10], [2, 1]];
  
  const intersection = array =&gt; array.reduce((a, b) =&gt; a.filter((c =&gt; b.includes(c))))

  console.log(intersection(arrays))
}

{
  let array = ['one', 'two', 'three']
  const grouped = arrary =&gt; arrary.reduce((r, v, i, a, k = v.length) =&gt; ((r[k] || (r[k] = [])).push(v), r), {})

  console.log(grouped(array))
}


{
  const keyBy = (array, key) =&gt; (array || []).reduce((r, x) =&gt; ({ ...r, [key ? x[key] : x] : x}), {})
  console.log(keyBy([{ id: 'a1', title: 'abc' }, { id: 'b2', title: 'def' }], 'id'))
}

{
  const fruits = [
    {name:&quot;banana&quot;, amount: 2},
    {name:&quot;apple&quot;, amount: 4},
    {name:&quot;pineapple&quot;, amount: 2},
    {name:&quot;mango&quot;, amount: 1}
  ];

  const sortBy = key =&gt; (a, b) =&gt; (a[key] &gt; b[key] ? 1 : ((b[key] &gt; a[key]) ? -1 : 0))
  let sortArr = fruits.concat().sort(sortBy('name'))
  console.log('sortArr', sortArr)

  console.log('sortArr', fruits.concat().sort(sortBy('amount')))
}


{
  function debounce(func, wait, immediate) {
    let timeout = null
    return function() {
    let args = arguments
      let context = this
      clearTimeout(timeout)
      timeout = null
      timeout = setTimeout(function() {
        if (!immediate) {
          func.apply(context, args)
        }
      }, wait)
      if (immediate &amp;&amp; !timeout) {
        func.apply(context, args)
      }
    }
  }

  const show = () =&gt; console.log('scrollTop', document.body.scrollTop || document.documentElement.scrollTop)

  // window.addEventListener('scroll', debounce(show, 150))
}

{
  function throttle (func, timeFrame) {
    let lastTime = 0
    return function() {
      let now = Date.now()
      if (now - lastTime &gt;= timeFrame) {
        func()
        lastTime = now
      }
    }
  }
  const show = () =&gt; console.log('scrollTop', document.body.scrollTop || document.documentElement.scrollTop)

  // window.addEventListener('scroll', throttle(show, 150))

}

{
  const isEmpty = obj =&gt; [Object, Array].includes((obj || {}).constructor) &amp;&amp; !Object.entries((obj || {})).length

  console.log(isEmpty(null))
  // output: true
  console.log(isEmpty(''))
  // output: true
  console.log(isEmpty({}))
  // output: true
  console.log(isEmpty([]))
  // output: true
  console.log(isEmpty({a: '1'}))
  // output: false
  console.log(isEmpty(undefined))

}

{
  const get = (obj, path, defaultValue = undefined) =&gt; {
    const traval = regexp =&gt; String.prototype.split
        .call(path, regexp)
        .filter(Boolean)
        .reduce((res, key) =&gt; (res !== null &amp;&amp; res !== undefined ? res[key] : res), obj)

    const result = traval(/[,[\]]+?/) || traval(/[,[\].]+?/)
    return result === undefined || result === obj ? defaultValue : result
  }
  var object = { a: [{ b: { c: 3 } }] };
  var result = get(object, 'a[0].b.c', 1);
  console.log('result', result)
}

</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[Nginx 负载均衡]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/52</link>
            <guid>https://github.com/xiaotiandada/blog/issues/52</guid>
            <pubDate>Tue, 19 Jan 2021 06:37:26 GMT</pubDate>
            <description><![CDATA[<p>2020-07-10 14:39:18</p>
<h2>一、负载均衡 - 初探</h2>
<p><strong>资料参考:</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/89356016">https://zhuanlan.zhihu.com/p/89356016</a></p>
<p><a href="https://juejin.im/post/5e60edbf5188254940670f75">https://juejin.im/post/5e60edbf5188254940670f75</a></p>
<!-- more -->
<p>服务器这边使用了 <strong>Nodejs</strong> 分别启两个服务 <strong>7001</strong> <strong>7002</strong>  和 两台机器 启动 <strong>7001</strong></p>
<p><strong>Nginx</strong> 这边使用 <strong>upstream</strong></p>
<p>nginx的upstream目前支持的5种方式的分配</p>
<p>1、轮询（默认） <strong>本地测试了这种</strong></p>
<p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p>
<pre><code class="language-nginx">upstream node { 
  server 127.0.0.1:7001; 
  server 127.0.0.1:7002; 
} 
</code></pre>
<p>2 - 4 没有测试过 复制的....</p>
<p>2、指定权重</p>
<p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p>
<pre><code class="language-nginx">upstream backserver { 
  server 127.0.0.1:7001 weight=8; 
  server 127.0.0.1:7002 weight=10; 
} 
</code></pre>
<p>3、IP绑定 ip_hash</p>
<p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>
<pre><code class="language-nginx">upstream backserver { 
  ip_hash; 
  server 127.0.0.1:7001; 
  server 127.0.0.1:7002; 
} 
</code></pre>
<p>4、fair（第三方）</p>
<p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<pre><code class="language-nginx">upstream backserver { 
  server 127.0.0.1:7001; 
  server 127.0.0.1:7002; 
  fair; 
} 
</code></pre>
<p>5、url_hash（第三方）</p>
<p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p>
<pre><code class="language-nginx">upstream backserver { 
  server 127.0.0.1:7001; 
  server 127.0.0.1:7002; 
  hash $request_uri; 
  hash_method crc32; 
} 
</code></pre>
<blockquote>
<p>max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误</p>
<p>fail_timeout:max_fails次失败后，暂停的时间 (复制的...</p>
</blockquote>
<p>在 <strong>Nginx</strong> 定义 测试机</p>
<pre><code class="language-nginx">http {
	upstream node {
    server 127.0.0.1:7001;
    server 192.168.1.11:7002;
  }
  
  # 因为 80 端口别的占用了 开了7000 代理
  server {
    listen 7000;
    server_name localhost;

    location / {
      proxy_pass http://node;
    }

  }
}

</code></pre>
<pre><code class="language-bash">nginx -t

# 如果没有启动先
nginx

nginx -s reload
</code></pre>
<p>因为 <strong>egg</strong> 定义的 <strong>router</strong> 返回了 <strong>port</strong> 直接访问 <strong>127.0.0.1:7000</strong> 可以查看结果 随机返回 <strong>7001/7002</strong></p>
<p>测试用了 <strong>jmeter</strong> 但是接口没异常 <strong>jmeter</strong> 倒是g了 使用不太熟练 请求次数太大了 但是效果还是可以看出来的</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[让Mocha支持es6语法]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/51</link>
            <guid>https://github.com/xiaotiandada/blog/issues/51</guid>
            <pubDate>Tue, 19 Jan 2021 06:37:07 GMT</pubDate>
            <description><![CDATA[<p>2020-07-08 18:23:34</p>
<p>因为 Mocha 默认支持 commonJS</p>
<p>参考资料 <a href="https://greenfavo.github.io/blog/docs/02.html">https://greenfavo.github.io/blog/docs/02.html</a></p>
<!-- more -->
<p>如果直接引入 import 会报错, 这让 写 es 语法的时候无法通过 import 来直接测试</p>
<p>这里借助 babel 转换</p>
<p>定义 <strong>scripts</strong> 运行 <strong>test</strong> Mocha 会自动执行 test 目录的测试代码</p>
<pre><code class="language-javascript">&quot;scripts&quot;: {
  &quot;test&quot;: &quot;mocha&quot;,
}
</code></pre>
<p>为了支持es6语法，加上以下代码</p>
<pre><code class="language-javascript">&quot;scripts&quot;: {
  &quot;test&quot;: &quot;mocha --require babel-register --bail&quot;,
}
</code></pre>
<p>安装依赖</p>
<pre><code class="language-bash">npm install babel-register  babel-preset-env -D
</code></pre>
<p>新建 <strong>.babelrc</strong></p>
<pre><code class="language-json">{
  &quot;presets&quot;: [
    [&quot;env&quot;]
  ]
}
</code></pre>
<p>babel会自动读取<code>.babelrc</code>配置文件，这样就让我们的Mocha代码支持es6的模块系统和es6的其他语法了</p>
<p>运行</p>
<pre><code class="language-bash">npm run test
</code></pre>
<p>Mocha配置说明 (纯复制</p>
<blockquote>
<p>Mocha的两个配置--require和--bail,官方文档是这样说的：</p>
<p>–require</p>
<p>The –require option is useful for libraries such as should.js, so you may simply –require should instead of manually invoking require(‘should’) within each test file.</p>
<p>意思是--require和在代码里手动require('babel-register')一样，但写在配置里会作用到每个test文件。<a href="http://xn--ruu81c3y7d2bq.es">默认支持.es</a> .js .jsx扩展名. 老版本的Mocha使用--compilers命令支持其他文件扩展名，但在4.0后就废弃掉了。</p>
<p>–bail</p>
<p>Only interested in the first exception? use –bail!</p>
<p>--bail可以在第一个异常抛出的时候停止运行测试,这对集成测试很重要。</p>
<p>About Babel</p>
<p>If your ES6 modules have extension .js, you can npm install –save-dev babel-register and use mocha –require babel-register; –compilers is only necessary if you need to specify a file extension.</p>
<p>babel-register可以让Mocha支持ES6 module，就是import export 写法.</p>
<p>babel-preset-env在没有任何配置选项的情况下，与 babel-preset-latest（或者babel-preset-es2015，babel-preset-es2016和babel-preset-es2017一起）的行为完全相同。官方推荐使用babel-preset-env.</p>
</blockquote>
]]></description>
        </item>
        <item>
            <title><![CDATA[GraphQL]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/50</link>
            <guid>https://github.com/xiaotiandada/blog/issues/50</guid>
            <pubDate>Tue, 21 Jun 2022 11:23:08 GMT</pubDate>
            <description><![CDATA[<p>学习记录📝 <a href="https://github.com/xiaotiandada/graphql">Repo</a></p>
<!-- more -->
<p><strong>资料</strong></p>
<p><a href="https://graphql.org/">https://graphql.org/</a></p>
<p><a href="https://mp.weixin.qq.com/s/bqStS2IBvBSDAiSjLdYETw">https://mp.weixin.qq.com/s/bqStS2IBvBSDAiSjLdYETw</a></p>
<p><a href="https://www.apollographql.com/docs/apollo-server/">https://www.apollographql.com/docs/apollo-server/</a></p>
<h2>尝鲜(初次体验)</h2>
<h3>复制文档</h3>
<pre><code class="language-bash"># ... init ...
npm install graphql
</code></pre>
<pre><code class="language-javascript">var { graphql, buildSchema } = require('graphql');

var schema = buildSchema(`
  type Query {
    hello: String
  }
`);

var root = { hello: () =&gt; 'Hello world!' };

graphql(schema, '{ hello }', root).then((response) =&gt; {
  console.log(response);
});
</code></pre>
<p>然后运行 <code>node app</code>, 基本操作了... 这个可能不太直观 ~</p>
<pre><code class="language-bash">npm install express express-graphql graphql
</code></pre>
<pre><code class="language-javascript">var express = require('express');
var graphqlHTTP = require('express-graphql');
var { buildSchema } = require('graphql');

var schema = buildSchema(`
  type Query {
    hello: String
  }
`);

var root = { hello: () =&gt; 'Hello world!' };

var app = express();
app.use('/graphql', graphqlHTTP({
  schema: schema,
  rootValue: root,
  graphiql: true,
}));
app.listen(4000, () =&gt; console.log('Now browse to localhost:4000/graphql'));
</code></pre>
<p>然后运行 <code>node app</code>, 可以在 <code>/graphql</code>路由下运行他的工具页面 (懒得截图 🍑)</p>
<pre><code class="language-bash">npm install apollo-server-express express
</code></pre>
<pre><code class="language-javascript">const express = require('express');
const { ApolloServer, gql } = require('apollo-server-express');

const typeDefs = gql`
  type Query {
    hello: String
  }
`;

const resolvers = {
  Query: {
    hello: () =&gt; 'Hello world!',
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

const app = express();
server.applyMiddleware({ app });

app.listen({ port: 4000 }, () =&gt;
  console.log('Now browse to http://localhost:4000' + server.graphqlPath)
);
</code></pre>
<p>重复上面的操作... 这里利用了 <a href="https://www.apollographql.com/docs/apollo-server/">apollo-server</a></p>
<pre><code class="language-json">{
	hello
}
</code></pre>
<p>简单的查询 Query hello..... hello world 经典语录</p>
<p>具体的可以看文档, 没有什么营养 因为都是copy的(凑点字数).....</p>
<hr>
<h3>简单的操作</h3>
<p>需要一个简单的 books list</p>
<ol>
<li>查询所有books</li>
<li>添加 book</li>
<li>更新 book</li>
<li>删除 book</li>
</ol>
<p>跳过依赖安装, 缺少依赖自行搞定! 没有使用数据库 本地存放一个 <strong>Varible</strong></p>
<pre><code class="language-javascript">const express = require('express');
const { ApolloServer, gql } = require('apollo-server-express');

// 书库 没接数据库
const books = [
  {
    id: 0,
    title: 'Harry Potter and the Chamber of Secrets',
    author: 'J.K. Rowling',
  },
  {
    id: 1,
    title: 'Jurassic Park',
    author: 'Michael Crichton'
  },
];

// 定义 type
const typeDefs = gql`
  type Book {
    id: Int,
    title: String
    author: String
  }

  type Query {
    books: [Book],
  }

  type Mutation {
    createBook(title: String, author: String): Book,
    updateBook(id: Int, title: String, author: String): Book,
    deleteBook(id: Int, title: String, author: String): Book,
  }
`;
// 定义 resolvers
const resolvers = {
  Query: {
    // 查询所有书
    books: () =&gt; books,
  },
  Mutation: {
    // 创建一本书
    createBook: (_, { title, author }) =&gt; {
      let list = {
        id: books.length,
        title,
        author
      }
      books.push(list)
      return list
    },
    // 更新一本书
    updateBook: (_, { id, title, author }) =&gt; {
      let idx = books.findIndex(i =&gt; i.id === id)
      if (~idx) {
        books[idx] = {
          id: idx,
          title: title,
          author: author
        }
        return books[idx]
      } else {
        return []
      }
    },
    // 删除一本书
    deleteBook: (_, { id }) =&gt; {
      let idx = books.findIndex(i =&gt; i.id === id)
      if (~idx) {
        books.splice(idx, 1)
        return books[idx]
      } else {
        return []
      }
    }
  }
};

const server = new ApolloServer({ typeDefs, resolvers });

const app = express();
server.applyMiddleware({ app });

app.listen({ port: 4000 }, () =&gt;
  console.log('Now browse to http://localhost:4000' + server.graphqlPath)
);
</code></pre>
<pre><code class="language-json">query GetBooks {
  books {
    id,
    title
    author
  }
}

mutation Create {
  createBook(title: &quot;12312&quot;, author: &quot;xxxxx&quot;) {title, author},
}

mutation Update {
  updateBook(id: 0, title: &quot;123&quot;, author: &quot;xxxxx&quot;) {id, title, author}
}

mutation Delete {
  deleteBook(id: 1) {id, title, author}
}
</code></pre>
<p>一些请求语句参考 愿君快速 <strong>debug</strong></p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;books&quot;: [
      {
        &quot;id&quot;: 0,
        &quot;title&quot;: &quot;Harry Potter and the Chamber of Secrets&quot;,
        &quot;author&quot;: &quot;J.K. Rowling&quot;
      },
      {
        &quot;id&quot;: 1,
        &quot;title&quot;: &quot;Jurassic Park&quot;,
        &quot;author&quot;: &quot;Michael Crichton&quot;
      }
    ]
  }
}
</code></pre>
<p>所有书单的返回 <strong>list</strong></p>
<h3>Tool</h3>
<ul>
<li><a href="https://studio.apollographql.com/">https://studio.apollographql.com/</a></li>
<li><a href="https://blog.aisensiy.me/graphql-test-tools">https://blog.aisensiy.me/graphql-test-tools</a></li>
<li><a href="https://docs.nestjs.com/graphql/quick-start">https://docs.nestjs.com/graphql/quick-start</a></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/24250627/174787989-73db0e51-4032-4202-86a1-1b0870288af5.png" alt="image"></p>
]]></description>
        </item>
        <item>
            <title><![CDATA[适配iPhonex]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/49</link>
            <guid>https://github.com/xiaotiandada/blog/issues/49</guid>
            <pubDate>Tue, 19 Jan 2021 06:36:19 GMT</pubDate>
            <description><![CDATA[<p>2020-06-24 22:30:32</p>
<p><a href="%5Bhttps://github.com/gqzydh/blog/blob/7fa5f844c11b53f926a9bf405051cb07ed24966f/source/_posts/Wap-%E7%BD%91%E9%A1%B5%E9%80%82%E9%85%8DiPhoneX.md%5D(https://github.com/gqzydh/blog/blob/7fa5f844c11b53f926a9bf405051cb07ed24966f/source/_posts/Wap-%E7%BD%91%E9%A1%B5%E9%80%82%E9%85%8DiPhoneX.md)">Wap-网页适配iPhoneX.md</a></p>
<p>[<a href="https://webkit.org/blog/7929/designing-websites-for-iphone-x/">Designing Websites for iPhone X</a>](<a href="https://webkit.org/blog/7929/designing-websites-for-iphone-x/?hmsr=funteas.com&amp;utm_medium=funteas.com&amp;utm_source=funteas.com">https://webkit.org/blog/7929/designing-websites-for-iphone-x/?hmsr=funteas.com&amp;utm_medium=funteas.com&amp;utm_source=funteas.com</a>)</p>
<!-- more -->
<p>这篇文章写得很不错了, 介绍了很多种情况 摘要一些内容(copy)...</p>
<hr>
<p>前言</p>
<p>iPhoneX 取消了物理按键，改成底部小黑条，这一改动导致网页出现了比较尴尬的屏幕适配问题。对于网页而言，顶部（刘海部位）的适配问题浏览器已经做了处理，所以我们只需要关注底部与小黑条的适配问题即可（即常见的吸底导航、返回顶部等各种相对底部 fixed 定位的元素）。</p>
<p>笔者通过查阅了一些官方文档，以及结合实际项目中的一些处理经验，整理了一套简单的适配方案.</p>
<h2>适配之前需要了解的几个新知识</h2>
<p>安全区域</p>
<p>安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角（corners）、齐刘海（sensor housing）、小黑条（Home Indicator）影响，也就是说，我们要做好适配，必须保证页面可视、可操作区域是在安全区域内。</p>
<p>更详细说明，参考文档：<a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/">Human Interface Guidelines - iPhoneX</a></p>
<h2>viewport-fit</h2>
<p>iOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置三个值：</p>
<p>contain: 可视窗口完全包含网页内容
cover：网页内容完全覆盖可视窗口
auto：默认值，跟 contain 表现一致</p>
<blockquote>
<p>注意：网页默认不添加扩展的表现是 viewport-fit=contain，需要适配 iPhoneX 必须设置 viewport-fit=cover，这是适配的关键步骤。</p>
</blockquote>
<p>更详细说明，参考文档：<a href="https://www.w3.org/TR/css-round-display-1/#viewport-fit-descriptor">viewport-fit-descriptor</a></p>
<h2>env() 和 constant()</h2>
<p>iOS11 新增特性，Webkit 的一个 CSS 函数，用于设定安全区域与边界的距离，有四个预定义的变量：</p>
<p>safe-area-inset-left：安全区域距离左边边界距离
safe-area-inset-right：安全区域距离右边边界距离
safe-area-inset-top：安全区域距离顶部边界距离
safe-area-inset-bottom：安全区域距离底部边界距离
这里我们只需要关注 safe-area-inset-bottom 这个变量，因为它对应的就是小黑条的高度（横竖屏时值不一样）。</p>
<p>注意：当 viewport-fit=contain 时 env() 是不起作用的，必须要配合 viewport-fit=cover 使用。对于不支持env() 的浏览器，浏览器将会忽略它。</p>
<p>在这之前，笔者使用的是 constant()，后来，官方文档加了这么一段注释（坑）：</p>
<p>The env() function shipped in iOS 11 with the name constant(). Beginning with Safari Technology Preview 41 and the iOS 11.2 beta, constant() has been removed and replaced with env(). You can use the CSS fallback mechanism to support both versions, if necessary, but should prefer env() going forward.</p>
<p>这就意味着，之前使用的 constant() 在 iOS11.2 之后就不能使用的，但我们还是需要做向后兼容，像这样：</p>
<pre><code>padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS &lt; 11.2 */
padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS &gt;= 11.2 */
注意：env() 跟 constant() 需要同时存在，而且顺序不能换。
</code></pre>
<p>更详细说明，参考文档：<a href="https://webkit.org/blog/7929/designing-websites-for-iphone-x/?hmsr=funteas.com&amp;utm_medium=funteas.com&amp;utm_source=funteas.com">Designing Websites for iPhone X</a></p>
<h2>如何适配</h2>
<p>了解了以上所说的几个知识点，接下来我们适配的思路就很清晰了。</p>
<p>第一步：设置网页在可视窗口的布局方式</p>
<p>新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口：</p>
<pre><code class="language-html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, viewport-fit=cover&quot;&gt;
</code></pre>
<p>前面也有提到过，只有设置了 viewport-fit=cover，才能使用 env()。</p>
<p>第二步：页面主体内容限定在安全区域内</p>
<p>这一步根据实际页面场景选择，如果不设置这个值，可能存在小黑条遮挡页面最底部内容的情况。</p>
<pre><code class="language-css">body {
  padding-bottom: constant(safe-area-inset-bottom);
  padding-bottom: env(safe-area-inset-bottom);
}
</code></pre>
<p>第三步：fixed 元素的适配</p>
<p>类型一：fixed 完全吸底元素（bottom = 0），比如下图这两种情况：</p>
<p>可以通过加内边距 padding 扩展高度：</p>
<pre><code class="language-css">{
  padding-bottom: constant(safe-area-inset-bottom);
  padding-bottom: env(safe-area-inset-bottom);
}
</code></pre>
<p>或者通过计算函数 calc 覆盖原来高度：</p>
<pre><code class="language-css">{
  height: calc(60px(假设值) + constant(safe-area-inset-bottom));
  height: calc(60px(假设值) + env(safe-area-inset-bottom));
}
</code></pre>
<p>注意，这个方案需要吸底条必须是有背景色的，因为扩展的部分背景是跟随外容器的，否则出现镂空情况。</p>
<p>还有一种方案就是，可以通过新增一个新的元素（空的颜色块，主要用于小黑条高度的占位），然后吸底元素可以不改变高度只需要调整位置，像这样：</p>
<pre><code class="language-css">{
  margin-bottom: constant(safe-area-inset-bottom);
  margin-bottom: env(safe-area-inset-bottom);
}
</code></pre>
<p>空的颜色块：</p>
<pre><code class="language-css">{
  position: fixed;
  bottom: 0;
  width: 100%;
  height: constant(safe-area-inset-bottom);
  height: env(safe-area-inset-bottom);
  background-color: #fff;
}
</code></pre>
<p>类型二：fixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等</p>
<p>像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理：</p>
<pre><code class="language-css">{
  margin-bottom: constant(safe-area-inset-bottom);
  margin-bottom: env(safe-area-inset-bottom);
}
</code></pre>
<p>或者，你也可以通过计算函数 calc 覆盖原来 bottom 值：</p>
<pre><code class="language-css">{
  bottom: calc(50px(假设值) + constant(safe-area-inset-bottom));
  bottom: calc(50px(假设值) + env(safe-area-inset-bottom));
}
</code></pre>
<p>你也可以使用 @supports 隔离兼容样式</p>
<p>写到这里，我们常见的两种类型的 fixed 元素适配方案已经了解了吧。如果我们只希望 iPhoneX 才需要新增适配样式，我们可以配合 @supports 来隔离兼容样式，当然这个处理对页面展示实际不会有任何影响：</p>
<pre><code class="language-css">@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) {
  div {
    margin-bottom: constant(safe-area-inset-bottom);
    margin-bottom: env(safe-area-inset-bottom);
  }
}
</code></pre>
<p>ps: 某些css功能不支持的时候可以使用 @supports</p>
<p><a href="http://matataki.io/">效果地址</a> 使用移动端打开任意一篇文章查看 底栏部分!!!</p>
<p>原作者总结得比我好, 拿过来学习学习!!!</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[算法数据结构]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/48</link>
            <guid>https://github.com/xiaotiandada/blog/issues/48</guid>
            <pubDate>Tue, 28 Jun 2022 17:53:35 GMT</pubDate>
            <description><![CDATA[<h2>栈</h2>
<ul>
<li><a href="https://codesandbox.io/s/data-structures-and-algorithms-hbw4wf?file=/src/index.js">codesandbox demo code</a></li>
</ul>
<iframe src="https://codesandbox.io/embed/data-structures-and-algorithms-hbw4wf?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="Data Structures and Algorithms"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
<p><img src="https://i.imgur.com/7fd9IEm.png" alt="栈的定义及实现- Crystal_Guang - 博客园"></p>
<p><img src="https://i.imgur.com/dVdl97R.png" alt="数据结构之栈和队列- 归斯君- 博客园"></p>
<pre><code class="language-js">class Stack {
  constructor() {
    // 存储栈的数据
    this.data = []; // {}
    // 记录栈的数据个数（相当于数组的 length）
    this.count = 0;
  }

  // push() 出栈方法
  push(item) {
    // 1. 数组方法 push 添加
    // this.data.push(item);
    // 2. 利用数组长度
    // this.data[this.data.length] = item;
    // 3. 计数方式
    this.data[this.count] = item;
    // 入栈后 count 自增
    this.count++;
  }

  // pop() 出栈方法
  pop() {
    // 出栈的前提是栈中存在元素，应先行检测
    if (this.isEmpty()) {
      console.log(&quot;栈为空&quot;);
      return;
    }
    // 移除栈顶数据
    // 1. 数组方法 pop 移除
    // this.data.pop();
    // 2. 计数方式
    const temp = this.data[this.count - 1];
    delete this.data[--this.count];
    return temp;
  }

  // isEmpty() 检测栈是否为空
  isEmpty() {
    return this.count === 0;
  }

  // top() 用于获取栈顶值
  top() {
    if (this.isEmpty()) {
      console.log(&quot;栈为空&quot;);
      return;
    }
    return this.data[this.count - 1];
  }

  // size() 获取元素个数
  size() {
    return this.count;
  }

  // clear() 清空栈
  clear() {
    this.data = [];
    this.count = 0;
  }
}

const s = new Stack();
s.push(&quot;x&quot;);
s.push(&quot;y&quot;);
s.push(&quot;z&quot;);

// console.log(s.pop());

console.log(s.top());
console.log(s.size());

// s.clear();

console.log(s);
</code></pre>
<ul>
<li><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></li>
</ul>
<p>解题思路：</p>
<ol>
<li>在存储数据的栈外，再新建一个栈，用于存储最小值</li>
<li>入栈的时候正常存储值到 stackA 栈，如果存储值小于等于 stackB 栈顶值，stackB 也入栈</li>
<li>出栈的时候判断 stackA 栈顶值，如果 stackA 栈顶值全等 stackB 栈顶值，stackA stackB 一起出栈，否则仅 stackA 出栈</li>
</ol>
<p>阶段一</p>
<p>stackA: [2]</p>
<p>stackB: [2]</p>
<p>阶段二</p>
<p>stackA: [2, 1]</p>
<p>stackB: [2, 1]</p>
<p>阶段二</p>
<p>stackA: [2, 1, 4, 5, 6]</p>
<p>stackB: [2, 1]</p>
<p>阶段三</p>
<p>stackA: [2, 1, 4, 5, 6, 1]</p>
<p>stackB: [2, 1, 1]</p>
<p>阶段性存储最小值到 stackB 栈，在出现新的小于等于最小值之前为一个阶段</p>
<pre><code class="language-js">// 在存储数据的栈外，再新建一个栈，用于存储最小值
class MinStack {
  constructor() {
    // stackA 用于存储数据
    this.stackA = [];
    this.countA = 0;

    // stackB 用于将数据降序存储（栈顶值为最小值）
    this.stackB = [];
    this.countB = 0;
  }

  // 入栈
  push(item) {
    // stackA 正常入栈
    this.stackA[this.countA++] = item;

    // stackB 如果没有数据 直接入栈
    // 如果 item 的值 &lt;= stackB 的最小值，入栈
    if (this.countB === 0 || item &lt;= this.min()) {
      this.stackB[this.countB++] = item;
    }
  }
  // 出栈
  pop() {
    // 先进行 stackB 的检测
    if (this.top() === this.min()) {
      // 如果 stackA 的栈顶值 === stackB 的栈顶值，stackB 出栈
      delete this.stackB[--this.countB];
    }

    // stackA 出栈
    delete this.stackA[--this.countA];
  }
  // 获取栈顶值
  top() {
    return this.stackA[this.countA - 1];
  }
  // 最小值函数
  min() {
    return this.stackB[this.countB - 1];
  }
}
</code></pre>
<hr>
<ul>
<li><a href="http://www.conardli.top/docs/">http://www.conardli.top/docs/</a></li>
<li><a href="https://juejin.cn/post/6844903682455109640#heading-87">https://juejin.cn/post/6844903682455109640#heading-87</a></li>
</ul>
<h2>排序</h2>
<p>算法学习 📒 <a href="https://github.com/xiaotiandada/algorithm">repo</a></p>
<h3>快速排序</h3>
<p>这个方法比较简单也很好理解</p>
<p><strong>方法一</strong></p>
<pre><code class="language-javascript">let list = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8];
// 自定义个数
let ageLists = []
for(let i = 0; i &lt;=100; i++) {
    let id = Math.floor(Math.random() * 100 + 1)
    ageLists.push({
        id: id,
        age: Math.floor(Math.random() * 40 + 1),
        name: `学号${i}`,
        type: 'student'
    })
}

console.log(ageLists)

// 排数组
function quickSort(array) {
    if (array.length &lt;= 1) {
        return array
    }

    let target = array[0]
    let left = []
    let right = []

    for (let i = 1; i &lt; array.length; i++) {
        if (array[i] &lt; target) {
            left.push(array[i])
        } else {
            right.push(array[i])
        }
    }

    return quickSort(left).concat([target], quickSort(right))
}

console.log(quickSort(list))

// 排对象
function quickSortObj(array, key) {
    if (array.length &lt;= 1) {
        return array
    }

    let target = array[0]
    let left = []
    let right = []

    for (let i = 1; i &lt; array.length; i++) {
        if (array[i][key] &lt; target[key]) {
            left.push(array[i])
        } else {
            right.push(array[i])
        }
    }

    return quickSortObj(left, key).concat([target], quickSortObj(right, key))
}

console.time('quickSortObj')
console.log(quickSortObj(ageLists, 'id'))
console.timeEnd('quickSortObj')
</code></pre>
<p><strong>方法二</strong></p>
<pre><code class="language-javascript">// 排序数组
function quickSort(array, start, end) {
    if (end - start &lt; 1) return

    let target = array[start]
    let l = start
    let r = end

    while (l &lt; r) {
        while (l &lt; r &amp;&amp; array[r] &gt;= target) {
            r--
        }
        array[l] = array[r]
        while (l &lt; r &amp;&amp; array[l] &lt; target) {
            l++
        }
        array[r] = array[l]
    }

    array[l] = target

    quickSort22(array, start, l - 1)
    quickSort22(array, l + 1, end)
    return array
}

console.time('quickSort')
console.log(quickSort(list, 0, list.length - 1))
console.timeEnd('quickSort')

// 拍对象
function quickSort2Obj(array, start, end, key) {
    if (end - start &lt; 1) return

    let target = array[start]
    let l = start
    let r = end

    while(l &lt; r) {
        while(l &lt; r &amp;&amp; array[r][key] &gt;= target[key]) {
            r--
        }
        array[l] = array[r]

        while(l &lt; r &amp;&amp; array[l][key] &lt; target[key]) [
            l++
        ]
        array[r] = array[l]
    }

    array[l] = target

    quickSort2Obj(array, start, l - 1, key)
    quickSort2Obj(array, l + 1, end, key)

    return array
}

console.time('quickSort2Obj')
console.log(quickSort2Obj(ageLists, 0, ageLists.length - 1, 'id'))
console.timeEnd('quickSort2Obj')
</code></pre>
<p>这个对比方法一难点, 一下不容易理解</p>
<p>经过测试 少量的数据 方法二有时候比方法一要慢(10 - 100), 但是数据足够大的时候 方法二比方法一就要快很多(10000左右)</p>
<h2>归并排序</h2>
<pre><code class="language-javascript">let list = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8];

function mergeSort(array) {
  if (array.length &lt; 2) {
    return array
  }

  let mid = Math.floor(array.length / 2)
  let front = array.slice(0, mid)
  let end = array.slice(mid)

  return merge(mergeSort(front), mergeSort(end))
}

function merge(front, end) {
  let temp = []

  while (front.length &amp;&amp; end.length) {
    if (front[0] &lt; end[0] ){
      temp.push(front.shift())
    } else {
      temp.push(end.shift())
    }
  }

  while(front.length) {
    temp.push(front.shift())
  }
  while(end.length) {
    temp.push(end.shift())
  }
  return temp
}

console.time()
console.log(mergeSort(list))
console.timeEnd()
</code></pre>
<h2>选择排序</h2>
<pre><code class="language-javascript">let list = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8];

function selectionSort(array) {
  for (let i = 0; i &lt; array.length - 1; i++) {
    let minIndex = i
    for (let j = i + 1; j &lt; array.length; j++) {
      if (array[j] &lt; array[minIndex]) {
        minIndex = j
      }
    }
    [array[minIndex], array[i]] = [array[i], array[minIndex]]
  }
  return array
}

console.time()
console.log(selectionSort(list))
console.timeEnd()
</code></pre>
<h2>插入排序</h2>
<pre><code class="language-javascript">let list = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8];


function insertSort(array) {
  for (let i = 1; i &lt; array.length; i++) {
    let target = i
    for (let j = i - 1; j &gt;= 0; j--) {
      if (array[target] &lt; array[j]) {
        [array[target], array[j]] = [array[j], array[target]]
        target = j
      } else {
        break
      }
    }
  }
  return array
}


console.time()
console.log(insertSort(list))
console.timeEnd()
</code></pre>
<h2>冒泡排序</h2>
<pre><code class="language-javascript">let list = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8];

function bubbleSort(array) {
  for (let i = 0; i &lt; array.length; i++) {
    let complate = true
    for (let j = 0; j &lt; array.length - 1 - i; j++) {
      console.log(1, array.length - 1 - i)
      if (array[j] &gt; array[j + 1]) {
        [array[j], array[j + 1]] = [array[j + 1], array[j]]
        complate = false
      }
    }
    if (complate) {
      break
    }
  }
  return array
}

console.time()
console.log(bubbleSort(list))
console.timeEnd()
</code></pre>
<h2>堆排序</h2>
<pre><code class="language-javascript">let list = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8];

function heapSort(array) {
  createHeap(array)
  console.log('array', array)
  // 交换第一个和最后一个元素，然后重新调整大顶堆
  for (let i = array.length - 1; i &gt; 0; i--) {
    [array[i], array[0]] = [array[0], array[i]]
    adJust(array, 0, i)
  }
  return array
}

// 构建大顶堆，从第一个非叶子节点开始，进行下沉操作
function createHeap(array) {
  const len = array.length
  const start = parseInt(len / 2) - 1
  for (let i = start; i &gt;= 0; i--) {
    adJust(array, i, len)
  }
}
// 将第target个元素进行下沉，孩子节点有比他大的就下沉
function adJust(array, target, len) {
  for (let i = 2 * target + 1; i &lt; len; i= 2 * i + 1) {
    // 找到孩子节点中最大的
    if (i + 1 &lt; len &amp;&amp; array[i + 1] &gt; array[i]) {
      i = i + 1
    }
    // 下沉
    if (array[i] &gt; array[target]) {
      [array[i] ,array[target]] = [array[target], array[i]]
      target = i
    } else {
      break
    }
  }
}

console.time()
console.log(heapSort(list))
console.timeEnd()
</code></pre>
<h3>shuffle</h3>
<p><a href="https://oldj.net/article/2017/01/23/shuffle-an-array-in-javascript/">https://oldj.net/article/2017/01/23/shuffle-an-array-in-javascript/</a></p>
<p><a href="https://github.com/lodash/lodash/blob/b0980a90fc83bc92e040f905ebed8196f895949c/.internal/shuffleSelf.js">https://github.com/lodash/lodash/blob/b0980a90fc83bc92e040f905ebed8196f895949c/.internal/shuffleSelf.js</a></p>
<p><a href="https://bost.ocks.org/mike/shuffle/compare.html">https://bost.ocks.org/mike/shuffle/compare.html</a></p>
<pre><code>-- To shuffle an array a of n elements (indices 0..n-1):
for i from n−1 downto 1 do
    j ← random integer such that 0 ≤ j ≤ i
    exchange a[j] and a[i]
</code></pre>
<pre><code class="language-javascript">let arr = [1,2,3,4,5,6,7,8,9,11]

const shuffle = (arr) =&gt; {
  let i = arr.length
  while (i) {
    let j = Math.floor(Math.random() * i--);
    [ arr[j], arr[i] ] = [ arr[i], arr[j] ]
  }
}

shuffle(arr)
console.log(arr)

// [4, 9, 1, 2, 7, 6, 5, 3, 8, 11]
</code></pre>
<p><strong>Lodash</strong></p>
<pre><code class="language-javascript">_.shuffle([1,2,3,4,5,6,7,8,9,0,10,11])

// (12) [5, 0, 3, 6, 11, 7, 8, 4, 9, 10, 1, 2]
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[toString(36)]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/47</link>
            <guid>https://github.com/xiaotiandada/blog/issues/47</guid>
            <pubDate>Tue, 19 Jan 2021 06:35:32 GMT</pubDate>
            <description><![CDATA[<p>2020-05-29 23:02:07</p>
<h2>序</h2>
<p>在某个开源项目里面发现一个随机生成 ID 的方法, 于是好奇的搜了搜, 发现一篇写的不错的文章!!!</p>
<!-- more -->
<p><a href="http://dongjunhui.com/archives/98/">文章地址</a></p>
<h2>方法源码</h2>
<pre><code class="language-javascript">Math.random().toString(36).substr(2, 9);
</code></pre>
<p>这个方法会返回一串随机的 ID <code>adp1r8xh7</code> 类似于这样的</p>
<h2>HackMD</h2>
<p>在 HackMD 里面(一款很好用的在线编辑工具) 在上传的时候会有个占位 Tag</p>
<pre><code>![Uploading file..._unv0ukdwd]()
</code></pre>
<p><code>_unv0ukdwd</code> 这个 ID 就是随机生成的!!!</p>
<h2>Ant Design</h2>
<p>分享给群友的时候, 群友提到 antd 里面也用到了了</p>
<p><a href="https://ant.design/components/select-cn/#header">Select选择器</a></p>
<pre><code class="language-javascript">const children = [];
for (let i = 10; i &lt; 36; i++) {
  children.push(&lt;Option key={i.toString(36) + i}&gt;{i.toString(36) + i}&lt;/Option&gt;);
}
</code></pre>
<p>因为是从 10 开始循环的 所以结果是从 A-Z</p>
<h2>测试</h2>
<pre><code class="language-javascript">for (let i = 0; i &lt; 36; i++) {
  console.log(i, i.toString(36))
}

0 &quot;0&quot;
1 &quot;1&quot;
2 &quot;2&quot;
3 &quot;3&quot;
4 &quot;4&quot;
5 &quot;5&quot;
6 &quot;6&quot;
7 &quot;7&quot;
8 &quot;8&quot;
9 &quot;9&quot;
10 &quot;a&quot;
11 &quot;b&quot;
12 &quot;c&quot;
13 &quot;d&quot;
14 &quot;e&quot;
15 &quot;f&quot;
16 &quot;g&quot;
17 &quot;h&quot;
18 &quot;i&quot;
19 &quot;j&quot;
20 &quot;k&quot;
21 &quot;l&quot;
22 &quot;m&quot;
23 &quot;n&quot;
24 &quot;o&quot;
25 &quot;p&quot;
26 &quot;q&quot;
27 &quot;r&quot;
28 &quot;s&quot;
29 &quot;t&quot;
30 &quot;u&quot;
31 &quot;v&quot;
32 &quot;w&quot;
33 &quot;x&quot;
34 &quot;y&quot;
35 &quot;z&quot;
undefined
</code></pre>
<p>上面是测试结果</p>
<p>0-9 输出了 0-9</p>
<p>10-35 输出了 a-z</p>
<p>36 为 undefined</p>
<p><code>如果转换的基数大于10，则会**使用字母**来表示大于9的数字，比如基数为16的情况，则使用a到f的字母来表示10到15。</code> 复制文章的文字</p>
<h2>End</h2>
<p>在一些简单的随机数生成或者demo展示的时候这个方法应该还是挺好用的</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Ethereum contract]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/46</link>
            <guid>https://github.com/xiaotiandada/blog/issues/46</guid>
            <pubDate>Mon, 13 Jun 2022 13:54:05 GMT</pubDate>
            <description><![CDATA[<h1>Ethereum</h1>
<p>Ethereum study notes</p>
<p>学习资料</p>
<ul>
<li><a href="https://ethereum.org/">https://ethereum.org/</a></li>
<li><a href="https://solidity.readthedocs.io/en/v0.6.6/introduction-to-smart-contracts.html">https://solidity.readthedocs.io/en/v0.6.6/introduction-to-smart-contracts.html</a></li>
<li><a href="https://www.qikegu.com/docs/4733">https://www.qikegu.com/docs/4733</a></li>
<li><a href="https://www.trufflesuite.com/tutorials/pet-shop">https://www.trufflesuite.com/tutorials/pet-shop</a></li>
<li></li>
<li><a href="https://docs.openzeppelin.com/learn/developing-smart-contracts">https://docs.openzeppelin.com/learn/developing-smart-contracts</a></li>
</ul>
<p><strong>cryptozombies</strong> 这个教程写的挺好的!!!</p>
<ul>
<li><a href="https://cryptozombies.io/">https://cryptozombies.io/</a></li>
<li><a href="https://github.com/loomnetwork/cryptozombies-lesson-code">https://github.com/loomnetwork/cryptozombies-lesson-code</a></li>
</ul>
<p>简易的拍卖 rinkeby 测试网</p>
<ul>
<li><a href="https://xiaotiandada.github.io/ethereum/auction/client/">https://xiaotiandada.github.io/ethereum/auction/client/</a></li>
</ul>
<h2>总结(一)</h2>
<h3>配置本地的开发环境以及遇到的坑</h3>
<p>首先看看这里 <a href="https://ethereum.org/">https://ethereum.org/</a></p>
<p>然后开发可以参照这篇文章进行学习和实战 <a href="https://www.qikegu.com/docs/4733">https://www.qikegu.com/docs/4733</a></p>
<p>在<code>truffle init</code>的时候遇到一个connect x.x.x.x:443的错误</p>
<p>官方给出来的答复是 GFW <code>It's all GFW's fault, when i crossed GFW, everything work.</code> <a href="https://github.com/trufflesuite/truffle/issues/2995">issues/2995</a></p>
<p>我目前的解决方案是直接clone <a href="https://github.com/truffle-box/bare-box">repo</a>然后一些基本的目录都有了,然后在继续参考教程跑流程</p>
<h2>总结(二)</h2>
<h3>本地部署多个项目的合约无法成功</h3>
<p>本地执行 <code>truffle compile</code> 显示是成功的</p>
<p>执行 <code>truffle migrate</code> 显示是最新的</p>
<p>但是实际在 <code>truffle console</code> || <code>truffle test</code> 里面调用时错误的</p>
<p>解决方案是 <code>truffle migrate --reset</code> 增加 <code>--reset</code> !!!</p>
<p>看到一篇文章有写到这个问题 <a href="https://www.jianshu.com/p/42479ede6730">https://www.jianshu.com/p/42479ede6730</a></p>
<blockquote>
<p>这个命令会执行所有migrations目录下的js文件。如果之前执行过truffle migrate命令，再次执行，只会部署新的js文件，如果没有新的js文件，不会起任何作用。如果使用--reset参数，则会重新的执行所有脚本的部署。truffle migrate --reset。</p>
</blockquote>
<h2>总结(二)</h2>
<h3>简单的计数器合约</h3>
<h3>初始化项目</h3>
<p>因为本地<code>truffle init</code>有问题, 所以我这里采取<code>clone</code>的方式init, 具体步骤参考上文</p>
<pre><code class="language-bash">git clone xxxxxx
</code></pre>
<p>然后替换名字</p>
<pre><code class="language-bash">mv xxx counter
</code></pre>
<p>然后喜欢性的npm</p>
<pre><code class="language-bash">npm init
</code></pre>
<h3>新建计数器合约</h3>
<p>在<code>contracts</code>目录新建</p>
<pre><code class="language-bash">touch Counter.sol
pragma solidity &gt;=0.4.21 &lt;0.7.0;

// 声明
contract Counter {
  // 声明计数器变量
  uint256 counter;

  // 部署时调用 初始化
  constructor() public {
    counter = 0;
  }

  // 增加方法
  function increase() public {
    counter += 1;
  }

  // 返回counter uint256是类型
  function get() public view returns(uint256) {
    return counter;
  }

}
</code></pre>
<h3>编译、部署、测试合约</h3>
<p>部署的时候需要在<code>migrations</code>目录新建<code>2_deploy_contracts.js</code>前面需要加上序号</p>
<p>执行需要 具体文档有写 <a href="https://www.qikegu.com/docs/4798">https://www.qikegu.com/docs/4798</a></p>
<pre><code class="language-bash">truffle compile

truffle migrate

truffle test
</code></pre>
<p>部署过程基本都大同小异(略过 不重复写了), 可以参考上文的资料进行部署</p>
<hr>
<p>⬆️    已落后</p>
<hr>
<p>使用 (Hardhat)(<a href="https://hardhat.org/guides/create-task.html">https://hardhat.org/guides/create-task.html</a>)</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[svg stroke-dasharray、stroke-dasharray]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/45</link>
            <guid>https://github.com/xiaotiandada/blog/issues/45</guid>
            <pubDate>Tue, 19 Jan 2021 06:34:31 GMT</pubDate>
            <description><![CDATA[<p>2020-03-15 00:45:54</p>
<p>svg stroke-dasharray、stroke-dasharray的学习 <a href="https://jdrd.jd.com/home/scene.html">京东零售设计服务平台</a>在这里看到一个按钮 里面用到了这两个属性 于是找了资料学习一下</p>
<!-- more -->
<h2>资料</h2>
<p><a href="https://www.cnblogs.com/daisygogogo/p/11044353.html">SVG学习之stroke-dasharray 和 stroke-dashoffset 详解</a></p>
<blockquote>
<p>这片文章我觉得讲得很不错 👍</p>
</blockquote>
<iframe height="265" style="width: 100%;" scrolling="no" title="svg stroke" src="https://codepen.io/xiaotiandada/embed/RwPMmbJ?height=265&theme-id=dark&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/xiaotiandada/pen/RwPMmbJ'>svg stroke</a> by xiaotiandada
  (<a href='https://codepen.io/xiaotiandada'>@xiaotiandada</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<pre><code class="language-html">  &lt;svg id=&quot;line&quot;&gt;
    &lt;line x1=&quot;30&quot; y1=&quot;30&quot; x2=&quot;300&quot; y2=&quot;30&quot; stroke=&quot;red&quot; stroke-width=&quot;20&quot; stroke-dasharray=&quot;300&quot;&gt;&lt;/line&gt;
  &lt;/svg&gt;

  &lt;svg id=&quot;circle&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;
    &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;50&quot; stroke=&quot;red&quot; stroke-width=&quot;5&quot; fill=&quot;green&quot;&gt;&lt;/circle &gt;
  &lt;/svg&gt;

  &lt;svg id=&quot;box&quot;&gt;
    &lt;polyline points=&quot;0,20 0,0, 100,0, 100,20&quot; stroke=&quot;red&quot; stroke-width=&quot;1&quot;&gt;&lt;/polyline&gt;
    &lt;polyline points=&quot;0,20 0,40, 100,40, 100,0&quot; stroke=&quot;red&quot; stroke-width=&quot;1&quot;&gt;&lt;/polyline&gt;
  &lt;/svg&gt;
</code></pre>
<pre><code class="language-css">    #line {
      stroke-dashoffset: 300
    }
    #line:hover {
      stroke-dashoffset: 0;
    }
    #line line {
      transition: all .3s;
    }


    #circle circle {
      transition: all .3s;
      stroke-dasharray: 314;
      stroke-dashoffset: 314;
    }


    #circle:hover circle {
      stroke-dashoffset: 0;
    }


    #box polyline {
      fill: transparent;
      stroke-dasharray: 360;
      stroke-dashoffset: 360;
      transition: all .3s;
    }
    #box:hover polyline {
      stroke-dashoffset: 0;
    }
</code></pre>
<p>下面是jd的按钮style</p>
<p><img src="https://i.loli.net/2020/03/15/NF6PYDKMVjc94wQ.png" alt=""></p>
<p><strong>鼠标经过</strong></p>
<p><img src="https://i.loli.net/2020/03/15/rCfWLetIsdH7Ax3.png" alt=""></p>
<blockquote>
<p>我在这个<a href="https://github.com/xiaotiandada/cui">cui</a>项目里面也写了一个这个效果的小组件 具体可以自己查看 🍑</p>
</blockquote>
]]></description>
        </item>
        <item>
            <title><![CDATA[设计模式]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/44</link>
            <guid>https://github.com/xiaotiandada/blog/issues/44</guid>
            <pubDate>Tue, 19 Jan 2021 06:34:06 GMT</pubDate>
            <description><![CDATA[<p>2020-02-26 23:57:00</p>
<p>第一次学习设计模式 <a href="https://github.com/xiaotiandada/javaScript-design-patterns">repo 所有的代码都在这儿啦!</a></p>
<!-- more --> 
<h2>工厂模式</h2>
<p><strong>相关资料:</strong></p>
<p><a href="https://juejin.im/post/5c984610e51d45656702a785">JavaScript设计模式总结</a></p>
<p><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html">js设计模式-工厂模式</a></p>
<p><strong>创建三个角色然后随机决斗⚔️</strong></p>
<pre><code class="language-js">console.log('工厂模式');

// 攻击力1-100
const attackPower = () =&gt; Math.floor(Math.random() * 100 + 1)

// 战士
class Warrior {
  constructor() {
    this.occupation = '战士'
    this.skill = '单一狂砍'
    this.blood = 100
    this.hit = attackPower()
    // other
  }
}

// 法师
class Mage {
  constructor() {
    this.occupation = '法师'
    this.skill = '集体冰冻'
    this.blood = 100
    this.hit = attackPower()
  }
}

// 射手
class Archer {
  constructor() {
    this.occupation = '射手'
    this.skill = '全局轰炸'
    this.blood = 100
    this.hit = attackPower()
  }
}

// 工厂对象
// class、function、object
class RoleFactory {
  constructor() {}
  createRole(role) {
    let roles = {
      Warrior: Warrior,
      Mage: Mage,
      Archer: Archer
    }

    const Character = roles[role]
    return role ? new Character() : new Warrior()

  }
}

// 创建角色
let roleFactory = new RoleFactory
let warrior = roleFactory.createRole('Warrior')
let mage = roleFactory.createRole('Mage')
let archer = roleFactory.createRole('Archer')

console.log('warrior:', warrior);
console.log('mage:', mage);
console.log('archer:', archer);

console.log('----------')

// 随机角色
const randomRole = (data, number) =&gt; {
  if (!data || !data.length || !number) return

  let randomRole = []

  for (let i = 0; i &lt; data.length; i++) {
    let sub = Math.floor(Math.random() * data.length )
    randomRole.push(...data.splice(sub, 1))
  }
  return randomRole
}

// 战斗
const duel = roles =&gt; {
  // 最强角色
  let maxRole = null
  // 最高攻击力
  let maxHit = -1
  roles.map(item =&gt; {
    console.log(item)
    // 如果攻击力大于最大攻击力
    if (item.hit &gt; maxHit) {
      // 设置当前角色
      maxRole = item
      // 攻击力也替换
      maxHit = item.hit
    } else if (item.hit === maxHit) {
      // 清空
      maxRole = null
      maxHit = -1
    }

  })

  return maxRole
}

const compose = (...fn) =&gt; fn.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))

let winner = compose(duel, randomRole)([warrior, mage, archer], 2)

if (winner) {
  console.log(`胜利者是: ${winner.occupation}, 他的技能是: ${winner.skill}, 攻击力: ${winner.hit}`)
} else {
  console.log(`这是平局`)
}
</code></pre>
<p><strong>输出</strong></p>
<pre><code class="language-js">工厂模式
warrior: Warrior { occupation: '战士', skill: '单一狂砍', blood: 100, hit: 1 }
mage: Mage { occupation: '法师', skill: '集体冰冻', blood: 100, hit: 39 }
archer: Archer { occupation: '射手', skill: '全局轰炸', blood: 100, hit: 33 }
----------
Warrior { occupation: '战士', skill: '单一狂砍', blood: 100, hit: 1 }
Mage { occupation: '法师', skill: '集体冰冻', blood: 100, hit: 39 }
胜利者是: 法师, 他的技能是: 集体冰冻, 攻击力: 39
</code></pre>
<p>因为<strong>第一次</strong>学习 还不太知道具体的<strong>优点和好处</strong> 也没办法<strong>口喷</strong> 所以暂时留个坑给自己 下次更加了解之后回来<strong>填坑</strong> 🍑</p>
<h2>单例模式</h2>
<p><a href="https://juejin.im/post/5c984610e51d45656702a785">https://juejin.im/post/5c984610e51d45656702a785</a></p>
<p><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</a></p>
<blockquote>
<p>定义：单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。 -- 复制的</p>
</blockquote>
<p>我的理解为一个类仅有一个实例, 并且全局访问都是相同的实例</p>
<p>建议先看完上面文章的单例模块, 我觉得他们总结得比我要好</p>
<pre><code class="language-javascript">// 登录框
/**
* 我这里单击按钮🔘显示登录框, 并且自身设置关闭事件 只是隐藏
* 在下一次显示登录框的时候不会创建 而是直接展示 因为单例模式
* 登录框已经创建了 所以直接返回了对象 然后展示
*/
const loginBox = (function(){
  let div
  return function() {
    if (!div) {
      div = document.createElement('div')
      div.onclick = function() {
        div.style.display = 'none'
      }
      div.innerHTML = '登录 hhhh (单击我隐藏)'
      document.body.appendChild(div)
    }
    return div
  }
})()

document.querySelector('#btn').onclick = function() {
  let loginbox = loginBox()
  loginbox.style.display = 'block'
}
</code></pre>
<p>这只是一个简单的示范... 🍑</p>
<h2>装饰器模式</h2>
<p><a href="https://juejin.im/post/5c984610e51d45656702a785">https://juejin.im/post/5c984610e51d45656702a785</a></p>
<blockquote>
<p>在不改变对象自身的基础上，动态的给某个对象添加新的功能，同时又不改变其接口</p>
</blockquote>
<p><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.html">https://fanerge.github.io/2017/js设计模式-装饰者模式.html</a></p>
<blockquote>
<p>定义：装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。</p>
<p>这样给对象动态的增加职责的方式就没有改变对象自身，一个对象放入另一个对象就形成了一条装饰链（一个聚合对象）， 而上面的shot和track也就是装饰者、装饰函数 ，当函数执行时，会把请求转给链中的下一个对象。</p>
</blockquote>
<pre><code class="language-javascript">{
  class Plane {
    fire() {
      console.log('发射普通子弹')
    }
  }

  class Missile {
    plane: any
    constructor(plane) {
      this.plane = plane
    }

    fire () {
      this.plane.fire()
      console.log('发射导弹')
    }
  }

  let plane = new Plane()
  plane = new Missile(plane)
  console.log(plane.fire())
}
</code></pre>
<pre><code class="language-javascript">// 利用AOP给函数动态添加功能，即Function的after或者before
{
  let func = function() {
    console.log('2')
  }

  Function.prototype.before = function(fn) {
    const _this = this
    return function() {
      fn.apply(this, arguments)
      return _this.apply(this, arguments)
    }
  }
  Function.prototype.after = function(fn) {
    const _this = this
    return function() {
      const ret = _this.apply(this, arguments)
      fn.apply(this, arguments)
      return ret
    }
  }
  
  func = func.before(function() {
    console.log(1)
  }).after(() =&gt; {
    console.log(3)
  });
  
  func()
}
</code></pre>
<pre><code class="language-javascript">
{
  // 利用装饰器
  function func1() {
    console.log(1)
  }
  function func2() {
    console.log(2)
  }
  class Func {
    @func2
    @func1
    init() {
      console.log(3)
    }
  }

  let func = new Func()
  func.init()

}
</code></pre>
<pre><code class="language-javascript">{
  // 封装成函数
  const before = function (fn, before) {
    return function() {
      before.apply(this, arguments)
      return fn.apply(this, arguments)
    }
  }

  const after = function(fn, after) {
    return function() {
      const ret = fn.apply(this, arguments)
      after.apply(this, arguments)
      return ret
    }
  }

  function func(x) {
    console.log(x)
  }

  function func1(2) {
    console.log(1)
  }


  function func2() {
    console.log(2)
  }


  before(func1, func2)()
  after(func1, func2)()
}
</code></pre>
<p>核心就在<code>after</code> <code>before</code> 了</p>
<pre><code class="language-javascript">{
 // ...
 function handwashing() {
   console.log('洗手')
 }

 function drink() {
   console.log('喝水')
 }

 function eat() {
   console.log('吃饭')
 }


 before(eat, handwashing)()
 after(eat, drink)()
 
 // 吃饭前洗手
 // 吃饭后喝水
}
</code></pre>
<p>比较基础的演示了 :)</p>
<h2>代理模式</h2>
<blockquote>
<p>为一个对象提供一个代用品或占位符，以便控制对它的访问。</p>
</blockquote>
<p><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html">https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html</a></p>
<pre><code class="language-javascript">// 缓存代理
const mult = function() {
  let a = 1

  for (let i = 0; i &lt; arguments.length; i++) {
    a *= arguments[i]
  }

  return a
}


const plus = function() {
  let a = 0

  for (let i = 0; i &lt; arguments.length; i++) {
    a += arguments[i]
  }

  return a
}


const createProxyFactory = function(fn) {
  let cache = {} // 保存计算结果
  return function() {
    let args = Array.from(arguments).join(',')
    if (args in cache) {
      return cache[args]
    } else {
      return cache[args] = fn.apply(this, arguments)
    }
  }
}


let proxyMult = createProxyFactory(mult)
let proxyPlus = createProxyFactory(plus)

console.log(proxyMult(1,2,3,4))
console.log(proxyPlus(1,2,3,4))
</code></pre>
<blockquote>
<p>这里每次进行同类的计算时（乘法和加法两类），先判断缓存对象cache中是否存在该参数连接成的字符串作为key的属性。
如果有，则直接从cache中读取，否则就进行计算并保存其结果。</p>
</blockquote>
<pre><code class="language-javascript">// 虚拟代理

const sleep = time =&gt; new Promise(resolve =&gt; setTimeout(resolve, time))

const imgFunc = (function() {
  let imgNode = document.createElement('img')
  document.body.appendChild(imgNode)

  return {
    setSrc(src) {
      imgNode.src = src
    }
  }
})()


const proxyImage = (function() {
  const img = new Image()
  img.onload = function() {
    imgFunc.setSrc(this.src)
  }

  return {
    setSrc(src) {
      imgFunc.setSrc('https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=766379944,3048822499&amp;fm=26&amp;gp=0.jpg')
      // 模拟加载时间
      setTimeout(() =&gt; {
        img.src = src
      }, 2000)
    }
  }
})()

proxyImage.setSrc('http://t8.baidu.com/it/u=1484500186,1503043093&amp;fm=79&amp;app=86&amp;f=JPEG?w=1280&amp;h=853')
</code></pre>
<blockquote>
<p>图片懒加载的方式：先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。</p>
</blockquote>
<h2>策略模式</h2>
<p><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html">https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html</a></p>
<blockquote>
<p>定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
</blockquote>
<pre><code class="language-javascript">const strategy = {
  a(salary) {
     return salary * 4
  },
  b(salary) {
    return salary * 3
  },
  c(salary) {
    return salary * 2
  }
}


Object.freeze(strategy)


const returnMoney = (type, salary) =&gt; {
  return strategy[type](salary)
}

console.log(returnMoney('a', 1000))
console.log(returnMoney('b', 3000))
console.log(returnMoney('c', 4000))
</code></pre>
<p>简单的使用</p>
<p>ps: 策略模式指的是定义一系列的算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，
实际就是将算法的使用和实现分离出来；</p>
<p><strong>表单验证</strong></p>
<p>我在原有的code上加了一个方法(错误展示, 比较基础所以很多地方没有考虑到)</p>
<iframe height="265" style="width: 100%;" scrolling="no" title="策略模式" src="https://codepen.io/xiaotiandada/embed/xxZOBvG?height=265&theme-id=dark&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/xiaotiandada/pen/xxZOBvG'>策略模式</a> by xiaotiandada
  (<a href='https://codepen.io/xiaotiandada'>@xiaotiandada</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<pre><code class="language-html">&lt;!-- ... --&gt;
&lt;style&gt;
  .error-msg {
    color: red;
    font-size: 14px;
  }
&lt;/style&gt;

&lt;form id=&quot;registerForm&quot;&gt;
  &lt;div&gt;
    &lt;label for=&quot;&quot;&gt;用户名&lt;/label&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label for=&quot;&quot;&gt;密码&lt;/label&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label for=&quot;&quot;&gt;手机号码&lt;/label&gt;
    &lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt;
  &lt;/div&gt;
  &lt;button&gt;submit&lt;/button&gt;
&lt;/form&gt;
&lt;!-- ... --&gt;
</code></pre>
<pre><code class="language-js">// 这里我们实现一组策略类封装具体的验证规则
const strategyForm = {
	// 是否为空
	isNotEmpty (value, errorMsg){
		if (value === '') {
			return errorMsg;
		}
	},
	// 最小长度
	minLength (value, length, errorMsg){
		if (value.length &lt; length) {
			return errorMsg;
		}
	},
	// 手机号码格式
	mobileFormat (value,errorMsg){
		if(!/(^1[3|5|8][0-9]{9}$)/.test(value)) {
			return errorMsg;
		}
	}
};
Object.freeze(strategyForm);


const Validator = function() {
  this.cache = []
}

Validator.prototype.add = function(dom, rules) {
	let slef = this
	// 添加错误信息提示
	const addErrorMsg = (msg, dom, errorMsg) =&gt; {
		// 如果有错误信息
		if (msg) {
			// 如果已经有了错误提示
			let errorMsgDom = dom.parentNode.querySelector('.error-msg')
			if (errorMsgDom) {
				errorMsgDom.innerHTML = errorMsg
			} else {
				// 没有提示创建
				let errorHtml = document.createElement('span')
				errorHtml.className = 'error-msg'
				errorHtml.innerHTML = errorMsg
				dom.parentNode.appendChild(errorHtml)
			}
		} else {
			// 没有错误提示
			// 如果有错误提示但是tag还存在则清除
			let errorMsgDom = dom.parentNode.querySelector('.error-msg')
			if (errorMsgDom) {
				errorMsgDom.remove()
			}
		}
	}
	for(let i = 0, rule; rule = rules[i++]; ) {
		(function(rule) {
			let strategyArr = rule.strategy.split(':')
			let errorMsg = rule.errorMsg

			slef.cache.push(function() {
				let strategy = strategyArr.shift() // 取第一个 策略名
				strategyArr.unshift(dom.value)
				strategyArr.push(errorMsg)
				let msg = strategyForm[strategy].apply(dom, strategyArr)
				addErrorMsg(msg, dom, errorMsg)
				return msg
			})

		})(rule)
	}
}

Validator.prototype.start = function() {
	for (let i = 0, validatorFunc; validatorFunc = this.cache[i++];) {
		let msg = validatorFunc()
		if (msg) return msg
	}
}

let registerForm = document.getElementById('registerForm')

let validateFunc = function() {
	let validator = new Validator()
	validator.add(registerForm.username, [
		{ strategy: 'isNotEmpty', errorMsg: '用户名不能为空' },
		{ strategy: 'minLength:6', errorMsg: '用户名长度不能小于6位' }
	])
	validator.add(registerForm.password,[
		{strategy: 'minLength:6',errorMsg:'密码长度不能小于6位'},
	]);
	validator.add(registerForm.phoneNumber,[
		{strategy: 'mobileFormat',errorMsg:'手机号格式不正确'},
	]);
	let errorMsg = validator.start()
	return errorMsg
}

registerForm.onsubmit = function() {
	let errorMsg = validateFunc()
	if (errorMsg) {
		console.log(errorMsg)
	} else {
		console.log('done')
	}
	return false
}
</code></pre>
<h2>中介者模式</h2>
<p><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html">https://fanerge.github.io/2017/js设计模式-中介者模式.html</a></p>
<p>定义：中介者模式的作用就是解除对象与对象之间的紧耦合关系</p>
<pre><code class="language-javascript">// MVC 模式
let M = {}
let V = {}
let C = {}

M.data = 'Hello World'
V.render = (M) =&gt; {
    // alert(M.data)
    document.body.append(document.createElement('p').innerHTML = M.data)
}
C.handleOnload = () =&gt; {
    V.render(M)
}


window.onload = C.handleOnload
</code></pre>
<iframe height="265" style="width: 100%;" scrolling="no" title="中介者模式" src="https://codepen.io/xiaotiandada/embed/abdBOvp?height=265&theme-id=dark&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/xiaotiandada/pen/abdBOvp'>中介者模式</a> by xiaotiandada
  (<a href='https://codepen.io/xiaotiandada'>@xiaotiandada</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<pre><code class="language-html">&lt;form action=&quot;#&quot; id=&quot;selectPhone&quot;&gt;
  &lt;div&gt;
    &lt;label for=&quot;&quot;&gt;选择手机颜色&lt;/label&gt;
    &lt;select name=&quot;&quot; id=&quot;colorSelect&quot;&gt;
      &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt;
      &lt;option value=&quot;red&quot;&gt;红色&lt;/option&gt;
      &lt;option value=&quot;blue&quot;&gt;蓝色&lt;/option&gt;
    &lt;/select&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label for=&quot;&quot;&gt;选择内存&lt;/label&gt;
    &lt;select name=&quot;&quot; id=&quot;memorySelect&quot;&gt;
      &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt;
      &lt;option value=&quot;16G&quot;&gt;16G&lt;/option&gt;
      &lt;option value=&quot;32G&quot;&gt;32G&lt;/option&gt;
    &lt;/select&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;label for=&quot;&quot;&gt;输入购买数量&lt;/label&gt;
    &lt;input type=&quot;number&quot; min=&quot;0&quot; id=&quot;numberInput&quot;&gt;
  &lt;/div&gt;
  &lt;div&gt;
    您选择了颜色: &lt;div id=&quot;colorInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt;
    您选择了内存: &lt;div id=&quot;memoryInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt;
    您输入了数量: &lt;div id=&quot;numberInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt;
    &lt;button id=&quot;nextBtn&quot; disabled=&quot;true&quot;&gt;请选择手机颜色和购买数量&lt;/button&gt;
  &lt;/div&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="language-javascript">let goods = {
   &quot;red|32G&quot;: 3,
	&quot;red|16G&quot;: 0,
	&quot;blue|32G&quot;: 1,
	&quot;blue|16G&quot;: 6
}

// 获得所有节点的引用，以便对其进行操作（中介者必许获得对其他对象的引用）
let colorSelect = document.getElementById( 'colorSelect' )
let memorySelect = document.getElementById( 'memorySelect' )
let numberInput = document.getElementById( 'numberInput' )

let colorInfo = document.getElementById( 'colorInfo' )
let memoryInfo = document.getElementById( 'memoryInfo' )
let numberInfo = document.getElementById( 'numberInfo' )
let nextBtn = document.getElementById( 'nextBtn' )

let mediator = (function() {
    return {
        changed(obj) {
            var color = colorSelect.value // 颜色
            let memory = memorySelect.value// 内存
            let number = numberInput.value // 数量

            if (obj === colorSelect) {
                colorInfo.innerHTML = color
            } else if (obj === memorySelect) {
                memoryInfo.innerHTML = memory
            } else if (obj === numberInput) {
                numberInfo.innerHTML = number
            } else {
                console.log(obj)
            }

            if (!color) {
                nextBtn.disabled = true
                nextBtn.innerHTML = '请选择手机颜色'
                return
            }

            if (!memory) {
                nextBtn.disabled = true
                nextBtn.innerHTML = '请选择内存大小'
                return
            }

            if (((number - 0) | 0 !== number - 0)) {
                nextBtn.disabled = true
                nextBtn.innerHTML = '请输入正确的购买数量'
                return
            }

            nextBtn.disabled = false;
			nextBtn.innerHTML = '放入购物车';

        }
    }
})()


// 与中介者联系起来，事件函数
colorSelect.onchange = function(){
	mediator.changed( this );
};
memorySelect.onchange = function(){
	mediator.changed( this );
};
numberInput.onchange = function(){
	mediator.changed( this );
};
</code></pre>
<h2>发布订阅模式</h2>
<pre><code class="language-js">// https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html

// 对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。

const Event = (function() {
  // 缓存列表
  let list = {}

  // 监听函数
  const listen = function(key, fn) {
    if (!list[key]) {
      list[key] = []
    }
    list[key].push(fn)
  }

  // 触发监听
  const trigger = function() {
    let key = Array.prototype.shift.call(arguments)
    let fns = list[key]

    if (!fns || fns.length === 0) {
      return false
    }

    for (let i = 0, fn; fn = fns[i++];) {
      fn.apply(this, arguments)
    }
  }
  // 移除监听函数
  const remove = function(key, fn) {
    let fns = list[key]

    if (!fns) {
      return false
    }

    if (!fn) {
      fns &amp;&amp; (fns.length = 0)
    } else {
      for (let i = fns.length - 1; i &gt;= 0; i--) {
        let _fn = fns[i]
        if (_fn === fn) {
          fns.splice(i, 1)
        }
      }
    }
  }

  return {
    listen,
    trigger,
    remove
  }
})()


function d1() {
  console.log('d11111')
}

function d2() {
  console.log('d22222')
}

function d3() {
  console.log('d33333')
}

Event.listen('color', d1)
Event.listen('color', d2)
Event.listen('color', d3)


Event.listen('size', d1)
Event.listen('size', d2)
Event.remove('size', d1)
Event.listen('size', d3)

Event.trigger('color')
console.log('----')
Event.trigger('size')
console.log('----')
Event.trigger('color')


// d11111
// d22222
// d33333
// ----
// d22222
// d33333
// ----
// d11111
// d22222
// d33333
</code></pre>
<h2>迭代器模式</h2>
<pre><code class="language-javascript">// https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html
// 定义：迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。

// 内部迭代器

const each = (array, callback) =&gt; {
  for (let i = 0, len = array.length; i &lt; len; i++) {
    if (callback.call(array[i], array[i], i) === false) {
      break
    }
  }
}

each([1,2,3,4,5], (val, i) =&gt; {
  console.log(val + ' - ' + i)
})
console.log('-----')
each([1,2,3,4,5], (val, i) =&gt; {
  if (i === 3) {
    return false
  }
  console.log(val + ' - ' + i)
})

// 外部迭代器

const Iterator = obj =&gt; {
  let current = 0;

  const next = () =&gt; {
    if (current &gt; obj.length) {
      return false
    }
    current += 1;
  }

  const isDone = () =&gt; {
    return current &gt;= obj.length
  }

  const getCurrentItem = () =&gt; {
    return obj[current]
  }

  return {
    next,
    isDone,
    getCurrentItem
  }
}

console.log('-----')

let iterator = Iterator([1,2,3,4,5])
console.log(iterator.getCurrentItem())
console.log(iterator.getCurrentItem())

iterator.next()

console.log(iterator.getCurrentItem())
console.log(iterator.isDone())

iterator.next()
console.log(iterator.getCurrentItem())
iterator.next()
console.log(iterator.getCurrentItem())
iterator.next()
console.log(iterator.getCurrentItem())
iterator.next()
console.log(iterator.getCurrentItem())
iterator.next()

console.log(iterator.isDone())



// 1 - 0
// 2 - 1
// 3 - 2
// 4 - 3
// 5 - 4
// -----
// 1 - 0
// 2 - 1
// 3 - 2
// -----
// 1
// 1
// 2
// false
// 3
// 4
// 5
// undefined
// true
</code></pre>
<h2>桥接模式</h2>
<p><a href="https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html">https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html</a></p>
<p>定义：桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<h2>外观模式</h2>
<pre><code class="language-html">&lt;button id=&quot;button&quot;&gt;外观模式&lt;/button&gt;
&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;foo1&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;foo2&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-javascript">// https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html
// https://natee.gitbooks.io/javascript-design-patterns/facade-pattern.html
// 定义：外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口使得这一子系统更加容易使用。


const addEvent = function(el, ev, fn) {
  if (el.addEventListener) {
    el.addEventListener(ev, fn, false)
  } else if (el.attachEvent) {
    el.attachEvent(`on${ev}`, fn)
  } else {
    el[`on${ev}`] = fn
  }
}

// 没测试
let N = window.N || {}
N.tools = {
  stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation()
    } else {
      e.cancelBubble = true
    }
  },
  preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault()
    } else {
      e.returnValue = false
    }
  },
  stopEvent(e) {
    this.stopPropagation(e)
    this.preventDefault(e)
  }
}


addEvent(document.getElementById('button'), 'click', function() {
  console.log('button')
})



function setStyles(elements, styles) {
  for (let i = 0, len = elements.length; i &lt; len; i++) {
    let element = document.getElementById(elements[i])
    if (element) {
      for (let property in styles) {
        element.style[property] = styles[property]
      }
    }
  }
}

setStyles(['foo', 'foo1', 'foo2'], {
  backgroundColor: 'red',
  width: '150px',
  height: '200px'
});
</code></pre>
<h2>访问者模式</h2>
<pre><code class="language-javascript">// https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html
// 没太理解...

function Visitor () {
  this.visit  = function(ConceteElement) {
    ConceteElement.doSomething()
  }
}

function ConceteElement() {
  this.doSomething = function() {
    console.log('this is a element')
  }

  this.accept = function(visitor) {
    visitor.visit(this)
  }
}


let visitor = new Visitor()
let conceteElement = new ConceteElement()

conceteElement.accept(visitor)

</code></pre>
<h2>模版方法模式</h2>
<p>定义：模板方法模式由二部分组成，第一部分是抽象父类，第二部分是具体实现的子类，一般的情况下是抽象父类封装了子类的算法框架，包括实现一些公共方法及封装子类中所有方法的执行顺序，子类可以继承这个父类，并且可以在子类中重写父类的方法，从而实现自己的业务逻辑。</p>
<pre><code class="language-javascript">// https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html


const ITInterview = function() {}

ITInterview.prototype.writeTest = function() {
  console.log('this is a write test')
}

ITInterview.prototype.technicalInterView = function() {
  console.log('this is a technical interview')
}

ITInterview.prototype.leader = function() {
  console.log('this is a leader interview')
}

ITInterview.prototype.waitNotice = function() {
  console.log('wait notice')
}

ITInterview.prototype.init = function() {
  this.writeTest()
  this.technicalInterView()
  this.leader()
  this.waitNotice()
}

const itInterview = new ITInterview()
itInterview.init()


// baidu
const BaiDuITInterview = function() {}
BaiDuITInterview.prototype = new ITInterview()

BaiDuITInterview.prototype.writeTest = function() {
  console.log('this is a baidu write test')
}

BaiDuITInterview.prototype.technicalInterView = function() {
  console.log('this is a baidu technical interview')
}


const baiduItInterview = new BaiDuITInterview()
baiduItInterview.init()

</code></pre>
<h2>组合模式</h2>
<p>定义：组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<pre><code class="language-javascript">// https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html
// 定义：组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。


// 定义组合对象（文件夹）
let Folder = function(name) {
  this.name = name
  this.files = []
}

Folder.prototype.add = function(file) {
  this.files.push(file)
}

Folder.prototype.scan = function() {
  console.log('开始文件扫描:' + this.name)
	for( let i = 0, file, files = this.files; file = files[i++]; ){
		file.scan();
	}
} 

//定义叶子对象（文件）
let File = function(name) {
  this.name = name
}

File.prototype.add = function() {
  throw new Error('文件下面不能再添加文件')
}
File.prototype.scan = function() {
  console.log('开始扫瞄：' + this.name)
}


let folder = new Folder('前端学习');
let folder1 = new Folder('JS学习');
let folder2 = new Folder('JQ学习');

let file1 = new File('JS设计模式');
let file2 = new File('JQ实战');
let file3 = new File('前端性能');

folder1.add(file1);
folder2.add(file2);

folder.add(folder1);
folder.add(folder2);
folder.add(file3);
folder.scan();

// 开始文件扫描:前端学习
// 开始文件扫描:JS学习
// 开始扫瞄：JS设计模式
// 开始文件扫描:JQ学习
// 开始扫瞄：JQ实战
// 开始扫瞄：前端性能
</code></pre>
<h2>备忘录模式</h2>
<p>定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态</p>
<pre><code class="language-javascript">// https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.html
// 定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态

const render = data =&gt; {
  console.log(data)
}

const page = function () {
  let cache = {}

  return (page) =&gt; {
    console.log('page', page)
    console.log('cache', JSON.stringify(cache))

    if (cache[page]) {
      render(cache[page])
    } else {
      let data = [
        {
          title: &quot;hi&quot;
        }
      ]

      cache[page] = data
      render(data)
    }
  }
}()



page(1)
page(1)
page(1)
page(1)

page(1)
page(2)
page(3)
page(4)

page(2)

</code></pre>
<h2>职责链模式</h2>
<pre><code class="language-javascript">// https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.html

// 定义：职责链模式（Chain of responsibility）是使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。职责链模式的名字非常形象，一系列可能会处理请求的对象被该连接成一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象，我们把这些对象成为链中的节点。

// 500 元客户订单
var order500 = function (orderType, pay, stock) {
  if (orderType === 1 &amp;&amp; pay) {
    console.log('500 rmb deposit, get 100 coupon ')
  } else {
    return 'nextSuccessor' // unknow the next node but always pass to next.
  }
};
// 200 元客户订单
var order200 = function (orderType, pay, stock) {
  if (orderType === 2 &amp;&amp; pay) {
    console.log('200 rmb deposit , get 50 coupon')
  } else {
    return 'nextSuccessor';
  }
};
// 无预约客户订单
var orderNormal = function (orderType, pay, stock) {
  if (stock &gt; 0) {
    console.log('normal buy no coupon')
  } else {
    console.log('the stock lack')
  }
};

let Chain = function (fn) {
  this.fn = fn
  this.successor = null
}

Chain.prototype.setNextSuccessor = function (successor) {
  return this.successor = successor
}

Chain.prototype.passRequest = function () {
  let ret = this.fn.apply(this, arguments)
  if (ret === 'nextSuccessor') {
    return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments)
  }
  return ret
}



// 现在我们把3个订单函数分别包装成职责链的节点
var chainOrder500 = new Chain(order500);
var chainOrder200 = new Chain(order200);
var chainOrderNormal = new Chain(orderNormal);

// 这里我们把上面封装的节点连成一条线，依次判断执行
chainOrder500.setNextSuccessor(chainOrder200)
chainOrder200.setNextSuccessor(chainOrderNormal)
// 测试代码
chainOrder500.passRequest(1,true,6); // 500 rmb deposit, get 100 coupon
chainOrder500.passRequest(2,true,4); // 200 rmb deposit , get 50 coupon

chainOrderNormal.passRequest(2,true,0); // 200 rmb deposit , get 50 coupon

</code></pre>
<h2>状态模式</h2>
<pre><code class="language-javascript">// https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html
// 定义：状态模式（State）定义一个对象，这个对象可以通过管理其状态从而使得应用程序作出相应的变化。

var trafficLight = (function () {
	var currentLight = null;
	return {
		change: function (light) {
			currentLight = light;
			currentLight.go();
		}
	}
})();


// 红灯
function RedLight() { }
RedLight.prototype.go = function () {
	console.log(&quot;this is red light&quot;);
}
// 绿灯
function GreenLight() { }
GreenLight.prototype.go = function () {
	console.log(&quot;this is green light&quot;);
}
// 黄灯
function YellowLight() { }
YellowLight.prototype.go = function () {
	console.log(&quot;this is yellow light&quot;);
}

trafficLight.change(new RedLight()); // this is red light
trafficLight.change(new YellowLight()); // this is yellow light


function Menu() { }
Menu.prototype.toggle = function (state) {
	state();
}

var menuStates = {
	&quot;show&quot;: function () {
		console.log(&quot;the menu is showing&quot;);
	},
	&quot;hide&quot;: function () {
		console.log(&quot;the menu is hiding&quot;);
	}
};

var menu = new Menu();
menu.toggle(menuStates.show);
menu.toggle(menuStates.hide);

</code></pre>
<h2>享元模式</h2>
<pre><code class="language-javascript">// https://fanerge.github.io/2017/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html

// 定义：享元模式是一种用于性能优化的模式，如果系统中因为创建了大量类似的对象而导致内存不足或占用过高这种模式就非常有用了。

// 定义塑料模特的构造函数
var Model = function (sex) {
	this.sex = sex;
}
// 为模特拍照
Model.prototype.takePhoto = function () {
	console.log('sex=' + this.sex + 'underwear=' + this.underwear )
}
// 实例化一个男模特 和 一个女模特
var maleModel = new Model('male');
let female    = new Model('female');    
for (var i = 1; i &lt;=50; i++){
	// 分别为模特换上 50 件内衣 以及 照相
	maleModel.underwear = 'underwear' + i;
	maleModel.takePhoto();
}
for (var i = 1; i &lt;=50; i++){
	// 分别为模特换上 50 件内衣 以及 照相
	female.underwear = 'underwear' + i;
	female.takePhoto();
}




let toolTipFactory = (function() {
  let tooplTipPool = []
  return {
    create: function() {
      if (tooplTipPool.length === 0) {
        console.log(1)
        let div = document.createElement('div')
        document.body.appendChild(div)
        return div
      } else {
        console.log(2)
        return tooplTipPool.shift()
      }
    },
    recover: function(tooltipDOm) {
      tooplTipPool.push(tooltipDOm)
    }
  }
})()

// 2
let arr = []
for (let i = 0, str; str = ['a', 'b'][i++];) {
  let toolTip = toolTipFactory.create()
  toolTip.innerHTML = str
  arr.push(toolTip)
}


for (let i = 0, toolTip; toolTip = arr[i++];) {
  toolTipFactory.recover(toolTip)
}

// 11
// 22
// 1111
for (let i = 0, str; str = ['a', 'b', 'c', 'd', 'e', 'f'][i++];) {
  let toolTip = toolTipFactory.create()
  toolTip.innerHTML = str
}
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[compose javascript]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/43</link>
            <guid>https://github.com/xiaotiandada/blog/issues/43</guid>
            <pubDate>Tue, 19 Jan 2021 06:33:34 GMT</pubDate>
            <description><![CDATA[<p>2020-02-26 22:54:15</p>
<p>在阅读某段代码的时候,了解到了<code>compose</code> 但是似乎不止<code>redux</code> 很多工具库都用到了这个<code>function</code></p>
<p><strong>code</strong></p>
<pre><code class="language-js">/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) =&gt; f(g(h(...args))).
 */

export default function compose(...funcs) {
  if (funcs.length === 0) {
    return arg =&gt; arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }

  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
}
</code></pre>
<p>以前的写法:</p>
<pre><code class="language-js">fn1(fn2(fn3(fn4(fnN(...)))))
</code></pre>
<p>现在的写法:</p>
<pre><code class="language-js">compose(fn1, fn2, fn3, fn4, fnN)(...)
</code></pre>
<p>相关链接:</p>
<p><a href="https://github.com/reactjs/redux/blob/v3.7.2/src/compose.js">redux</a></p>
<p><a href="https://www.codementor.io/@michelre/use-function-composition-in-javascript-gkmxos5mj">Use function composition in JavaScript</a></p>
<p><a href="https://segmentfault.com/a/1190000015801987">redux之compose</a></p>
<p><a href="https://cnodejs.org/topic/5995a7abee602e88524b435e">redux compose 详解</a></p>
]]></description>
        </item>
        <item>
            <title><![CDATA[用nodejs快速在Matataki发文]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/42</link>
            <guid>https://github.com/xiaotiandada/blog/issues/42</guid>
            <pubDate>Tue, 19 Jan 2021 06:33:09 GMT</pubDate>
            <description><![CDATA[<p>2020-01-27 20:52:26</p>
<p>如何用nodejs快速在Matataki发文, 利用node爬虫来获取网页的内容然后转发到<a href="https://www.matataki.io/">matataki</a>上面</p>
<p>这里就自己的<a href="https://xiaotiandada.github.io/">blog</a>做一个简单的<strong>example</strong> 这是可能需要用的<a href="https://xiaotiandada.github.io/matatakiApi">接口文档</a>⬇️⬇️⬇️ (docsify真香)</p>
<!-- more -->
<p><img src="https://i.loli.net/2020/01/27/V5oPbDI9QANXcGJ.png" alt=""></p>
<h3>开始</h3>
<ol>
<li>
<p>首先我们先初始一个项目</p>
<pre><code class="language-bash">mkdir matataki-post
npm init -y
touch index.js
</code></pre>
</li>
<li>
<p>理清思路</p>
<p>就像怎么把大象🐘装进冰箱一样 1.... 2... 3... 首先我们需要在<a href="https://www.matataki.io/article">matataki</a>上面注册一个账号, 我选择了邮箱 因为很简单也很方便 注册也挺快的, 然后去发布一篇文章 看看接口是如何调用的</p>
<p><strong>编辑</strong></p>
<p><img src="https://i.loli.net/2020/01/27/Lp29OskI6whtKdx.png" alt=""></p>
<p><strong>发布</strong></p>
<p><img src="https://i.loli.net/2020/01/27/KzcSsa6kIovujWE.png" alt=""></p>
<p>分析Networ</p>
<p>编辑: 我们在编辑文章的时候可以看出上传图片调用接口是 /post/uploadImage, 于是我们可以忽略其他接口调用</p>
<p>发布: 发布的时候, 可以看出我们一共调用了两个核心的接口, 一个是ipfs上传, 一个是文章上传</p>
<p><strong>思路</strong></p>
<pre><code class="language-tex">// 1、获取内容
	// 1、获取html
	// 2、解析dom获取内容
// 2、发布文章
	// 1、转存文章封面 因为文章的图片是外站的 我们需要转存到matataki上面才行
	// 2、上传ipfs
	// 3、上传文章
</code></pre>
</li>
<li>
<p>获取网页内容并解析dom</p>
<p>因为我的blog是静态页面 所以用<a href="https://www.npmjs.com/package/superagent">superagent</a>就可以抓取到内容了, 如果是客户端渲染抓去内容可能有问题, 可以考虑用<a href="https://www.npmjs.com/package/puppeteer">puppetter</a>做爬虫, 然后用<a href="https://www.npmjs.com/package/cheerio">cheerio</a>来解析dom 回味jq,  请求用<a href="https://www.npmjs.com/package/axios">axios</a>因为做前端习惯了🍑</p>
<pre><code class="language-bash">npm i superagent cheerio axios
</code></pre>
<pre><code class="language-javascript">const superagent = require(&quot;superagent&quot;);
const cheerio = require(&quot;cheerio&quot;);
const axios = require(&quot;axios&quot;);
// ...
// 获取内容
const getHtml = async url =&gt; {
  try {
    // 根据url获取内容
    const res = await superagent.get(url);
    return res.text;
  } catch (err) {
    console.error(err);
    return false;
  }
};

// 拆dom 这块根据自己页面自定义
const getDom = html =&gt; {
  if (!html) return false; // 没html返回
  const $ = cheerio.load(html);
  // 我的标题
  let title = $(&quot;#main #posts .post-header .post-title&quot;);
  // 描述
  let desc = $(&quot;#main #posts .post-body&quot;).text();
  // 内容
  let content = $(&quot;#main #posts .post-body&quot;).html();
  // 文章封面
  let cover = $(&quot;#main #posts .post-body img&quot;);
	
  // 如果有标题
  let titleRes = title.length &gt;= 1 ? $(title[0]).text() : &quot;&quot;;
  // 如果有图片
  let coverRes = cover.length &gt;= 1 ? $(cover[0]).attr(&quot;src&quot;) : &quot;&quot;;
	
  // 把数据返回出去
  return {
    title: titleRes,
    desc,
    content,
    cover: coverRes
  };
};
</code></pre>
<p>这块还是挺简单的233~~~</p>
<pre><code class="language-bash"># 然后我们可以调用方法 启动
node index

# 如果不出意外的话, 数据就能正常返回了 懒得截图了
</code></pre>
</li>
<li>
<p>发布文章</p>
<p>首先我们需要一些平台需要的信息,</p>
<ul>
<li><strong>TOKEN</strong>, 可以去控制台的<strong>Cookies</strong>里面寻找, 找到一个<strong>key</strong>为 <strong>ACCESS_TOKEN</strong> 然后复制信息</li>
<li><strong>URL</strong> 就是需要转发的文章</li>
<li><strong>AUTHOR</strong>是你这个账号在平台的用户名</li>
<li><strong>PLATFORM</strong> 是你这个账号的类型, 比如我是邮箱账号 我就是为 <strong>email</strong></li>
</ul>
<pre><code class="language-javascript">const TOKEN = &quot;&quot;; // 身份证明
const URL = &quot;&quot;; // 需要发的文章
const AUTHOR = &quot;&quot;; // 用户名
const PLATFORM = &quot;email&quot;; // 账号类型 邮箱账号
</code></pre>
<p>然后我们需要一个<strong>config</strong>文件 我也这种做法对不对 反正能用🍑 如果你觉得直接写在index.js要方便 可以简化这步</p>
<pre><code class="language-javascript">// config.js
module.exports = {
  // 接口地址
  api: {
    development: &quot;&quot;,
    production: &quot;https://api.smartsignature.io&quot;
  },
  // 页面地址
  webUrl: {
    development: &quot;&quot;,
    production: &quot;https://www.matataki.io&quot;
  }
}

// index.js
const config = require('./config') // config
const mode = process.env.NODE_ENV || 'production'; // 模式
const API = config.api[mode]; // 接口
const webUrl = config.webUrl[mode]; // 页面地址
</code></pre>
<p>增加两个命令  <strong>dev</strong>  <strong>start</strong> 来区分  <strong>development</strong> 和 <strong>production</strong></p>
<pre><code class="language-javascript">  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;dev&quot;: &quot;NODE_ENV=development node index&quot;,
    &quot;start&quot;: &quot;NODE_ENV=production node index&quot;
  },
</code></pre>
<p>把内容发布到<strong>ipfs</strong></p>
<pre><code class="language-javascript">const qs = require(&quot;qs&quot;);
// ...

console.log('开始获取Html...');
let resHtml = await getHtml(URL);
console.log('获取Dom...');
let resDom = await getDom(resHtml);

let data = {
    title: resDom.title.trim(),
    author: AUTHOR,
    desc: resDom.desc.trim(),
    content: resDom.content.trim()
  };
  data.desc = data.desc.replace(/[\r\n]/g, &quot;&quot;); // 去除回撤换行
  data.content = data.content.replace(/[\r\n]/g, &quot;&quot;); // 去除回撤换行
  let hash = await postIpfs(data);
  if (!hash) return console.log(&quot;not hash&quot;, hash);

// 发布到ipfs
const postIpfs = async ({ title, author, desc, content }) =&gt; {
  try {
    if (!TOKEN) throw new Error(&quot;没有token&quot;);
    const stringifyData = qs.stringify({
      &quot;data[title]&quot;: title,
      &quot;data[author]&quot;: author,
      &quot;data[desc]&quot;: desc,
      &quot;data[content]&quot;: content
    });
    let res = await axios({
      method: &quot;post&quot;,
      url: `${API}/post/ipfs`,
      data: stringifyData,
      headers: { &quot;x-access-token&quot;: TOKEN }
    });
    // console.log(res.data);
    if (res.status === 200 &amp;&amp; res.data.code === 0) {
      return res.data.hash;
    } else return false;
  } catch (error) {
    console.log(error);
    return false;
  }
};
</code></pre>
<p>需要的 <strong>x-access-token</strong> 已经在前面定义过了, 成功请求后会返回<strong>hash</strong>地址</p>
<p>然后转存图片</p>
<blockquote>
<p>下载图片这块, 按照<strong>search</strong>到的<strong>code</strong>没有修改, 使用<strong>request</strong>请求图片, 并且写入文件, 当然我也发现一个不错的第三方库, <a href="https://www.npmjs.com/package/image-downloader">image-downloader</a> 这个可以很轻松的下载图片</p>
</blockquote>
<pre><code class="language-javascript">const FormData = require('form-data');
const fs = require('fs')
const request = require('request')
const path = require('path')
// ...
// 图片转存
const downloadImage = async url =&gt; {
  if (!url) {
    console.log('没有url地址')
    return false
  }
  // https://github.com/Kerminate/douban-movies/blob/9119c276b2785b329f62cca684bc6d6459a7c57e/server/tasks/smms.js

  // 下载图片
  const downResources = (url, imgPath) =&gt; {
    return new Promise((resolve, reject) =&gt; {
      request
        .get(url)
        .pipe(fs.createWriteStream(imgPath))
        .on('finish', () =&gt; {
          resolve()
        })
    })
  }

  const fileName = 'photo.png'
  const imgPath = path.resolve(__dirname, './photo.jpg')
  try {
    await downResources(url, imgPath)
    // fix Callback must be a function
    const buffer = await fs.readFileSync(imgPath)
    const base64Image = Buffer.from(buffer).toString('base64')

    const form = new FormData()
    form.append('smfile', Buffer.from(base64Image, 'base64'), {
      filename: fileName
    })
    let headers = form.getHeaders()
    headers['x-access-token'] = TOKEN
    const res = await axios({
        method: 'POST',
        url: `${API}/post/uploadImage`,
        headers: headers,
        data: form
      })
    // console.log(res.data)
    if (res.status === 200 &amp;&amp; res.data.code === 0) {
      return res.data.data.cover
    } else {
      console.log('fail, status: ', res.status)
      return false
    }
  } catch (err) {
    console.log('update error', err)
    return false
  }
};
</code></pre>
<p>图片上传的核心我是从<strong>github</strong>里面<strong>search</strong>的</p>
<pre><code class="language-javascript">// ...
// 这里的一些转换我没有弄明白, 前端一般直接一个file或者一个blob就上去了
// 在node里面这个Buffer我还没有理解 希望大佬们看到了能教我一手👋!!!
const base64Image = Buffer.from(buffer).toString('base64')
const form = new FormData()
form.append('smfile', Buffer.from(base64Image, 'base64'), {
  filename: fileName
})
// ...
</code></pre>
<p>上传成功后会返回一个<strong>url</strong>地址, 如果是<strong>smms</strong>之类的图床上传记得多写一些判断他会判断<strong>重复</strong>的图片</p>
<p>图片也有了之后就是上传文章了</p>
<pre><code class="language-javascript">// 发布文章
const post = async data =&gt; {
  try {
    let res = await axios({
      method: &quot;post&quot;,
      url: `${API}/post/publish`,
      data: data,
      headers: { &quot;x-access-token&quot;: TOKEN }
    });
    // console.log(data, res.data);
    if (res.status === 200 &amp;&amp; res.data.code === 0) {
      return res.data;
    } else {
      console.log('fail', res.data)
      return false;
    }
  } catch (error) {
    console.log('error', error)
    return false;
  }
};

  console.log('发送到Matataki...');
	// 大部分的参数按照我这个默认就好了
  let resPost = await post({
    author: AUTHOR,
    cover,
    fissionFactor: 2000,
    hash: hash,
    platform: PLATFORM,
    publickey: null,
    sign: null,
    msgParams: null,
    signId: null,
    title: resDom.title,
    is_original: 0,
    tags: &quot;&quot;,
    cc_license: null,
    commentPayPoint: 1,
    shortContent: &quot;&quot;
  });
  if (resPost) {
    console.log(`发送成功, 您的文章地址: ${webUrl}/p/${resPost.data}`)
  } else {
    console.log('发送失败!!!')
  }
</code></pre>
<p>成功后会返回一个文章<strong>id</strong>然后我们去访问<code> console.log(`发送成功, 您的文章地址: ${webUrl}/p/${resPost.data}`)</code></p>
</li>
</ol>
<p>到此流程就完全结束了!!! 归纳调用</p>
<pre><code class="language-javascript">// 开始
const init = async () =&gt; {
  console.log('开始获取Html...');
  let resHtml = await getHtml(URL);
  console.log('获取Dom...');
  let resDom = await getDom(resHtml);

  console.log('开始发送到ipfs...');
  let data = {
    title: resDom.title.trim(),
    author: AUTHOR,
    desc: resDom.desc.trim(),
    content: resDom.content.trim()
  };
  data.desc = data.desc.replace(/[\r\n]/g, &quot;&quot;); // 去除回撤换行
  data.content = data.content.replace(/[\r\n]/g, &quot;&quot;); // 去除回撤换行
  let hash = await postIpfs(data);
  if (!hash) return console.log(&quot;not hash&quot;, hash);

  console.log('转存下载图片...');
  let cover = await downloadImage(resDom.cover);
  if (!cover) return console.log('下载图片失败')
  console.log('发送到Matataki...');
  let resPost = await post({
    author: AUTHOR,
    cover,
    fissionFactor: 2000,
    hash: hash,
    platform: PLATFORM,
    publickey: null,
    sign: null,
    msgParams: null,
    signId: null,
    title: resDom.title,
    is_original: 0,
    tags: &quot;&quot;,
    cc_license: null,
    commentPayPoint: 1,
    shortContent: &quot;&quot;
  });
  if (resPost) {
    console.log(`发送成功, 您的文章地址: ${webUrl}/p/${resPost.data}`)
  } else {
    console.log('发送失败!!!')
  }
};

init()
</code></pre>
<p><img src="https://i.loli.net/2020/01/28/u24DUxmbzJMjAkK.png" alt=""></p>
<p>调用结果 看起来还不错🍑</p>
<p><a href="https://www.matataki.io/p/1991">预览地址 1991</a></p>
<p><a href="https://github.com/xiaotiandada/matataki-post">仓库地址</a></p>
<p><a href="https://github.com/xiaotiandada">我的Github</a></p>
<hr>
<p>由于这是一个简单的<strong>example</strong> 所以不会弄得太复杂 简单的爬虫加上调用接口即可。</p>
<p>因为不太会node 全完自己瞎鼓捣, 如果写的不对或者不好的地方希望大佬们多多指点 指点</p>
<p>也欢迎加入QQ Group ID:718639024 来吐槽我🤮🤮🤮</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[vue优化记录]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/41</link>
            <guid>https://github.com/xiaotiandada/blog/issues/41</guid>
            <pubDate>Tue, 19 Jan 2021 06:31:51 GMT</pubDate>
            <description><![CDATA[<p>2019-11-21 12:48:47</p>
<p>1.看别人怎么优化的
2.看chrome提示怎么优化</p>
<pre><code class="language-js">const ImageminPlugin = require('imagemin-webpack-plugin').default
const imageminMozjpeg = require('imagemin-mozjpeg')

// 图片优化
new ImageminPlugin({
  test: /\.(jpe?g|png|gif)$/i,
  plugins: [
    imageminMozjpeg({
      disable: process.env.NODE_ENV !== 'production',
      quality: '65-80',
      progressive: true
    })
  ]
})
</code></pre>
<p><a href="https://vue-loader-v14.vuejs.org/zh-cn/configurations/extract-css.html">提取 CSS 到单个文件-简单的方法</a></p>
<h1>首页</h1>
<p><strong>performance 30</strong>
<strong>Accessibility 78</strong>
<strong>BestPractices 79</strong>
<strong>SEO 100</strong></p>
<h1>performance</h1>
<p><strong>performance 30!</strong></p>
<h2>Serve images in next-gen formats</h2>
<p>Image formats like JPEG 2000, JPEG XR, and WebP often provide better compression than PNG or JPEG, which means faster downloads and less data consumption. Learn more.</p>
<p>修改了png, 使用<a href="https://developers.google.com/speed/webp/">webp</a> 利用photoshop插件保存图片</p>
<p><strong>performance 35!</strong></p>
<h2>Serve images in next-gen formats(不提示)</h2>
<blockquote>
<p>但是由于兼容问题, 这里炸了 哈哈哈哈哈哈哈哈😂</p>
</blockquote>
<p>... 等待后续</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[node-mysql爬取图片并显示]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/40</link>
            <guid>https://github.com/xiaotiandada/blog/issues/40</guid>
            <pubDate>Tue, 19 Jan 2021 06:30:27 GMT</pubDate>
            <description><![CDATA[<p>2019-11-03 23:11:39</p>
<p><a href="https://xiaotiandada.github.io/2019/08/29/node%E7%88%AC%E8%99%AB-%E7%AE%80%E6%98%93%E7%89%88%E3%80%90%E7%AB%99%E9%85%B7%E3%80%91/">node爬虫 简易版【站酷】</a></p>
<p><a href="https://xiaotiandada.github.io/2019/09/02/node-mysql-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E3%80%90%E7%AE%80%E6%98%93%E7%89%88%E3%80%91/">node mysql 增删改查【简易版】</a></p>
<p>结合上面的文章做了一个图片展示</p>
<!-- more -->
<p><img src="node-mysql%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E6%98%BE%E7%A4%BA/client.png" alt="node-mysql爬取图片并显示"></p>
<h2>start</h2>
<p>启动node服务, 使用express</p>
<pre><code class="language-js">
const express = require('express')
const app = express()
const router = require('./router')

app.use(router)
app.listen(3000, () =&gt; console.log('port in 3000'))

// router
const router = express.Router()
router.get('/', (req, res) =&gt; {
  res.send(`hello world`)
})
module.exports = router
</code></pre>
<pre><code class="language-bash">node index.js
# 或者利用nodemon监听
nodemon index  # 写入配置文件
</code></pre>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;nodemon index.js&quot;
  },
</code></pre>
<pre><code class="language-bash">yarn dev

#or

npm run dev
</code></pre>
<p>在屏幕看见 hello world 就算是成功了</p>
<h3>修改crawler.js</h3>
<pre><code class="language-js">// 在之前下载图片逻辑后面写入插入数据库逻辑

// ...
const mysql = require('./mysql')
// ...

  // 下载图片
  const download = (item, id) =&gt; {
    try {
      let userAgent = userAgents[parseInt(Math.random() * userAgents.length)]
      // 通过 superagent 保存图片
      const req =  superagent.get(item.url)
      .set({ 'User-Agent': userAgent })
      // 增加 url title
      let url = `/image/page${id}/${item.title}.png`
      let title = item.title
      // 使用了stream(流)
      req.pipe(fs.createWriteStream(`./static/image/page${id}/${item.title}.png`))
      // 写入数据库
      mysql.sqlAdd(url, title)
      return `下载${item.title}done`
    } catch (error) {
      return console.log(`下载图片失败${item.title}`, error)
    }
  }

// mysql 文件
  // 插入数据 id自增
  sqlAdd  (url, title)  {
    let sqlAdd = 'INSERT INTO image SET ?';
    let sqlAddJson = {
      url,
      title
    }
    connection.query(sqlAdd, sqlAddJson, (err,res) =&gt; {
      if(err) return console.log('INSERT INFO ERROR:',err.message);
      console.log('INSERT INFO', res.insertId);
    });
  }

  // 没有做一些错误等预防(2333)
</code></pre>
<p>插入成功后, 打开数据库查一下</p>
<p>记得启动数据库!!!</p>
<pre><code class="language-bash">mysql.server start
</code></pre>
<p><img src="node-mysql%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E6%98%BE%E7%A4%BA/db.png" alt="db"></p>
<p>建表的过程就省略了...</p>
<h3>查数据</h3>
<p>数据有了之后, 开始查询数据</p>
<pre><code class="language-js">const express = require('express')
const router = express.Router()
const controller = require('./controller')
router.get('/', (req, res) =&gt; {
  res.send(`hello world 11qq`)
})

router.get('/allimg', async (req, res) =&gt; {
  // 调用controller.js
  let allImg = await controller.getAllImg()
  res.send(allImg)
})

module.exports = router
</code></pre>
<p>调用controller.getAllImg()并返回</p>
<pre><code class="language-js">const mysql = require('./mysql')

module.exports = {
  async getAllImg() {
    try {
      // 调用mysql方法
      let res = await mysql.getAllImg()
      return {
        code: 0,
        data: res,
        message: 'success'
      }
    } catch (error) {
      console.log('mysql getAllImg error', error)
      return {
        code: -1,
        data: {},
        message: 'fail'
      }
    }
  }
}
</code></pre>
<p>调用mysql.getAllImg()并返回</p>
<pre><code class="language-js">// mysql.js
// 查询所有数据并且返回
  getAllImg() {
    let sql = 'SELECT * FROM image'
    return new Promise((resolve, reject) =&gt; {
      connection.query(sql, (err, result) =&gt; {
        if (err) return reject(err)
        resolve(result)
      })
    })
  }
</code></pre>
<p><img src="node-mysql%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E6%98%BE%E7%A4%BA/data.png" alt="data"></p>
<p>访问<a href="http://localhost:3000/allimg%E8%B7%AF%E7%94%B1%E4%B9%8B%E5%90%8E%E5%8F%AF%E8%83%BD%E6%98%AF%E8%BF%99%E6%A0%B7">http://localhost:3000/allimg路由之后可能是这样</a></p>
<h3>展示</h3>
<p>数据有了之后就可以展示了</p>
<p>这里用了<a href="https://parceljs.org/">parcel</a>打包工具</p>
<pre><code class="language-bash"># 快速

yarn init -y

touch index.html
touch index.ts
touch index.less

yarn add --dev typescript
yarn add --dev parcel-bundler

// package.json
&quot;scripts&quot;: {
  &quot;start&quot;: &quot;parcel index.html&quot;
}

yarn start # 启动一个服务, 会有一个新页面
</code></pre>
<pre><code class="language-html">&lt;!-- ... --&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;script src=&quot;./index.ts&quot;&gt;&lt;/script&gt;
  &lt;!-- ... --&gt;
</code></pre>
<p>内容很简单</p>
<pre><code class="language-ts">// 使用axios
import axios from 'axios'
// 导入 less
import './index.less'
const APP_URL = 'http://127.0.0.1:3000'
const API = axios.create({
  baseURL: APP_URL,
  timeout: 1000
});

API.get('/allimg')
  .then( (res) =&gt; {
    console.log(res)
    if (res.status === 200 &amp;&amp; res.data.code === 0)
    setList(res.data.data)
  })
  .catch( (error) =&gt; {
    console.log(error);
  })


// 写入html结构
const setList = (arr: object[]) =&gt; {
  let app = document.querySelector('#app')
  let ulDom = document.createElement('ul')
  ulDom.classList.add('list')
  ulDom.setAttribute('role', 'list')
  let dom: string = ``

  interface Img {
    url: string,
    title: string
  }

  arr.map((i: Img) =&gt; {
    dom += `&lt;li&gt;
      &lt;img src=&quot;${APP_URL}${i.url}&quot;&gt;
      &lt;div&gt;
      &lt;span&gt;url: ${i.url}&lt;/span&gt;
      &lt;span&gt;title: ${i.title}&lt;/span&gt;
      &lt;/div&gt;
    &lt;/li&gt;`
  })

  ulDom.innerHTML = dom
  app.append(ulDom)
}
</code></pre>
<p>然后查看, 发现有问题,接口请求 Network Error (这里是跨域问题)</p>
<p>我们使用cors来解决</p>
<pre><code class="language-js">
// yarn add cors
const express = require('express')
const router = express.Router()
const cors = require('cors') // 导入
const controller = require('./controller')

router.use(cors()) // 全局允许 如果需要单独配置, 看官方文档
router.get('/', (req, res) =&gt; {
  res.send(`hello world 11qq`)
})

router.get('/allimg', async (req, res) =&gt; {
  let allImg = await controller.getAllImg()
  res.send(allImg)
})

module.exports = router
</code></pre>
<p>解决跨域之后就出现数据了, 然后把样式美化一下, 到这里上面的图片还没有加上!!!</p>
<pre><code class="language-less">.list {
  li {
    display: flex;
    align-items: center;
    margin: 6px 0;
    &amp;:hover {
      background-color: #eee;
      img {
        width: 300px;
      }
    }
    &amp; &gt; span {
      font-size: 14px;
      color: #333;
      list-style: 1.5;
    }
    &amp; &gt; div {
      display: flex;
      flex-direction: column;
      justify-content: center;
      margin-left: 20px;
    }
  }
  img {
    width: 100px;
    transition: width .3s;
  }
}
</code></pre>
<p>为了假如图片, 我设置了node静态资源(也不知道做法对不对 反正是跑起来了)</p>
<p><a href="https://expressjs.com/zh-cn/starter/static-files.html">在 Express 中提供静态文件</a></p>
<pre><code class="language-js">
const express = require('express')
const app = express()
// 设置static
app.use(express.static('static'));
const mysql = require('./mysql')
mysql.init()

const router = require('./router')
app.use(router)
// 这里是爬虫的方法
// const crawler = require('./crawler')
// crawler.init()


app.listen(3000, () =&gt; console.log('port in 3000'))

</code></pre>
<p>然后访问接口数据的路径加上<a href="http://localhost:3000/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86">http://localhost:3000/就可以了</a></p>
<p>效果展示</p>
<p><img src="node-mysql%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E6%98%BE%E7%A4%BA/client.png" alt="node-mysql爬取图片并显示"></p>
<p>还有很多优化点可以做, 分页什么什么吧啦吧啦, 代码优化 错误处理 emmmmm</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[vue微信分享]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/39</link>
            <guid>https://github.com/xiaotiandada/blog/issues/39</guid>
            <pubDate>Tue, 19 Jan 2021 06:29:54 GMT</pubDate>
            <description><![CDATA[<p>2019-11-02 00:30:30</p>
<p><a href="https://xiaotiandada.github.io/2019/10/23/%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E5%BE%AE%E4%BF%A1SDK/">上文 配置环境</a></p>
<p>这篇主要是分享vue做微信分享</p>
<!-- more -->
<p>假设本地的开发环境已经准备好了!!! 👍 并且你有一个好的同事为你写好了接口😊</p>
<p>npm的地址</p>
<p><a href="https://www.npmjs.com/package/weixin-js-sdk">sdk</a>
<a href="https://www.npmjs.com/package/axios">axios</a></p>
<pre><code class="language-bash">npm install weixin-js-sdk #微信官方js-sdk

npm install axios #基于Promise的HTTP客户端，用于浏览器和node.js
</code></pre>
<p>新建一个js文件(假如他叫wechat_share.js)</p>
<pre><code class="language-js">import wx from 'weixin-js-sdk'
import axios from 'axios'

export default ({ title, desc, link, imgUrl }) =&gt; {
  let defaultTitle = '默认标题'
  let defaultDesc = '默认描述'
  let defaultLink = window.location.href
  let defaultimgUrl ='默认图片'
  // 通过接口获取签名信息, 传递url过去, url 需要 encodeURIComponent
  axios
    .get(`/xxx/sign?url=${encodeURIComponent(defaultLink)}`)
    .then(res =&gt; {
      if (res.status === 200 &amp;&amp; '其他判断') {
        let { hash, timestamp, nonce } = res.data.data
        wx.config({
          debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。
          appId: 'xxxxxx', // 必填，公众号的唯一标识
          timestamp, // 必填，生成签名的时间戳
          nonceStr: nonce, // 必填，生成签名的随机串
          signature: hash, // 必填，签名
          jsApiList: [
            'updateAppMessageShareData',
            'updateTimelineShareData',
            'onMenuShareAppMessage'
          ]
        })
        wx.error(function(res) {
          console.log('wechat error', res)
        })
        wx.ready(function() {
          wx.updateAppMessageShareData({
            title: title || defaultTitle,
            desc: desc || defaultDesc,
            link: link || defaultLink,
            imgUrl: imgUrl || defaultimgUrl,
            success: function() {
              console.log('wechat share success updateAppMessageShareData')
            }
          })
          wx.updateTimelineShareData({
            title: title || desc || defaultTitle,
            link: link || defaultLink,
            imgUrl: imgUrl || defaultimgUrl,
            success: function() {
              console.log('wechat share success updateTimelineShareData')
            }
          })
          // 即将废弃，适配电脑版微信，参考：https://mp.weixin.qq.com/wiki?action=doc&amp;id=mp1421141115#10
          wx.onMenuShareAppMessage({
            title: title || defaultTitle,
            desc: desc || defaultDesc,
            link: link || defaultLink,
            imgUrl: imgUrl || defaultimgUrl,
            success: function() {
              console.log('wechat share success onMenuShareAppMessage')
            }
          })
        })
      }
    })
}
</code></pre>
<p>封装了一个简单的方法, 用户做微信分享 我们只需要调用方法, 并且传递信息即可, 里面的标题信息可以根据自己的实际情况修改!!!</p>
<p>接下来只需要在使用的地方调用即可(我在全局写了一个)</p>
<pre><code class="language-js">// main.js
import wechatShare from 'wechat_share'
Vue.prototype.$wechatShare = wechatShare

// other.vue xxx used

this.$wechatShare({})
</code></pre>
<p>如果每个页面都调用一次那就太麻烦了, 利用router的钩子函数, 然后把方法放入router.js 里面, 使用 router.afterEach 方法(<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%90%8E%E7%BD%AE%E9%92%A9%E5%AD%90">全局后置钩子</a>)</p>
<pre><code class="language-js">// router.js
import wechatShare from 'wechat_share'

router.afterEach((to, from) =&gt; {
  wechatShare({})
})
</code></pre>
<p>然后每个页面都会拥有分享功能(😄😄😄😄)</p>
<hr>
<p>但是这里有一个问题⚠️️️️️⚠️️️️️⚠️️️️️, 切换页面 然后去签名的时候, 微信报错说是无效签名!!!!</p>
<p>原因是因为传递的localhost.href与当前页面不符合!!!</p>
<p>因为router.afterEach是异步的(别人这样说的)然后需要通过this.$nextTick来解决(用setTimeout也可以 但是不太好 你懂的233)</p>
<pre><code class="language-js">// router.js
import wechatShare from 'wechat_share'
import Vue from 'vue'

router.afterEach((to, from) =&gt; {
  Vue.nextTick(() =&gt; {
    wechatShare({})
  })
})
</code></pre>
<p>在router里面使用讲this.$nextTick修改为Vue.nextTick(这样就可以解决, router.afterEach获取的localhost.href与当前页面不符合的问题</p>
<p>然后就是一个个别页面, 需要定制化内容分享, 调用方法即可</p>
<pre><code class="language-js">// 异步
async xx() {
  await xx().then(() =&gt; {
      this.$wechatShare({
        title,
        desc,
        imgUrl
      })
  })
}

// 同步
this.$wechatShare({
  title,
  desc,
  imgUrl
})
</code></pre>
<p>如果是异步的只需要在调用完方法之后, 调用写入内容即可(🚀🚀🚀)</p>
<hr>
<p>如果每个页面都想设置怎么办???</p>
<p>解决方案 在router的meta里面配置一些简单的信息即可</p>
<pre><code class="language-js">...
router: [
     {
      path: '/',
      name: 'index',
      component: () =&gt; import(/* webpackChunkName: &quot;index&quot; */ 'index.vue'),
      meta: {
        title: 'xxxxxxxxxx'
        ....
      }
    },
]
...

router.afterEach((to, from) =&gt; {
  Vue.nextTick(() =&gt; {
    wechatShare({
      title: to.meta.title
    })
  })
})
</code></pre>
<p>在钩子函数afterEach里面设置默认的title: to.meta.title 👍 🚀 🔥</p>
<p>效果图</p>
<p><a href="https://matataki.io/">体验地址</a> 微信打开会自动跳转的</p>
<p><a href="https://matataki.io/">https://matataki.io/</a></p>
<p><img src="vue%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB/1.png" alt="效果图"></p>
]]></description>
        </item>
        <item>
            <title><![CDATA[css 弹跳小球]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/38</link>
            <guid>https://github.com/xiaotiandada/blog/issues/38</guid>
            <pubDate>Tue, 19 Jan 2021 06:29:35 GMT</pubDate>
            <description><![CDATA[<p>2019-10-27 22:08:23</p>
<p><a href="https://juejin.im/post/5d2e00315188255a0476ea51">资料</a></p>
<!-- more -->
<pre><code class="language-html">  &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt;
  &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-css">
    body {
      -webkit-box-reflect: below 0px -webkit-linear-gradient(transparent,transparent 50%, rgba(255,255,255,.6));
    }
    .circle {
      width: 100px;
      height: 100px;
      /* background: red; */
      background: radial-gradient(circle at 40% 0, red 60%, #104b63);
      border-radius: 50%;
      margin-top: 300px;
      margin-left: 300px;
      transform: translate(0, -200px);
      animation: circle 1.8s cubic-bezier(0.18, 0.89, 0.32, 1.28) infinite;
    }

    @keyframes circle {
      0% {
        transform: translate(0, -200px);
      }
      10% {
        transform: translate(0, -160px);
      }
      20% {
        transform: translate(0, -120px);
      }
      30% {
        transform: translate(0, -80px);
      }
      40% {
        transform: translate(0, -40px);
      }
      50% {
        transform: translate(0, 0);
      }
      60% {
        transform: translate(0, -40px) scale(1.13, 0.87);
      }
      70% {
        transform: translate(0, -80px) scale(0.87, 1.13);
      }
      80% {
        transform: translate(0, -120px) scale(1.05, 0.95);
      }
      90% {
        transform: translate(0, -160px) scale(0.98, 1.02);
      }
      100% {
        transform: translate(0, -200px);
      }
    }

    .line {
      height: 1px;
      width: 100%;
      background-color: #000;
    }
</code></pre>
<p class="codepen" data-height="353" data-theme-id="dark" data-default-tab="css,result" data-user="xiaotiandada" data-slug-hash="VwwWVwg" style="height: 353px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="弹跳小球">
  <span>See the Pen <a href="https://codepen.io/xiaotiandada/pen/VwwWVwg">
  弹跳小球</a> by xiaotiandada (<a href="https://codepen.io/xiaotiandada">@xiaotiandada</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>]]></description>
        </item>
        <item>
            <title><![CDATA[本地调试微信SDK]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/37</link>
            <guid>https://github.com/xiaotiandada/blog/issues/37</guid>
            <pubDate>Tue, 19 Jan 2021 06:29:04 GMT</pubDate>
            <description><![CDATA[<p>2019-10-23 13:05:50</p>
<p>这里使用vue(其他道理应该也是一样的), 因为微信的sdk只能在他的域名下才能正常使用, 我们又不能去服务端开发然后build, 所有在本地调试微信sdk就很有必要了,(微信分享在另一篇会写)</p>
<!-- more -->
<p>首选假设你有一个备案并且在微信设置好了域名(自己配置, 或者有一个好的同事👍)</p>
<p>假如你的域名是<strong><a href="http://www.wx.com">www.wx.com</a></strong></p>
<h2>工具</h2>
<p>Nginx</p>
<p>iHost(mac一个修改host的软件)</p>
<p>调试器 微信开发工具(Google搜索 官网下载)</p>
<p><a href="https://qydev.weixin.qq.com/wiki/index.php?title=%E5%BE%AE%E4%BF%A1JS-SDK%E6%8E%A5%E5%8F%A3">微信SDk文档</a></p>
<h2>go</h2>
<p>首先需要了解一下什么是<a href="https://baike.baidu.com/item/hosts">host</a>, 然后我们要做的就是修改本地host文件, 访问 <a href="http://www.wx.com">www.wx.com</a> 的时候访问我们自定义的ip地址</p>
<pre><code>127.0.0.1	www.wx.com
</code></pre>
<p>save之后 我们访问 <a href="http://www.wx.com">www.wx.com</a> 会访问本地的 127.0.0.1 (懒得截图)</p>
<p>启动一个vue demo(省略N字)</p>
<pre><code class="language-bash">vue create *

# ...

yarn serve #这里会跑一个http服务, 端口可能是8080也可能是任意其他
</code></pre>
<p>然后再回到访问www.wx.com页面(还是无法正常访问本地的vue demo项目), 原因是默认的端口是80, 而我们的服务是8080, 这时候我们需要吧80端口代理到8080(使用nginx)</p>
<pre><code class="language-bash"># N种安装方法之一

brew install nginx
</code></pre>
<p>安装完成之后</p>
<pre><code>nginx
</code></pre>
<p>发现会有一个默认的Nginx页面(这里就说明你安装成功了👍) (懒得截图)</p>
<pre><code class="language-bash">nginx -s stop # 我们停掉它
</code></pre>
<p>然后找到config文件, nginx的配置文件叫 nginx.conf, 我本地的路径为 /usr/local/etc/nginx (其他平台Google搜索, 查看配置文件在哪儿)</p>
<pre><code>server {
	listen 80;
	server_name sstest.frontenduse.top;

  location / {
    proxy_pass http://localhost:8080;
  }
}
</code></pre>
<p>可以又多个 server</p>
<p>通过 proxy_pass 代理80端口到8080端口(如果默认的80端口暂用, 可以改为别的比如8081 随意)</p>
<pre><code class="language-bash">nginx # 此时访问localhost, 会进入之前启动的vue demo页面
</code></pre>
<p>然后去vue demo里面引入微信的sdk 出现如下类似的图就算正常了</p>
<p>具体怎么引入看官方文档(下篇文章会写)</p>
<p>script 或者 import, 然后按照微信的文章配置就好了<a href="https://qydev.weixin.qq.com/wiki/index.php?title=%E5%BE%AE%E4%BF%A1JS-SDK%E6%8E%A5%E5%8F%A3">微信SDk文档</a></p>
<p><img src="%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E5%BE%AE%E4%BF%A1SDK/1.jpg" alt="网图"></p>
<p>网图</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[ vue自定义滚动指令]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/36</link>
            <guid>https://github.com/xiaotiandada/blog/issues/36</guid>
            <pubDate>Tue, 19 Jan 2021 06:28:40 GMT</pubDate>
            <description><![CDATA[<p>2019-10-21 10:48:56</p>
<p><a href="https://cn.vuejs.org/v2/cookbook/creating-custom-scroll-directives.html">教程</a></p>
<p>教程写的很好, 我按照教程跑了一部分</p>
<p><strong>真实的示例：为级联动画使用一个自定义滚动指令</strong></p>
<p>这部分没有跑, 看了看directive里面的代码, 通过v-scroll里面的参数来进行判断的, 然后把toPath里面的参数传入进来,</p>
<p>我根据教程学习, 然后顺便添加了一个lodash throttle 来'节流'</p>
<h2>创建一个vue demo</h2>
<pre><code>... ... 省略
</code></pre>
<p>新建一个directive.js</p>
<pre><code class="language-js">import Vue from 'vue'
import throttle from &quot;lodash/throttle&quot;;
Vue.directive('scroll', {
  inserted: (el, binding) =&gt; {
    let f = evt =&gt; {
      if (binding.value(evt, el)) {
        // eslint-disable-next-line no-console
        // console.log(8, binding.value(evt, el))
        // remove event
        window.removeEventListener('scroll', f)
      }
    }
    // listen event
    // use lodash/throttle call methods
    window.addEventListener('scroll', throttle(f, 300))
    // eslint-disable-next-line no-console
    console.log(el, binding)
  }
})

import &quot;./directive&quot;; // main.js 里面 import
</code></pre>
<p>在组件里面</p>
<pre><code class="language-html">&lt;HelloWorld v-scroll=&quot;handleScroll&quot; class=&quot;box&quot; msg=&quot;Welcome to Your Vue.js App&quot;/&gt;
</code></pre>
<p>可以是任何元素 使用 v-scroll=&quot;xxx&quot;</p>
<pre><code class="language-js">// ....
    handleScroll (evt, el) {
      // eslint-disable-next-line no-console
      console.log(19, evt, el, window.scrollY)
      // judeg window.scroll, execution TweenMax function
      if (window.scrollY &gt; 50) {
        TweenMax.to(el, .3, {
          y: -10,
          opacity: 1,
          // eslint-disable-next-line no-undef
          ease: Sine.easeOut
        })
      }
      // to meet the conditions return true else return false
      return window.scrollY &gt; 100
    }
// ...
</code></pre>
<pre><code class="language-css">.box {
  opacity: 0;
  transition: 1.5s all cubic-bezier(0.39, 0.575, 0.565, 1);
  /* transform: translate3d(0, 10px, 0); */
}
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[正则匹配两个字符串之间的内容]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/35</link>
            <guid>https://github.com/xiaotiandada/blog/issues/35</guid>
            <pubDate>Tue, 19 Jan 2021 06:28:05 GMT</pubDate>
            <description><![CDATA[<p>2019-10-12 00:32:54</p>
<p><a href="http://c.runoob.com/front-end/854">在线工具</a></p>
<p><strong>匹配A字符与B字符之间的字符(包含AB)</strong></p>
<p>A.*?B</p>
<img width="300" src="正则匹配两个字符串之间的内容/1.png">
<p><strong>匹配A字符与B字符之间的字符(包含A不包含B)</strong></p>
<p>A.*?(?=B)</p>
<img width="300" src="正则匹配两个字符串之间的内容/2.png">
<p><strong>匹配A字符与B字符之间的字符(不包含AB)</strong></p>
<p>(?&lt;=A).*?(?=B)</p>
<img width="300" src="正则匹配两个字符串之间的内容/3.png">
<hr>
<blockquote>
<p>资料</p>
</blockquote>
<pre><code>### 正则中的 ?= 、?&lt;= 、?!、 ?&lt;!=

以前看正则的时候遇到?= 、?&lt;=，在网上搜索出来名字有称之为正向预查、负向预查的，有称之为前瞻、后顾的，看用法的话大概知道是怎么回事，但就是记不住啊，对于我来说，这名称太抽象(鬼扯)了。

今天看书看到作者讲到正则，感觉自己又有所领悟，翻出来重新理解了一下。

如今我的理解是这样的，我将&lt;记为方向，包含这个箭头说明是放在目标内容左边的：

1. ```?=``` ： 询问后面跟着的东西是否等于这个    /b(?=a)/.test('bab')

2. ```?&lt;=``` ： 询问是否以这个东西开头  /(?&lt;=a)b/.test('ab')

3. ```?!``` : 询问后面跟着的东西是否不是这个  /b(?!a)/.test('bb')

4. ```?&lt;!=``` ：询问是否不是以这个东西开头  /(?&lt;!=a)b/.test('bb')

其实按照我这样理解的话，```?!``` 后面要是加上```=```就更加符合我的心理预期了，最后还有一点，匹配得到的结果并不包含 ?=、?&lt;=、?!和?&lt;!=里面的内容

### 顺便记录一下

javascript的replace方法的第二个参数，如果是传入的字符串的话，有几个特殊的东西。

1. ```$&amp;`` ： 表示匹配到的结果。'javascript'.replace(/script/, '$&amp;$&amp;') -&gt;  ‘javascriptscript’

2. ```$\```` ： 表示匹配到的结果的左边或者说前面的那一堆字符串。 'javascript'.replace(/script/, '$&amp; 不是 $`')  -&gt;  &quot;javascript 不是 java&quot;

3. ```$'``` ： 表示匹配到的结果的右边或者说后面的那一堆字符串。 '我是猪'.replace(/我是/, &quot;$&amp;$'&quot;)  -&gt;   &quot;我是猪猪&quot;

4. ```$$``` ： 表示$字符。

作者：不过从心而已
链接：https://www.jianshu.com/p/661af704198c
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[i18n]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/34</link>
            <guid>https://github.com/xiaotiandada/blog/issues/34</guid>
            <pubDate>Mon, 16 May 2022 07:47:25 GMT</pubDate>
            <description><![CDATA[<h3>Next</h3>
<ul>
<li><a href="https://jasonlam.cc/blog/ZitySpace/the-experience-of-website-internationalization">https://jasonlam.cc/blog/ZitySpace/the-experience-of-website-internationalization</a></li>
<li><a href="https://github.com/isaachinman/next-i18next/issues/1552">https://github.com/isaachinman/next-i18next/issues/1552</a></li>
</ul>
<h3>vue-i18n 为什么切换语言部分的数据会不变？</h3>
<p>2019-09-26 15:48:12</p>
<p><strong>vue-i18n国际化在data中切换不起作用</strong></p>
<p><a href="https://www.bbsmax.com/A/qVdep96p5P/">https://www.bbsmax.com/A/qVdep96p5P/</a></p>
<p>配置会写在另一篇文章里面!!</p>
<pre><code>将this.$t() 写到了data属性里，切换语言不起作用

data是一次性生产的，你这么写只能是在 data 初始化的时候拿到这些被国际化的值，并不能响应变化。

官方的解决办法是，建议我们将表达式写到computed属性里，不要写到data里

copy⬆️

</code></pre>
<p>因为在 js 中的this.options只会在初始化的时候执行一次，它的数据并不会随着你本地 lang的变化而变化，所以需要你在lang变化的时候手动重设this.options。 -- copy</p>
<p><a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/advanced/i18n.html">https://panjiachen.github.io/vue-element-admin-site/zh/guide/advanced/i18n.html</a></p>
<p>有些数据又不想写在computed里面怎么办???</p>
<p>解决方案</p>
<ol>
<li>刷新页面 (体验不太好</li>
<li>写入computed</li>
<li>通过监听locale重新赋值</li>
</ol>
<pre><code class="language-js">  watch: {
    '$i18n.locale'() {
      console.log(this.$i18n.locale)
      this.setContent() // 重新设置一下值
    }
  },
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[Building-Components shadow Dom]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/33</link>
            <guid>https://github.com/xiaotiandada/blog/issues/33</guid>
            <pubDate>Tue, 19 Jan 2021 06:27:18 GMT</pubDate>
            <description><![CDATA[<p>2019-09-25 00:41:02</p>
<p><a href="https://developers.google.com/web/fundamentals/web-components/shadowdom#slots">https://developers.google.com/web/fundamentals/web-components/shadowdom#slots</a></p>
<pre><code class="language-html">&lt;!-- custom dom --&gt;
&lt;custom-tabs&gt;
    &lt;!-- 定义slot --&gt;
    &lt;button slot=&quot;tab&quot;&gt;button&lt;/button&gt;
    &lt;button slot=&quot;tab&quot;&gt;button&lt;/button&gt;
    &lt;button slot=&quot;tab&quot;&gt;button&lt;/button&gt;
    &lt;!-- 默认slot --&gt;
    &lt;section&gt;section1&lt;/section&gt;
    &lt;section&gt;section2&lt;/section&gt;
    &lt;section&gt;section3&lt;/section&gt;
  &lt;/custom-tabs&gt;

  &lt;script&gt;
  let selected_ = null
  class customTab extends HTMLElement {
    constructor() {
      super()

      let shadowRoot = this.attachShadow({mode: 'open'})
      // 样式 内容
      shadowRoot.innerHTML = `
        &lt;style&gt;
          :host {
            border: 1px solid #ececec;
            display: inline-block;
          }

          #tabs ::slotted(*) {
            border: none;
            outline: none;
            padding: 20px 40px;
            background: #f1f1f1;
          }

          #tabs ::slotted([aria-selected=&quot;true&quot;]) {
            background: #fff;
          }

          #panels {
            padding: 20px;
            font-size: 18px;
          }

          #panels ::slotted([aria-hidden=&quot;true&quot;]) {
            display: none;
          }

        &lt;/style&gt;

        &lt;div id=&quot;tabs&quot;&gt;
          &lt;slot id=&quot;tabSlot&quot; name=&quot;tab&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div id=&quot;panels&quot;&gt;
          &lt;slot id=&quot;panelsSlot&quot;&gt;&lt;/slot&gt;
        &lt;/div&gt;
      `
    }

    // get set
    get selected() {
      return selected_
    }

    set selected(idx) {
      selected_ = idx
      this._selected(idx)
    }

    connectedCallback() {

      // set role
      this.setAttribute('role', 'tab-list')

      // get Element
      let tabsSlot = this.shadowRoot.querySelector('#tabSlot')
      let panelsSlot = this.shadowRoot.querySelector('#panelsSlot')

      // filter Element
      this.tabs = tabsSlot.assignedNodes({flatten: true})
      this.panels = panelsSlot.assignedNodes({flatten: true}).filter(el =&gt; el.nodeType === Node.ELEMENT_NODE)


      // set role
      for (const [i, panel] of this.panels.entries()) {
        panel.setAttribute('role', 'tab-panel')
      }

      // set click keydown event
      this._boundOnTitleClick = this._onTitleClick.bind(this)
      this._boundOnKeydown = this._onKeydown.bind(this)

      tabsSlot.addEventListener('click', this._boundOnTitleClick)
      tabsSlot.addEventListener('keydown', this._boundOnKeydown)

      // set default selected, by tab html selected attribute
      this.selected = this._findFirstSelectedTab() || 0
    }

    // tab click event
    _onTitleClick(e) {
      if (e.target.slot === 'tab') {
        // now click Element index
        this.selected = this.tabs.indexOf(e.target)
      }
    }

    // tab keydown event
    _onKeydown(e) {
      switch(e.code) {
        // up left
        case 'ArrowUp':
        case 'ArrowLeft':
          e.preventDefault()
          // --, if it's 0 idx = length - 1 else idx
        var idx = this.selected - 1
        idx = idx &lt; 0 ? this.tabs.length - 1 : idx
        // click event
        this.tabs[idx].click()
          break;
          // down right
        case 'ArrowDown':
        case 'ArrowRight':
          e.preventDefault()
          // ++ by &amp; tab click event
        var idx = this.selected + 1
        this.tabs[idx % this.tabs.length].click()
          break;
        default:
          break;
      }
    }

    // find tab html attribute selected set now Tab
    _findFirstSelectedTab() {
      let selectedIdx
      // for
      for (const [i, tab] of this.tabs.entries()) {
        // set role
        tab.setAttribute('role', 'tab')
        // if tab has selected, nowTab is i
        if (tab.hasAttribute('selected')) {
          selectedIdx = i
        }
      }
      return selectedIdx
    }

    // set tab toggle function
    _selected(idx = null) {
      // for
      for(let i = 0, tab; tab = this.tabs[i]; ++i) {
        // if idx === i equal true
        let selected = idx === i
        // set attribute
        tab.setAttribute('aria-selected', selected)
        this.panels[i].setAttribute('aria-hidden', !selected)
      }
    }
  }


  if (customElements) customElements.define('custom-tabs', customTab)
  else console.log('不支持 custom')
  &lt;/script&gt;
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[Building Components Custom Elements 自定义元素]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/32</link>
            <guid>https://github.com/xiaotiandada/blog/issues/32</guid>
            <pubDate>Tue, 19 Jan 2021 06:26:38 GMT</pubDate>
            <description><![CDATA[<p>2019-09-15 01:42:32</p>
<p>首先来写一个示例吧</p>
<p>Web Components 标准非常重要的一个特性是，它使开发者能够将HTML页面的功能封装为 custom elements（自定义标签），而往常，开发者不得不写一大堆冗长、深层嵌套的标签来实现同样的页面功能。这篇文章将会介绍如何使用HTML的custom elements。 - MDN</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements">https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements</a></p>
<p>具体看MDN文档,(复制完应该就差不多了 然后去这里玩)</p>
<p><a href="https://developers.google.com/web/fundamentals/web-components/">https://developers.google.com/web/fundamentals/web-components/</a></p>
<!-- more -->
<p><strong>查看demo</strong></p>
<pre><code class="language-html">&lt;style for-run for-show&gt;
.popup-info {
  width: 100px;
  height: 100px;
  position: relative;
  top: 100px;
  left: 300px;
}
.popup-info1 {
  width: 100px;
  height: 100px;
  position: relative;
  top: 160px;
  left: 600px;
}
.popup-info img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  cursor: pointer;
}
.popup-info .info {
  font-size: 20px;
  width: 200px;
  display: inline-block;
  border: 1px solid black;
  padding: 10px;
  background: white;
  border-radius: 4px;
  opacity: 0;
  transition: 0.6s all;
  position: absolute;
  bottom: 110px;
  left: 0px;
  z-index: 3;
}
.popup-info:hover .info{
  opacity: 1;
}
&lt;/style&gt;

&lt;template for-run for-show&gt;

&lt;popup-info role=&quot;popup&quot; img=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=4038933139,466219061&amp;fm=26&amp;gp=0.jpg&quot; data-text=&quot;I Learn Js 💗&quot;&gt;&lt;/popup-info&gt;
&lt;button id=&quot;remove&quot;&gt;remove&lt;/button&gt;
&lt;button id=&quot;move&quot;&gt;move&lt;/button&gt;
&lt;button id=&quot;toggle&quot;&gt;toggle attribute&lt;/button&gt;


&lt;popup-info1 role=&quot;popup&quot; img=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=4038933139,466219061&amp;fm=26&amp;gp=0.jpg&quot; data-text=&quot;I Learn Js 💗&quot;&gt;&lt;/popup-info1&gt;

&lt;button is=&quot;popup-button&quot;&gt;popup-button!&lt;/button&gt;

&lt;/template&gt;

&lt;script for-run for-show&gt;
class popupInfo extends HTMLElement {
  constructor() {
    super()

  }
  static get observedAttributes() {
    return ['role']
  }
  // 生命周期钩子
  connectedCallback() {
    // 创建 div
    let div = document.createElement('div')
    div.setAttribute('role', 'popup-info')

    // 创建 img
    let img = document.createElement('img')
    let src = this.getAttribute('img')

    // 创建info信息
    let info = document.createElement('span')
    let text = this.getAttribute('data-text')

    // 设置img内容
    img.src = src
    img.alt = text

    // 设置info内容
    info.classList.add('info')
    info.innerText = text

    // 添加class
    div.classList.add('popup-info')

    // 添加内容 img info
    div.appendChild(img)
    div.appendChild(info)

    this.appendChild(div)
  }
  disconnectedCallback() {
    console.log('我没有了呀')
  }
  attributeChangedCallback(attrName, oldVal, newVal) {
    console.log('当前的属性:', attrName)
    console.log('当前的属性 old:', oldVal)
    console.log('当前的属性 new:', newVal)
  }
  adoptedCallback() {
    console.log('adoptedCallback 自定义元素被移入新的 document')
  }
}

customElements.define('popup-info', popupInfo)


// 测试 自定义元素被移入新的 document
const testAdoptedCallback = ()=&gt; {
  // 创建 iframe
  const createWindow = () =&gt; {
    let iframe = document.createElement('iframe')
    document.body.appendChild(iframe)
    return iframe.contentWindow
  }
  let cw = createWindow()
  // 创建 自定义元素
  let cw1 = document.querySelector('popup-info')

  // 创建的元素插入到 新创建的iframe
  cw.document.body.appendChild(cw1)
}

const move = () =&gt; {
  let move = document.querySelector('#move')
  move.onclick = function() {
    testAdoptedCallback()
  }
}
move()

// 测试移除 popup-info
const remove = () =&gt; {
  let remove = document.querySelector('#remove')
  remove.onclick = function() {
    document.querySelector('popup-info').remove()
  }
}
remove()

// 测试属性被修改 toggle
const toggle = () =&gt; {
  let i = 0
  let toggle = document.querySelector('#toggle')
  toggle.onclick = function() {
    i++
    document.querySelector('popup-info').setAttribute('role', `popup-info-change, ${i}`)
  }
}
toggle()



class popupInfo1 extends popupInfo {
  constructor() {
    super()
  }
  connectedCallback() {
    this.innerText = 'extends popupInfo'
  }
}

customElements.define('popup-info1', popupInfo1)


class popupButton extends HTMLButtonElement {
  constructor() {
    super()
  }
  connectedCallback() {
    this.innerText += ' extends'
  }
}

customElements.define('popup-button', popupButton, {extends: 'button'})

&lt;/script&gt;
</code></pre>
<p><strong>定义新元素</strong></p>
<pre><code class="language-js">class popupInfo extends HTMLElement {
  constructor() {
    super()
  }
  static get observedAttributes() {
    return ['role']
  }
  // 生命周期钩子
  connectedCallback() {
    // 创建 div
    let div = document.createElement('div')
    div.setAttribute('role', 'popup-info')

    // 创建 img
    let img = document.createElement('img')
    let src = this.getAttribute('img')

    // 创建info信息
    let info = document.createElement('span')
    let text = this.getAttribute('data-text')

    // 设置img内容
    img.src = src
    img.alt = text

    // 设置info内容
    info.classList.add('info')
    info.innerText = text

    // 添加class
    div.classList.add('popup-info')

    // 添加内容 img info
    div.appendChild(img)
    div.appendChild(info)

    this.appendChild(div)
  }
  disconnectedCallback() {
    console.log('我没有了呀')
  }
  attributeChangedCallback(attrName, oldVal, newVal) {
    console.log('当前的属性:', attrName)
    console.log('当前的属性 old:', oldVal)
    console.log('当前的属性 new:', newVal)
  }
  adoptedCallback() {
    console.log('adoptedCallback 自定义元素被移入新的 document')
  }
}

customElements.define('popup-info', popupInfo)

</code></pre>
<pre><code class="language-html">&lt;popup-info role=&quot;popup&quot; img=&quot;https://miro.medium.com/max/1440/1*LjR0UrFB2a__5h1DWqzstA.png&quot; data-text=&quot;I Learn Js 💗&quot;&gt;&lt;/popup-info&gt;

</code></pre>
<blockquote>
<p>定义一个自定义的元素 然后使用</p>
</blockquote>
<p><strong>扩展元素</strong></p>
<p><strong>扩展自定义元素</strong></p>
<p>customElements 全局性用于定义自定义元素</p>
<p>customElements.define()，并使用 JavaScript class 扩展基础 HTMLElement</p>
<pre><code class="language-js">class popupInfo1 extends popupInfo {
  constructor() {
    super()
  }
  connectedCallback() {
    this.innerText = 'extends popupInfo'
  }
}

customElements.define('popup-info1', popupInfo1)
</code></pre>
<p>继承自定义元素好像效果有点不对(我还没找到为啥 希望大佬教教我)</p>
<p>有关创建自定义元素的规则</p>
<ul>
<li>自定义元素的名称必须包含短横线 (-)。因此，<x-tags>、<my-element> 和 <my-awesome-app> 等均为有效名称，而 <tabs> 和 &lt;foo_bar&gt; 则为无效名称....</li>
<li>您不能多次注册同一标记...</li>
<li>自定义元素不能自我封闭标签</li>
</ul>
<blockquote>
<p>教程里面更详细</p>
</blockquote>
<p>和上面很相识, 扩展了自定义的元素</p>
<p><strong>扩展原生 HTML 元素</strong></p>
<pre><code class="language-js">class popupButton extends HTMLButtonElement {
  constructor() {
    super()
  }
  connectedCallback() {
    this.innerText += ' extends'
  }
}

customElements.define('popup-button', popupButton, {extends: 'button'})
</code></pre>
<img src="Building-Components-Custom-Elements-自定义元素/button.png" />
<p>要扩展元素，您需要创建继承自正确 DOM 接口的类定义</p>
<p>扩展原生元素时，对 define() 的调用会稍有不同。所需的第三个参数告知浏览器要扩展的标记。</p>
<p>这很有必要，因为许多 HTML 标记均使用同一 DOM 接口</p>
<p>例如 section address 和 em（以及其他）都使用 HTMLElement；q 和 blockquote 则使用 HTMLQuoteElement；等等。</p>
<p>指定 {extends: 'blockquote'} 可让浏览器知道您创建的是 blockquote 而不是 q。有关 HTML DOM 接口的完整列表，请参阅 HTML 规范。</p>
<pre><code class="language-js">class popupButton extends HTMLButtonElement {}

customElements.define('popup-button', popupButton)
</code></pre>
<p><strong>自定义元素响应</strong></p>
<p>自定义元素可以定义特殊生命周期钩子</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>constructor</td>
<td>创建或升级元素的一个实例。用于初始化状态、设置事件侦听器或创建 Shadow DOM...</td>
</tr>
<tr>
<td>connectedCallback</td>
<td>元素每次插入到 DOM 时都会调用...</td>
</tr>
<tr>
<td>disconnectedCallback()</td>
<td>元素每次从 DOM 中移除时都会调用...</td>
</tr>
<tr>
<td>attributeChangedCallback(attrName, oldVal, newVal)</td>
<td>属性添加、移除、更新或替换...</td>
</tr>
<tr>
<td>adoptedCallback(attrName, oldVal, newVal)</td>
<td>自定义元素被移入新的 document...</td>
</tr>
</tbody>
</table>
<p><a href="https://developers.google.com/web/fundamentals/web-components/customelements#extendhtml">https://developers.google.com/web/fundamentals/web-components/customelements#extendhtml</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements#%E4%BD%BF%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements#使用生命周期回调函数</a></p>
<blockquote>
<p>上面写得很清晰 比我这个容易理解</p>
</blockquote>
<pre><code class="language-js">  // 生命周期钩子
  connectedCallback() {
    // 创建 div
    let div = document.createElement('div')
    div.setAttribute('role', 'popup-info')

    // 创建 img
    let img = document.createElement('img')
    let src = this.getAttribute('img')

    // 创建info信息
    let info = document.createElement('span')
    let text = this.getAttribute('data-text')

    // 设置img内容
    img.src = src
    img.alt = text

    // 设置info内容
    info.classList.add('info')
    info.innerText = text

    // 添加class
    div.classList.add('popup-info')

    // 添加内容 img info
    div.appendChild(img)
    div.appendChild(info)

    this.appendChild(div)
  }
</code></pre>
<p>dom创建时候 创建内容</p>
<pre><code class="language-js">...
  disconnectedCallback() {
    console.log('我没有了呀')
  }
  ...

  // 测试移除 popup-info
const remove = () =&gt; {
  let remove = document.querySelector('#remove')
  remove.onclick = function() {
    document.querySelector('popup-info').remove()
  }
}
remove()
</code></pre>
<p>dom 移除执行的方法 可以移除事件什么的</p>
<pre><code class="language-js">...
  attributeChangedCallback(attrName, oldVal, newVal) {
    console.log('当前的属性:', attrName)
    console.log('当前的属性 old:', oldVal)
    console.log('当前的属性 new:', newVal)
  }
...
  // 测试属性被修改 toggle
const toggle = () =&gt; {
  let i = 0
  let toggle = document.querySelector('#toggle')
  toggle.onclick = function() {
    i++
    document.querySelector('popup-info').setAttribute('role', `popup-info-change, ${i}`)
  }
}
toggle()
</code></pre>
<p>需要注意的是，如果需要在元素属性变化后，触发 attributeChangedCallback()回调函数，你必须监听这个属性。这可以通过定义observedAttributes() get函数来实现，observedAttributes()函数体内包含一个 return语句，返回一个数组，包含了需要监听的属性名称：</p>
<pre><code class="language-js">
  static get observedAttributes() {
    return ['role']
  }

</code></pre>
<p>监听属性变化 调用的方法 比如 role=&quot;popup&quot; 什么的</p>
<pre><code class="language-js">...
  adoptedCallback() {
    console.log('adoptedCallback 自定义元素被移入新的 document')
  }
...

  // 测试 自定义元素被移入新的 document
const testAdoptedCallback = ()=&gt; {
  // 创建 iframe
  const createWindow = () =&gt; {
    let iframe = document.createElement('iframe')
    document.body.appendChild(iframe)
    return iframe.contentWindow
  }
  let cw = createWindow()
  // 创建 自定义元素
  let cw1 = document.querySelector('popup-info')

  // 创建的元素插入到 新创建的iframe
  cw.document.body.appendChild(cw1)
}

const move = () =&gt; {
  let move = document.querySelector('#move')
  move.onclick = function() {
    testAdoptedCallback()
  }
}
move()
</code></pre>
<p>自定义元素被移入新的 document</p>
<p><strong>元素定义的内容</strong></p>
<pre><code class="language-js">class popupInfo extends HTMLElement {
  constructor() {
    super()

  }
  connectedCallback() {
     this.innerHTML = &quot;xxxxxx&quot;;
  }
}
</code></pre>
<p>以新内容覆盖元素的子项并非一种好的做法，因为这样做会不符合设想。
添加元素定义内容的更好做法是使用 shadow DOM，下一篇文章会写</p>
<pre><code class="language-js">class popupInfoShadow extends HTMLElement {
  constructor() {
    super()

    let shadowRoot = this.attachShadow({mode: 'open'})
    shadowRoot.innerHTML = &quot;&lt;span&gt;hello&lt;/span&gt;&quot;
  }

}

customElements.define('popup-info-shadow', popupInfoShadow)
</code></pre>
<img src="Building-Components-Custom-Elements-自定义元素/shadow.png" />
<p><strong>通过 template 创建元素</strong></p>
<pre><code class="language-js">&lt;info-template&gt;&lt;/info-template&gt;

&lt;template id=&quot;info-template&quot;&gt;
  &lt;style&gt;
    p {
      color: red;
    }
  &lt;/style&gt;
  &lt;p&gt;hello template&lt;/p&gt;

&lt;/template&gt;


&lt;script&gt;
class infoTemplate extends HTMLElement {
  constructor(){
    super()

    let shadowRoot = this.attachShadow({mode: 'open'})
    const t = document.querySelector('#info-template')
    const instance = t.content.cloneNode(true)
    shadowRoot.appendChild(instance)
  }
}

customElements.define('info-template', infoTemplate)
</code></pre>
<img src="Building-Components-Custom-Elements-自定义元素/template.png" />
<ul>
<li>我们在 HTML 中定义新的元素：info-template</li>
<li>元素的 Shadow DOM 使用 template 创建</li>
<li>由于是 Shadow DOM，元素的 DOM 局限于元素本地</li>
<li>由于是 Shadow DOM，元素的内部 CSS 作用域限于元素内</li>
</ul>
<p><strong>设置自定义元素样式</strong></p>
<pre><code class="language-css">&lt;style&gt;
p {
  ...
}
&lt;/style&gt;
</code></pre>
<p>:defined CSS 伪类 表示任何已定义的元素。这包括任何浏览器内置的标准元素以及已成功定义的自定义元素 (例如通过 CustomElementRegistry.define() 方法)。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:defined">https://developer.mozilla.org/zh-CN/docs/Web/CSS/:defined</a></p>
<pre><code class="language-css">app-drawer:not(:defined) {}
</code></pre>
<pre><code class="language-html">&lt;style&gt;
info-template {
  color:red;
  opacity: 0;
}
aa-bb:not(:defined) {
  color:red;
  opacity: 0;
}
&lt;/style&gt;

&lt;info-template&gt;&lt;/info-template&gt;
&lt;info-template&gt;123&lt;/info-template&gt;

&lt;aa-bb&gt;123&lt;/aa-bb&gt;
</code></pre>
<img src="Building-Components-Custom-Elements-自定义元素/style.png" />
<p>定义之前会隐藏起来哦</p>
<p><strong>其他详情</strong></p>
<p>未知元素与未定义的自定义元素</p>
<p>HTML 使用起来非常宽松和灵活。例如，在页面上声明 randomtagthatdoesntexist，浏览器将非常乐意接受它。为什么非标准标记可以生效？答案在于 HTML 规范允许这样。规范没有定义的元素作为 HTMLUnknownElement 进行解析。</p>
<p>自定义元素则并非如此。如果在创建时使用有效的名称（包含“-”），则潜在的自定义元素将解析为 HTMLElement。 您可以在支持自定义元素的浏览器中核实这一点。打开控制台：Ctrl+Shift+J（或者在 Mac 上，Cmd+Opt+J）并粘贴下列代码行：</p>
<pre><code class="language-js">// &quot;tabs&quot; is not a valid custom element name
document.createElement('tabs') instanceof HTMLUnknownElement === true

// &quot;x-tabs&quot; is a valid custom element name
document.createElement('x-tabs') instanceof HTMLElement === true
</code></pre>
<p><strong>API 参考</strong></p>
<p>全局性 customElements 定义了处理自定义元素的方法。</p>
<p><strong>define(tagName, constructor, options)</strong></p>
<p>在浏览器中定义新的自定义元素。</p>
<pre><code class="language-js">customElements.define('my-app', class extends HTMLElement { ... });
customElements.define(
  'fancy-button', class extends HTMLButtonElement { ... }, {extends: 'button'});
</code></pre>
<p>抽离出来可以更利于阅读</p>
<p><strong>get(tagName)</strong></p>
<pre><code class="language-js">let Drawer = customElements.get('app-drawer');
console.log(Drawer)
if (Drawer) {
  let drawer = new Drawer();
}


let PopupInfo = customElements.get('popup-info');
console.log(PopupInfo)
if (PopupInfo) {
  let popupInfo = new PopupInfo();
}
</code></pre>
<p>在给定有效自定义元素标记名称的情况下，返回元素的构造函数。</p>
<p>如果没有注册元素定义，则返回 undefined。</p>
<img src="Building-Components-Custom-Elements-自定义元素/get.png" />
<p><strong>whenDefined(tagName)</strong></p>
<pre><code class="language-js">customElements.whenDefined('popup-info').then(() =&gt; {
  console.log('popup-info ready!');
});

customElements.whenDefined('app-drawer').then(() =&gt; {
  console.log('app-drawer ready!');
}).catch(err =&gt; {
  console.log('err', err)
})
</code></pre>
<img src="Building-Components-Custom-Elements-自定义元素/whenDefined.png" />
<p>如果定义了自定义元素，则返回可解析的 Promise。如果元素已定义，则立即得到解析。</p>
<p>如果标记名称并非有效自定义元素名称，则拒绝(好像也不会走catch)</p>
<p><strong>历史记录和浏览器支持</strong></p>
<p>如果您最近几年持续关注网络组件，您应知道 Chrome 36+ 实施的自定义元素 API 版本使用了 document.registerElement() 而不是 customElements.define()。</p>
<p>但前者是标准的弃用版本，称为 v0。customElements.define() 成为现行标准并逐步获得各大浏览器厂商的支持。这称为自定义元素 v1。</p>
<p><a href="https://developers.google.com/web/fundamentals/web-components/customelements">https://developers.google.com/web/fundamentals/web-components/customelements</a></p>
<p><strong>浏览器支持</strong></p>
<p>要检测自定义元素功能，检测是否存在 window.customElements：</p>
<pre><code class="language-js">const supportsCustomElementsV1 = 'customElements' in window;
</code></pre>
<img src="Building-Components-Custom-Elements-自定义元素/in.png" />
<p><strong>Polyfill</strong></p>
<p><a href="https://www.npmjs.com/package/@webcomponents/custom-elements">https://www.npmjs.com/package/@webcomponents/custom-elements</a></p>
<p>注：无法对 :defined CSS 伪类执行 polyfill。 (没测试过)</p>
<pre><code class="language-js">const supportsCustomElementsV1 = 'customElements' in window;
function loadScript(src) {
  return new Promise((resolve, reject) =&gt; {
    const script = document.createElement('script')
    script.src = src
    script.onload = resolve
    script.onerror = reject
    document.head.appendChild(script)
  })
}

if (!supportsCustomElementsV1) {
  loadScript('https://unpkg.com/@webcomponents/custom-elements')
  console.log('use polyfill')
} else {
  // Native support.Good to go.
  console.log('native')
}
</code></pre>
<p>总结:</p>
<p>自定义元素提供了一种新工具，可让我们在浏览器中定义新 HTML 标记并创建可重用的组件。
它们与 Shadow DOM 和 template 等新平台原语结合使用，我们可开始实现更多的可能</p>
<ul>
<li>创建和扩展可重复使用组件的跨浏览器（网络标准）</li>
<li>无需库或框架即可使用。原生 JS/HTML 威武！</li>
<li>提供熟悉的编程模型。仅需使用 DOM/CSS/HTML。</li>
<li>与其他网络平台功能良好匹配（Shadow DOM、template、CSS 自定义属性等）</li>
<li>与浏览器的 DevTools 紧密集成。</li>
<li>利用现有的无障碍功能。</li>
<li>(我也是复制的 2333)</li>
</ul>
<p><a href="https://developers.google.com/web/fundamentals/web-components/customelements">https://developers.google.com/web/fundamentals/web-components/customelements</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements">https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements</a></p>
]]></description>
        </item>
        <item>
            <title><![CDATA[twitter 点赞简易动画]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/31</link>
            <guid>https://github.com/xiaotiandada/blog/issues/31</guid>
            <pubDate>Tue, 19 Jan 2021 06:25:14 GMT</pubDate>
            <description><![CDATA[<p>2019-09-08 16:06:47</p>
<h2>资料</h2>
<p><a href="https://zhuanlan.zhihu.com/p/20486738">https://zhuanlan.zhihu.com/p/20486738</a>
<img src="https://abs.twimg.com/a/1446542199/img/t1/web_heart_animation.png"></p>
<h2>GO</h2>
<ul>
<li>首先去twitter打开控制台下载png的素材</li>
<li>放入一个div</li>
<li>设置css 完事</li>
</ul>
<h2>Js</h2>
<pre><code class="language-js">export default class Render {
  append(parent, dom){
    parent.append(dom)
  }
}


let render =  new Render()

let likeButton = document.createElement('div')
likeButton.classList.add('like-button')


render.append(document.querySelector('body'), likeButton)
</code></pre>
<h2>Css</h2>
<pre><code class="language-css">.like-button {
  width: 50px;
  height: 50px;
  background-position: left;
  background-image: url(https://abs.twimg.com/a/1446542199/img/t1/web_heart_animation.png);
  background-repeat:no-repeat;
  background-size:2900%;
  cursor: pointer;
  &amp;:hover {
    background-position: right;
  }
}

.is-animating {
  animation: heart-burst .8s steps(28) 1 forwards;
}

@keyframes heart-burst { // 从左到右
  0%{
    background-position: left;
  }
  100%{
    background-position: right;
  }
}


</code></pre>
<p>鼠标经过png从 <strong>background-position: left;</strong> 到 <strong>background-position: right;</strong> 变色处理</p>
<p>通过单击添加 class 达到目的</p>
<p><strong>animation: heart-burst .8s steps(28) 1 forwards;</strong> 分为steps 28 执行动画</p>
<h2>js</h2>
<pre><code class="language-js">likeButton.onclick = function() {
  let hasClass = likeButton.classList.contains('is-animating')
  if (!hasClass) likeButton.classList.add('is-animating')
}

likeButton.addEventListener('animationend', function() {
  let hasClass = likeButton.classList.contains('is-animating')
  if (hasClass) likeButton.classList.remove('is-animating')
}) // 根据情况处理
</code></pre>
<p>-- end ---</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[node mysql 增删改查【简易版】]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/30</link>
            <guid>https://github.com/xiaotiandada/blog/issues/30</guid>
            <pubDate>Tue, 19 Jan 2021 06:24:47 GMT</pubDate>
            <description><![CDATA[<p>2019-09-02 14:35:40</p>
<p>学习 node mysql, 然后做了一些简单的增删改查, 小小总结总结 Go!!!</p>
<!-- more -->
<p>资料: <a href="https://www.oschina.net/translate/using-node-mysql-javascript-client">https://www.oschina.net/translate/using-node-mysql-javascript-client</a></p>
<h2>init</h2>
<p>使用 express 初始化</p>
<pre><code class="language-js">const express = require('express')
const app = express()

app.use('/', (req, res) =&gt; {
  res.send(`hello world`)
})

app.listen(3000, () =&gt; console.log('port in 3000'))

</code></pre>
<p>懒得截图, 运行localhost:3000 就能看到hello world (擅长输出hello world 233)</p>
<p>然后添加了nodemon 自动重启</p>
<pre><code class="language-js">yarn add nodemon -D

// package

&quot;dev&quot;: &quot;nodemon index.js&quot;

yarn dev
</code></pre>
<p>方便</p>
<h2>mysql</h2>
<p>npm mysql</p>
<p>文档: <a href="https://www.npmjs.com/package/mysql">https://www.npmjs.com/package/mysql</a></p>
<pre><code class="language-js">var mysql      = require('mysql');
var connection = mysql.createConnection({
  host     : 'localhost',
  user     : 'me',
  password : 'secret',
  database : 'my_db'
});
connection.connect();

connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) {
  if (error) throw error;
  console.log('The solution is: ', results[0].solution);
});

connection.end();
</code></pre>
<p>上面需要根据实际情况修改, 比如说账号密码数据库</p>
<p>数据库我是用 Tool 创建的(不会终端命令 我真垃圾)</p>
<ul>
<li>navicat premium 有免费试用时间</li>
</ul>
<p>然后mysql我是用 brew 下载的 (方便)</p>
<pre><code>brew install mysql
</code></pre>
<p>这里遇到一个问题</p>
<pre><code>Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client
</code></pre>
<p>解决方案:
<a href="https://stackoverflow.com/questions/50093144/mysql-8-0-client-does-not-support-authentication-protocol-requested-by-server">https://stackoverflow.com/questions/50093144/mysql-8-0-client-does-not-support-authentication-protocol-requested-by-server</a></p>
<h2>增</h2>
<p><strong>数据新建了一个image, 设置主键ID key 自增</strong></p>
<pre><code class="language-js">// 插入数据 id自增
const sqlAdd = () =&gt; {
  // posts 表名
  let sqlAdd = 'INSERT INTO image SET ?';
  let sqlAddJson = {
    url: Math.floor(Math.random()*100) + '我是url',
    title: Math.floor(Math.random()*100) + '我是标题'
  }
  connection.query(sqlAdd, sqlAddJson, (err,res) =&gt; {
    if(err) return console.log('INSERT INFO ERROR:',err.message);
    console.log('INSERT INFO', res.insertId);
  });
}
// sqlAdd()

</code></pre>
<h2>删</h2>
<pre><code class="language-js">// 删除数据 id
const sqlDelete = id =&gt; {
  // 通过id查询
  let sql = `DELETE FROM image WHERE id = ?`;
  connection.query(sql, [id] , (err,res) =&gt; {
    if(err) console.log('[DELETE ERROR]:',err.message);
    console.log('DELETE', res.affectedRows);
  });
}
// sqlDelete(2)
</code></pre>
<h2>改</h2>
<pre><code class="language-js">// 更新数据 id
const sqlUpdate = id =&gt; {
  let sqlAddJson = {
    url: Math.floor(Math.random()*100) + '我是url',
    title: Math.floor(Math.random()*100) + '我是标题'
  }
  // 需要改的数据和查询id
  let sqlAdd = `UPDATE image SET url = ?, title = ? WHERE id = ?`;
  connection.query(sqlAdd, [sqlAddJson.url, sqlAddJson.title, id], (err,res) =&gt; {
    if(err) return console.log('UPDATE ERROR:',err.message);
    console.log('UPDATE', res.changedRows);
  });
}
// sqlUpdate(2)
</code></pre>
<h2>查</h2>
<pre><code class="language-js">// 查询数据
const sqlSelect = () =&gt; {
  // 查询那个表
  let sql = 'SELECT * FROM image';
  connection.query(sql,  (err,result) =&gt; {
    if(err) console.log('[SELECT ERROR]:',err.message);
    console.log('result', JSON.stringify(result));  //数据库查询结果返回到result中
  });
}
// sqlSelect()
</code></pre>
<h2>end</h2>
<p>很简易的增删改查 嘿嘿</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[node爬虫 简易版【站酷】]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/29</link>
            <guid>https://github.com/xiaotiandada/blog/issues/29</guid>
            <pubDate>Tue, 19 Jan 2021 06:23:52 GMT</pubDate>
            <description><![CDATA[<p>2019-08-29 13:35:12</p>
<h2>node爬虫 简易版【站酷】</h2>
<p>简单的学习一下node爬虫, 抓取站酷(本来想抓花瓣的,但是因为花瓣是接口调用的 而我想抓dom所以选择了站酷 :)</p>
<!-- more -->
<h2>Result</h2>
<img width="400" src="node爬虫-简易版【站酷】/1.png">
<img width="400" src="node爬虫-简易版【站酷】/2.png">
<h2>资料</h2>
<p><a href="https://github.com/liuxing/mm-spider">https://github.com/liuxing/mm-spider</a></p>
<p>站酷: <a href="https://www.zcool.com.cn">https://www.zcool.com.cn</a></p>
<h2>库</h2>
<pre><code class="language-js">const superagent = require('superagent');
const cheerio = require('cheerio')
const fs = require('fs-extra')
</code></pre>
<p><a href="https://www.npmjs.com/">https://www.npmjs.com/</a> 搜索</p>
<h2>Go</h2>
<h3>获取HTML</h3>
<pre><code class="language-js">const getUrlHtml = async () =&gt; {
  try {
    // 外层定义的id
    const res = await superagent.get(`https://www.zcool.com.cn/?p=${id}`);
    return res.text
  } catch (err) {
    console.error(err);
    return false
  }
}
</code></pre>
<p>使用 superagent 获取html</p>
<p>文档: <a href="https://www.npmjs.com/package/superagent">https://www.npmjs.com/package/superagent</a></p>
<h3>拆Dom</h3>
<pre><code class="language-js">const getDom = (html) =&gt; {
  if (!html) return // 没html返回
  const $ = cheerio.load(html)
  let arr = [] // 储存需要下载的数据
  // 获取dom 循环写入数据
  $('.all-work-list .work-list-box .card-box').each((i, el) =&gt; {
    let img = $(el).find('.card-img a img').attr('src')
    let title = $(el).find('.card-info .card-info-title a').text()
    arr.push({
      title: title.replace(/\//g, ''), // 去掉 / 因为 / 会认为是路径, 根据实际情况来操作
      url: img.replace('@260w_195h_1c_1e_1o_100sh.jpg', '') // 去掉后缀 不使用缩略图 根据实际情况来操作
    })
  })
  return arr
}
</code></pre>
<p>使用 cheerio 操作html</p>
<p>文档: <a href="https://www.npmjs.com/package/cheerio">https://www.npmjs.com/package/cheerio</a></p>
<h3>下载图片</h3>
<pre><code class="language-js">// 睡眠
const sleep = async time =&gt; new Promise(resolve =&gt; setTimeout(resolve, time))
</code></pre>
<pre><code class="language-js">const downloadImg = async arr =&gt; {
  // 先删除文件夹 可以不用这步 因为开始写的时候会重复创建 我又懒得删
  try {
    await fs.remove(path.join(__dirname, `/page${id}`))
  } catch (error) {
    console.log('删除文件夹失败')
  }
  // 创建文件夹 根据id命名
  try {
    await fs.mkdir(path.join(__dirname, `/page${id}` ))
  } catch (error) {
    return console.log('创建文件夹失败')
  }
  // 下载图片
  const download = async item =&gt; {
    await sleep(100) // 睡眠 降低爬虫的速度
    try {
      // 通过 superagent 保存图片
      const req =  superagent.get(item.url)
      // 使用了stream(流)
      req.pipe(fs.createWriteStream(`./page${id}/${item.title}.png`))
      console.log(`下载${item.title}done`)
    } catch (error) {
      return console.log(`下载图片失败${item.title}`, error)
    }
  }

  // 循环arr数据下载图片
  for (const item of arr) await download(item)
}
</code></pre>
<p>使用fs下载图片</p>
<p>文档:</p>
<p><a href="https://www.npmjs.com/package/fs-extra">https://www.npmjs.com/package/fs-extra</a></p>
<p><a href="https://nodejs.org/api/fs.html">https://nodejs.org/api/fs.html</a></p>
<blockquote>
<p>遇到的问题:</p>
<p>下载图片不能使用async await 好像会提前结束 导致下载图片无法使用(具体可以大佬实验的时候打印Error)(可能是我打开方式不对 请大佬赐教)</p>
<p>文件名不能带有 / 会认为是路径</p>
</blockquote>
<h3>All Code</h3>
<details>
<summary>查看所有代码</summary>
<pre><code class="language-js">const superagent = require('superagent');
const cheerio = require('cheerio')
const fs = require('fs-extra')
const path = require('path')

let id = 1
let maxPage = 10

const sleep = async time =&gt; new Promise(resolve =&gt; setTimeout(resolve, time))

const getUrlHtml = async () =&gt; {
  try {
    // 外层定义的id
    const res = await superagent.get(`https://www.zcool.com.cn/?p=${id}`);
    return res.text
  } catch (err) {
    console.error(err);
    return false
  }
}

const getDom = (html) =&gt; {
  if (!html) return // 没html返回
  const $ = cheerio.load(html)
  let arr = [] // 储存需要下载的数据
  // 获取dom 循环写入数据
  $('.all-work-list .work-list-box .card-box').each((i, el) =&gt; {
    let img = $(el).find('.card-img a img').attr('src')
    let title = $(el).find('.card-info .card-info-title a').text()
    arr.push({
      title: title.replace(/\//g, ''), // 去掉 / 因为 / 会认为是路径, 根据实际情况来操作
      url: img.replace('@260w_195h_1c_1e_1o_100sh.jpg', '') // 去掉后缀 不使用缩略图 根据实际情况来操作
    })
  })
  return arr
}

const downloadImg = async arr =&gt; {
  // 先删除文件夹 可以不用这步 因为开始写的时候会重复创建 我又懒得删
  try {
    await fs.remove(path.join(__dirname, `/page${id}`))
  } catch (error) {
    console.log('删除文件夹失败')
  }
  // 创建文件夹 根据id命名
  try {
    await fs.mkdir(path.join(__dirname, `/page${id}` ))
  } catch (error) {
    return console.log('创建文件夹失败')
  }
  // 下载图片
  const download = async item =&gt; {
    await sleep(100) // 睡眠 降低爬虫的速度
    try {
      // 通过 superagent 保存图片
      const req =  superagent.get(item.url)
      // 使用了stream(流)
      req.pipe(fs.createWriteStream(`./page${id}/${item.title}.png`))
      console.log(`下载${item.title}done`)
    } catch (error) {
      return console.log(`下载图片失败${item.title}`, error)
    }
  }

  // 循环arr数据下载图片
  for (const item of arr) await download(item)
}

const init = async () =&gt; {
  for (let i = 0; i &lt; maxPage; i++) {
    let urlHtml = await getUrlHtml()
    let getDate = await getDom(urlHtml)
    await downloadImg(getDate)
    id = i + 1
  }
}

init()

</code></pre>
</details>
<p>源码地址: <a href="https://github.com/xiaotiandada/interest-page/tree/master/crawler">https://github.com/xiaotiandada/interest-page/tree/master/crawler</a></p>
<h2>修改1</h2>
<p>--- 分割线 ---</p>
<p>感谢大佬的指点 ----&gt; QQ 923398776</p>
<h3>资料</h3>
<p><a href="https://andyliwr.github.io/2017/12/05/nodejs_spider_ip/">https://andyliwr.github.io/2017/12/05/nodejs_spider_ip/</a></p>
<h3>使用async控制并发数</h3>
<pre><code class="language-js">  try {
    // async map limit 控制并发数
    async.mapLimit(arr, 20, async item =&gt; download(item, id), (err, results) =&gt; {
      if (err) throw err
      console.log(results)
    })
  } catch (error) {
    console.log(`async.mapLimit${error}`)
  }
</code></pre>
<p>文档: <a href="https://www.npmjs.com/package/async">https://www.npmjs.com/package/async</a></p>
<h3>动态设置UA</h3>
<pre><code class="language-js">    // userAgent
    const userAgents = [ 'Mozilla/5.0 ..'];

    try {
      let userAgent = userAgents[parseInt(Math.random() * userAgents.length)]
      // 通过 superagent 保存图片
      const req =  superagent.get(item.url)
      .set({ 'User-Agent': userAgent })
      // 使用了stream(流)
      req.pipe(fs.createWriteStream(`./page${id}/${item.title}.png`))
      return `下载${item.title}done`
    } catch (error) {
      return console.log(`下载图片失败${item.title}`, error)
    }
  }
</code></pre>
<h3>All Code</h3>
<details>
<summary>查看所有代码</summary>
<pre><code class="language-js">const superagent = require('superagent');
const cheerio = require('cheerio')
const fs = require('fs-extra')
const path = require('path')
const async = require(&quot;async&quot;);

let id = 1
let maxPage = 10

// userAgent
const userAgents = [
  'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.12) Gecko/20070731 Ubuntu/dapper-security Firefox/1.5.0.12',
  'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)',
  'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20',
  'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6',
  'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER',
  'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0) ,Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/1.2.9',
  'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)',
  'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)',
  'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)',
  'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko/20110307 Firefox/4.0b13pre',
  'Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52',
  'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.12) Gecko/20070731 Ubuntu/dapper-security Firefox/1.5.0.12',
  'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)',
  'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6',
  'Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6',
  'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)',
  'Opera/9.25 (Windows NT 5.1; U; en), Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/1.2.9',
  'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36'
]

const getUrlHtml = async () =&gt; {
  try {
    // 外层定义的id
    const res = await superagent.get(`https://www.zcool.com.cn/?p=${id}`);
    return res.text
  } catch (err) {
    console.error(err);
    return false
  }
}

const getDom = (html) =&gt; {
  if (!html) return // 没html返回
  const $ = cheerio.load(html)
  let arr = [] // 储存需要下载的数据
  // 获取dom 循环写入数据
  $('.all-work-list .work-list-box .card-box').each((i, el) =&gt; {
    let img = $(el).find('.card-img a img').attr('src')
    let title = $(el).find('.card-info .card-info-title a').text()
    arr.push({
      title: title.replace(/\//g, ''), // 去掉 / 因为 / 会认为是路径, 根据实际情况来操作
      url: img.replace('@260w_195h_1c_1e_1o_100sh.jpg', '') // 去掉后缀 不使用缩略图 根据实际情况来操作
    })
  })
  return arr
}

const downloadImg = async (arr, id) =&gt; {
  // 先删除文件夹 可以不用这步 因为开始写的时候会重复创建 我又懒得删
  try {
    await fs.remove(path.join(__dirname, `/page${id}`))
  } catch (error) {
    console.log('删除文件夹失败')
  }
  // 创建文件夹 根据id命名
  try {
    await fs.mkdir(path.join(__dirname, `/page${id}` ))
  } catch (error) {
    return console.log('创建文件夹失败')
  }
  // 下载图片
  const download = (item, id) =&gt; {
    try {
      let userAgent = userAgents[parseInt(Math.random() * userAgents.length)]
      // 通过 superagent 保存图片
      const req =  superagent.get(item.url)
      .set({ 'User-Agent': userAgent })
      // 使用了stream(流)
      req.pipe(fs.createWriteStream(`./page${id}/${item.title}.png`))
      return `下载${item.title}done`
    } catch (error) {
      return console.log(`下载图片失败${item.title}`, error)
    }
  }

  try {
    // async map limit 控制并发数
    async.mapLimit(arr, 20, async item =&gt; download(item, id), (err, results) =&gt; {
      if (err) throw err
      console.log(results)
    })
  } catch (error) {
    console.log(`async.mapLimit${error}`)
  }

}

const init = async () =&gt; {
  for (let i = 0; i &lt;= maxPage; i++) {
    let urlHtml = await getUrlHtml()
    let getDate = await getDom(urlHtml)
    await downloadImg(getDate, id)
    id = i + 1
  }
}

init()


</code></pre>
</details>
<blockquote>
<p>不足, 没有动态设置Ip等等, 希望大佬多多指点</p>
</blockquote>
]]></description>
        </item>
        <item>
            <title><![CDATA[ dfs 深度优先搜索【js】]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/28</link>
            <guid>https://github.com/xiaotiandada/blog/issues/28</guid>
            <pubDate>Tue, 19 Jan 2021 06:23:14 GMT</pubDate>
            <description><![CDATA[<p>2019-08-19 12:32:52</p>
<h1>资料</h1>
<p>题目: <a href="https://www.spoj.com/problems/PT07Z/">https://www.spoj.com/problems/PT07Z/</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA)">https://zh.wikipedia.org/wiki/树_(图论)</a></p>
<p>谢谢岛老师的教学</p>
<p><a href="http://www.shuizilong.com/house/">岛娘blog</a></p>
<p><a href="https://github.com/lychees">岛娘Github</a></p>
<p><a href="https://www.youtube.com/channel/UCkGmTVYI7xNW-ffuh5oV71Q">岛娘Youtube</a></p>
<p><a href="https://github.com/xiaotiandada/algorithm">code source</a></p>
<h1>Go</h1>
<p>下面根据上面资料的wiki图来生成的点和边 看不见可能需要科学上网</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/24/Tree_graph.svg/360px-Tree_graph.svg.png">
<p>点: 1 2 3 4 5 6</p>
<p>边: 14 24 34 45 56</p>
<h2>设置顶点</h2>
<p>使用 Map <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map</a></p>
<pre><code class="language-js">let vertexLen = 6; // 顶点数
let vertex = new Map(); // 顶点数据集合 map 可以设置键对值 0 1 2 3 4 5 or 1 2 3 4 5 6 or A B C D E F G ... ...
</code></pre>
<h2>设置顶点和边</h2>
<pre><code class="language-js">/**
 * 设置顶点
 * @param {String || Number} v 顶点
 */
const setVertex = v =&gt; vertex.set(v, []);
/**
 * 设置边
 * @param {String || Number} v1 点
 * @param {String || Number} v2 点
 */
const setVertexEdge = (v1, v2) =&gt; {
  vertex.get(v1).push(v2);
  vertex.get(v2).push(v1);
};

// 设置点
for (let i = 1; i &lt;= vertexLen; i++) setVertex(i);

// 定义边
let vertexEdge = [[1, 4], [2, 4], [3, 4], [4, 5], [5, 6]];

// 设置边
for (let i = 0; i &lt; vertexEdge.length; i++)
  setVertexEdge(vertexEdge[i][0], vertexEdge[i][1]);

</code></pre>
<p>得到的集合</p>
<pre><code class="language-js">Map {
  1 =&gt; [ 4 ],
  2 =&gt; [ 4 ],
  3 =&gt; [ 4 ],
  4 =&gt; [ 1, 2, 3, 5 ],
  5 =&gt; [ 4, 6 ],
  6 =&gt; [ 5 ] }
</code></pre>
<h2>dfs</h2>
<p>vertex 结构目前是这样点 ⬆️️️️️️️️️️ ⬆️️️️️️️️️️ ⬆️️️️️️️️️️</p>
<p>这个方法主要通过存放一个map保存访问状态</p>
<p>参考地址 <a href="https://www.geeksforgeeks.org/implementation-graph-javascript/">https://www.geeksforgeeks.org/implementation-graph-javascript/</a></p>
<pre><code class="language-js">/**
 * dfs
 * @param {String || Number} startNode 开始点
 */
const dfs = startNode =&gt; {
  let visited = new Map(); // 保持和顶点结构一样
  for (let i = 1; i &lt;= vertexLen; i++) visited.set(i, false); // 设置访问状态

  // dfs 方法
  const dfsFunc = (startNode, visited) =&gt; {
    let z = 0; // 长度
    visited.set(startNode, true); // 第一个点设置已访问
    let get_next = vertex.get(startNode); // 获得顶点的所有临接点
    for (let i = 0; i &lt; get_next.length; i++) {
      // 循环临接点
      let get_elem = get_next[i]; // 得到元素
      if (!visited.get(get_elem)) {
        // 是否访问
        z = Math.max(z, dfsFunc(get_elem, visited) + 1); // 增加边数
      }
    }
    return z;
  };
  return dfsFunc(startNode, visited);
};
</code></pre>
<h2>dfs</h2>
<p>下面这个是岛老师👨‍🏫教我方法</p>
<p>主要通过存父节点来判断</p>
<pre><code class="language-js">/**
 * dfs
 * @param {String || Number} startNode 开始点
 */
const dfs1 = startNode =&gt; {
  // 记录开始点和父级节点
  const dfsFunc = (startNode, parentNode = -1) =&gt; {
    let z = 0; // 记录长度
    let get_next = vertex.get(startNode); // 得到相邻节点
    for (let i = 0; i &lt; get_next.length; i++) { // 循环点
      let get_elem = get_next[i]; // 得到点
      if (get_elem === parentNode) continue; // 如果是父节点 跳过
      z = Math.max(z, dfsFunc(get_elem, startNode) + 1); // 递归添加长度
    }
    return z;
  };
  return dfsFunc(startNode);
};

</code></pre>
<details>
<summary>查看所有代码</summary>
<pre><code class="language-js">let vertexLen = 6; // 顶点数
let vertex = new Map(); // 顶点数据集合 map 可以设置键对值 0 1 2 3 4 5 or 1 2 3 4 5 6 or A B C D E F G ... ...

/**
 * 设置顶点
 * @param {String || Number} v 顶点
 */
const setVertex = v =&gt; vertex.set(v, []);
/**
 * 设置边
 * @param {String || Number} v1 点
 * @param {String || Number} v2 点
 */
const setVertexEdge = (v1, v2) =&gt; {
  vertex.get(v1).push(v2);
  vertex.get(v2).push(v1);
};

// 设置点
for (let i = 1; i &lt;= vertexLen; i++) setVertex(i);

// 定义边
let vertexEdge = [[1, 4], [2, 4], [3, 4], [4, 5], [5, 6]];

// 设置边
for (let i = 0; i &lt; vertexEdge.length; i++)
  setVertexEdge(vertexEdge[i][0], vertexEdge[i][1]);

/**
 * dfs
 * @param {String || Number} startNode 开始点
 */
const dfs = startNode =&gt; {
  let visited = new Map(); // 保持和顶点结构一样
  for (let i = 1; i &lt;= vertexLen; i++) visited.set(i, false); // 设置访问状态

  // dfs 方法
  const dfsFunc = (startNode, visited) =&gt; {
    let z = 0; // 长度
    visited.set(startNode, true); // 第一个点设置已访问
    let get_next = vertex.get(startNode); // 获得顶点的所有临接点
    for (let i = 0; i &lt; get_next.length; i++) {
      // 循环临接点
      let get_elem = get_next[i]; // 得到元素
      if (!visited.get(get_elem)) {
        // 是否访问
        z = Math.max(z, dfsFunc(get_elem, visited) + 1); // 增加边数
      }
    }
    return z;
  };
  return dfsFunc(startNode, visited);
};

/**
 * dfs
 * @param {String || Number} startNode 开始点
 */
const dfs1 = startNode =&gt; {
  // 记录开始点和父级节点
  const dfsFunc = (startNode, parentNode = -1) =&gt; {
    let z = 0; // 记录长度
    let get_next = vertex.get(startNode); // 得到相邻节点
    for (let i = 0; i &lt; get_next.length; i++) { // 循环点
      let get_elem = get_next[i]; // 得到点
      if (get_elem === parentNode) continue; // 如果是父节点 跳过
      z = Math.max(z, dfsFunc(get_elem, startNode) + 1); // 递归添加长度
    }
    return z;
  };
  return dfsFunc(startNode);
};

let z = dfs(1);
console.log(z);

let z1 = dfs1(1);
console.log(z1);

console.log(vertex);

</code></pre>
</details>
<hr>
<p>--- 分割线 ---</p>
<p>很遗憾上面的是有问题的</p>
<p><a href="http://www.shuizilong.com/house/archives/pt07z/">岛老师的作业批改</a></p>
<ul>
<li>
<p>数据没有从 IO 读入读出。</p>
</li>
<li>
<p>第一个 dfs 求出的不是最远的端点。</p>
</li>
</ul>
<p>正确的解法应该是先求最深的一个端点,然后用从这个端点再搜索一次.</p>
<blockquote>
<p>因为 js 在 <a href="https://www.spoj.com">https://www.spoj.com</a> 跑不过, 在<a href="http://codeforces.com">http://codeforces.com</a> 可以跑但是没找到题目,然后就选用了c++</p>
</blockquote>
<p>在codeforces js输入输出</p>
<p><a href="http://codeforces.com/blog/entry/10594">http://codeforces.com/blog/entry/10594</a></p>
<p><a href="http://codeforces.com/blog/entry/64707">http://codeforces.com/blog/entry/64707</a></p>
<hr>
<pre><code class="language-c++">// u 开始点 p 父节点
pair&lt;int, int&gt; dfs(int u, int p = -1) {
  // z first 长度 z second 最深点
  // first += 1 second 为 u
  pair&lt;int, int&gt; z = {0, u};
  // for edge u 的 边
  for(auto v: edge[u]) {
    // 如果是父级点 跳过
    if (v == p) continue;
    z = max(z, dfs(v, u));
  }
  // 边+1
  z.first += 1;
  return z;
}
</code></pre>
<details>
<summary>查看所有代码</summary>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

const int N = 1e6;
vector&lt;int&gt; edge[N];

// u 开始点 p 父节点
pair&lt;int, int&gt; dfs(int u, int p = -1) {
  // z first 长度 z second 最深点
  // first += 1 second 为 u
  pair&lt;int, int&gt; z = {0, u};
  // for edge u 的 边
  for(auto v: edge[u]) {
    // 如果是父级点 跳过
    if (v == p) continue;
    z = max(z, dfs(v, u));
  }
  // 边+1
  z.first += 1;
  return z;
}


int main() {
  int n;
  // 输入
  cin &gt;&gt; n;
  
  // 输入端点循环下面的边
  for(int i = 0; i &lt; n - 1; i++) {
    int v, u;
    cin &gt;&gt; v &gt;&gt; u;
    edge[v].push_back(u);
    edge[u].push_back(v);
  }
  
  // 得到最深的端点
  pair&lt;int, int&gt; z = dfs(1);
  // 从最深的端点搜索
  z = dfs(z.second);

  // 边-1
  cout &lt;&lt; z.first-1 &lt;&lt; endl;
}

</code></pre>
</details>
<p>希望看到的大佬可以多多指点迷津!!! 右边有我的联系方式💗💗</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[less循环]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/27</link>
            <guid>https://github.com/xiaotiandada/blog/issues/27</guid>
            <pubDate>Tue, 19 Jan 2021 06:22:42 GMT</pubDate>
            <description><![CDATA[<p>2019-08-16 11:55:30</p>
<p>使用递归调用来循环</p>
<!-- more -->
<h3>less 编译前</h3>
<pre><code class="language-less">.loop(@n) when (@n &gt; 0) {
  div:nth-of-type(@{n}){
    width: (@n*10px);
    height: 40px;
    background: red;
    margin: 10px;
    font-size: 12px;
  }
  .loop(@n - 1);
}

.loop(5);
</code></pre>
<h3>css 编译后</h3>
<pre><code class="language-css">div:nth-of-type(5) {
  width: 50px;
  height: 40px;
  background: red;
  margin: 10px;
  font-size: 12px;
}
div:nth-of-type(4) {
  width: 40px;
  height: 40px;
  background: red;
  margin: 10px;
  font-size: 12px;
}
div:nth-of-type(3) {
  width: 30px;
  height: 40px;
  background: red;
  margin: 10px;
  font-size: 12px;
}
div:nth-of-type(2) {
  width: 20px;
  height: 40px;
  background: red;
  margin: 10px;
  font-size: 12px;
}
div:nth-of-type(1) {
  width: 10px;
  height: 40px;
  background: red;
  margin: 10px;
  font-size: 12px;
}
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[Safari等浏览器 border-eadius失效...]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/26</link>
            <guid>https://github.com/xiaotiandada/blog/issues/26</guid>
            <pubDate>Tue, 19 Jan 2021 06:22:20 GMT</pubDate>
            <description><![CDATA[<p>2019-08-02 11:34:33</p>
<p>今天产品反馈了一个<strong>Bug</strong>说是鼠标经过,图片会 <strong>圆角=》无圆角=》圆角</strong> 的过程来变化</p>
<p>懒得贴图, 搜到这个文章肯定就会发生了hhh</p>
<p>增加解决方案,方便更快搜到问题</p>
<h2>解决方案</h2>
<p>给他的<strong>父级</strong>添加 transform</p>
<pre><code class="language-css">transform: rotate(0deg);
/* 懒得加 -webkit */
</code></pre>
<h2>结论</h2>
<p>我还不知道为什么会这样(可能是浏览器的解析不同???)</p>
<h2>脑洞</h2>
<p>猜测影响失效的原因</p>
<ul>
<li>transition 去掉这个可以解决!!!但是没有动画只会很难看 不可取</li>
<li>transform 猜测</li>
<li>xxxxx</li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[lodash 学习]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/25</link>
            <guid>https://github.com/xiaotiandada/blog/issues/25</guid>
            <pubDate>Tue, 19 Jan 2021 06:21:06 GMT</pubDate>
            <description><![CDATA[<p>2019-07-21 18:39:45</p>
<p>lodash 学习</p>
<p><a href="https://lodash.com/docs/4.17.15">https://lodash.com/docs/4.17.15</a>
<a href="https://github.com/lodash/lodash">https://github.com/lodash/lodash</a></p>
<!-- more -->
<h2>一、lodash 源码方法 初探</h2>
<p>先看看一些简单的方法实现</p>
<p>如果全部贴出来的话, 太占地方了 不方便查阅 下面提供 <a href="https://github.com/xiaotiandada/lodash"><strong>repo地址</strong></a></p>
<p>以文件区分了每个方法 方便</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[文章分享]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/24</link>
            <guid>https://github.com/xiaotiandada/blog/issues/24</guid>
            <pubDate>Tue, 19 Jan 2021 05:12:32 GMT</pubDate>
            <description><![CDATA[<ul>
<li>
<p><a href="https://css-tricks.com/position-sticky-and-table-headers/?unapproved=1748290&amp;moderation-hash=d1f92665656ca041fa89843eaa10b10f#comment-1748290">Position Sticky and Table Headers【表格头部固定】</a></p>
</li>
<li>
<p><a href="https://css-tricks.com/managing-multiple-backgrounds-with-custom-properties/?unapproved=1749263&amp;moderation-hash=4b2fa24b7eca1c9d9f90251a3d1ebe93#comment-1749263">Managing Multiple Backgrounds with Custom Properties【使用自定义属性管理多个背景】</a></p>
</li>
<li>
<p><a href="https://css-tricks.com/multi-line-truncation-with-pure-css/">multi-line-truncation-with-pure-css【使用纯CSS进行多行截断】</a></p>
</li>
</ul>
]]></description>
        </item>
        <item>
            <title><![CDATA[chrome extensions 开发中遇到的坑]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/23</link>
            <guid>https://github.com/xiaotiandada/blog/issues/23</guid>
            <pubDate>Tue, 19 Jan 2021 05:09:49 GMT</pubDate>
            <description><![CDATA[<p>2019-07-16 00:30:58</p>
<p><strong>记录自己开发chrome extension中遇到的坑(🍑</strong></p>
<h2>开发环境</h2>
<p>vue</p>
<blockquote>
<p>使用下面资料提供的模版, 快速入坑(🍑</p>
</blockquote>
<h2>Dev</h2>
<pre><code class="language-bash">npm i

npm run watch:dev
</code></pre>
<blockquote>
<p>会自动build, 使用dist目录即可</p>
</blockquote>
<h2>Build</h2>
<pre><code class="language-bash">npm run build/npm run build:dev

npm run build-zip
</code></pre>
<h2>资料</h2>
<p><a href="https://developer.chrome.com/extensions">https://developer.chrome.com/extensions</a></p>
<p><a href="https://github.com/sxei/chrome-plugin-demo">https://github.com/sxei/chrome-plugin-demo</a></p>
<p><a href="https://github.com/Kocal/vue-web-extension">https://github.com/Kocal/vue-web-extension</a> (模版)</p>
<blockquote>
<p>希望大家多看看文档和第二个连接的文章写的非常好(Good ❗️️️❗️❗️️)</p>
</blockquote>
<p>--- 2019-7-15 ---</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[svg动画用复杂交互动画改善用户体验-练习]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/22</link>
            <guid>https://github.com/xiaotiandada/blog/issues/22</guid>
            <pubDate>Tue, 19 Jan 2021 05:08:18 GMT</pubDate>
            <description><![CDATA[<p>2019-07-07 23:53:32</p>
<p><a href="https://codepen.io/sdras/pen/BKaYyG">书籍Demo</a>
<a href="https://github.com/xiaotiandada/Case/tree/master/svg%E5%8A%A8%E7%94%BB%E7%94%A8%E5%A4%8D%E6%9D%82%E4%BA%A4%E4%BA%92%E5%8A%A8%E7%94%BB%E6%94%B9%E5%96%84%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C-%E7%BB%83%E4%B9%A0/%E4%B8%8D%E5%AE%9E%E7%94%A8%E9%A2%9D%E5%A4%96%E7%9A%84%E5%BA%93%E6%9D%A5%E5%88%9B%E5%BB%BAUI%7CUX%E5%8A%A8%E7%94%BB">源码</a></p>
<p><a href="https://codei.netlify.com/gist/b4c50cbd51edb77d431fe4d5929128ab">https://codei.netlify.com/gist/b4c50cbd51edb77d431fe4d5929128ab</a></p>
<h3>HTML</h3>
<p>随意写的,主要用svg画一些线条和圆,具体的大家可以参考svg文档把</p>
<pre><code class="language-html">  ...
  &lt;svg class=&quot;magnifier&quot; vieBox=&quot;0 0 300 46&quot;&gt;
    &lt;!-- 圆 --&gt;
    &lt;circle class=&quot;magnifier-c&quot; cx=&quot;20&quot; cy=&quot;20&quot; r=&quot;16&quot; fill=&quot;none&quot; stroke=&quot;#fff&quot;&gt;&lt;/circle&gt;
    &lt;!-- 线 --&gt;
    &lt;line class=&quot;magnifier-l-c&quot; x1=&quot;10&quot; y1=&quot;10&quot; x2=&quot;20&quot; y2=&quot;20&quot; fill=&quot;none&quot; stroke=&quot;#fff&quot; /&gt;
  &lt;/svg&gt;
  ...
</code></pre>
<h3>CSS</h3>
<p>css部分写得比较乱(我真垃圾!!!)</p>
<p>主要通过Element添加class来切换(能用css的就不用js)</p>
<p>随便贴一点意思意思emmm</p>
<pre><code class="language-css">.magnifier-l-c,
 .line-line,
 .main input {
  /* 避免引起回流 */
  visibility: hidden;
  opacity: 0;
}

.magnifier.open .magnifier-l-c, 
.main.open .line-line,
.main.open input {
  /* 避免引起回流 */
  visibility: visible;
  opacity: 1;
}
</code></pre>
<h3>JS</h3>
<pre><code class="language-js">// 获取Element
let magnifier = document.querySelector('.magnifier')
let main = document.querySelector('.main')
let line = document.querySelector('.line')
// set click
magnifier.onclick = function() {
  // 判断是否有class
  let hasOpen = magnifier.classList.contains('open')
  console.log(hasOpen)
  // 设置 class
  if (hasOpen) {
    magnifier.classList.remove('open')
    main.classList.remove('open')
    line.classList.remove('open')
  } else {
    magnifier.classList.add('open')
    main.classList.add('open')
    line.classList.add('open')
  }
}
</code></pre>
<p>okk了, 大概就这么多,然后具体的可以看源码和书籍Demo</p>
<p><a href="https://codepen.io/sdras/pen/BKaYyG">书籍Demo</a>
[源码](</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[网易云APP启动界面【模仿】]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/21</link>
            <guid>https://github.com/xiaotiandada/blog/issues/21</guid>
            <pubDate>Tue, 19 Jan 2021 05:05:27 GMT</pubDate>
            <description><![CDATA[<p>2019-07-04 22:24:23</p>
<p>第一次还原这样的效果吧(我真菜😢😢😢!!!), 完成度70-80%(叹气😕)</p>
<p><a href="https://github.com/xiaotiandada/interest-page">项目地址</a></p>
<!-- more -->
<p><strong>预览</strong></p>
<img width="300" src="网易云APP启动界面【模仿】/app1.png" />
<img width="300" src="网易云APP启动界面【模仿】/app2.png" />
<h3>素材</h3>
<ul>
<li><a href="https://www.lottiefiles.com/">https://www.lottiefiles.com/</a> 我从这里找的,有源文件和JSON</li>
</ul>
<h3>工具</h3>
<ul>
<li>
<p>工具</p>
<ul>
<li>AE</li>
<li>PS</li>
<li>PxCook</li>
</ul>
</li>
<li>
<p>Code</p>
<ul>
<li><a href="https://github.com/airbnb/lottie-web">lottie-web</a></li>
<li>webpack (辅助)</li>
</ul>
</li>
</ul>
<h3>还原过程</h3>
<h4>简单的适配</h4>
<pre><code class="language-js">let htmlWidth = document.documentElement.clientWidth || document.body.clientWidth
let htmlDom = document.querySelector('html')
htmlDom.style.fontSize = htmlWidth / 10 + 'px'
</code></pre>
<p>其实适配的方法有很多种,个人比较懒就简单的搜哈先 下面给大家贴出了一些文章</p>
<ul>
<li>
<p><a href="https://www.imweb.io/topic/5a523cc0a192c3b460fce3a5">https://www.imweb.io/topic/5a523cc0a192c3b460fce3a5</a></p>
</li>
<li>
<p><a href="http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/">http://www.alloyteam.com/2016/03/mobile-web-adaptation-tool-rem/</a></p>
</li>
<li>
<p><a href="https://segmentfault.com/a/1190000007526917">https://segmentfault.com/a/1190000007526917</a></p>
</li>
<li>
<p><a href="https://www.google.com/">Google</a></p>
</li>
</ul>
<p>手淘的方案也非常好,挺好用的 <a href="https://github.com/amfe/lib-flexible">https://github.com/amfe/lib-flexible</a></p>
<p><strong>Vant的方案</strong></p>
<pre><code class="language-js">// Rem 适配
// Vant 中的样式默认使用px作为单位，如果需要使用rem单位，推荐使用以下两个工具

// postcss-pxtorem 是一款 postcss 插件，用于将单位转化为 rem
// lib-flexible 用于设置 rem 基准值
// 下面提供了一份基本的 postcss 配置，可以在此配置的基础上根据项目需求进行修改

module.exports = {
  plugins: {
    'autoprefixer': {
      browsers: ['Android &gt;= 4.0', 'iOS &gt;= 7']
    },
    'postcss-pxtorem': {
      rootValue: 37.5,
      propList: ['*']
    }
  }
}
</code></pre>
<blockquote>
<p><a href="https://youzan.github.io/vant/#/zh-CN/quickstart">https://youzan.github.io/vant/#/zh-CN/quickstart</a></p>
</blockquote>
<h3>素材导出</h3>
<p><strong>bodymovin</strong></p>
<ul>
<li>
<p>使用Ae的插件bodymovin导出Json文件, 我们装上之后把一些用不到的元素按钮隐藏先. 教程靠大家自己<a href="https://www.google.com/">Google</a>了</p>
</li>
<li>
<p>然后需要psd的可以在AE中导出(方法一样Google 233😏😏😏)</p>
</li>
<li>
<p>icon可以在PSD导出, 然后尺寸什么的在PxCook Ps了吗标注,量尺寸什么的,甚至在在线的标注工具标记(方法很多🤨🤨🤨)</p>
</li>
</ul>
<h3>使用Lottie</h3>
<pre><code class="language-js">npm install lottie-web

lottie.loadAnimation({
  container: element, // the dom element that will contain the animation
  renderer: 'svg',
  loop: true,
  autoplay: true,
  path: 'data.json' // the path to the animation json
});
</code></pre>
<p>基本的使用还是很简单的👨🏻‍💻</p>
<p>我们可以看见下面有时间轴, 可以看到动画时长什么的,然后我根据这个还原出来的效果不尽人意,(自己太菜 慢慢学习怎么还原这样的稿吧🙁🙁🙁)</p>
<p><img src="%E7%BD%91%E6%98%93%E4%BA%91APP%E5%90%AF%E5%8A%A8%E7%95%8C%E9%9D%A2%E3%80%90%E6%A8%A1%E4%BB%BF%E3%80%91/1.png" alt=""></p>
<blockquote>
<p>查看动画时间</p>
</blockquote>
<pre><code class="language-css">  animation: logo-button-bottom 1.5s;
  animation-fill-mode: forwards;
</code></pre>
<p><img src="%E7%BD%91%E6%98%93%E4%BA%91APP%E5%90%AF%E5%8A%A8%E7%95%8C%E9%9D%A2%E3%80%90%E6%A8%A1%E4%BB%BF%E3%80%91/2.png" alt=""></p>
<blockquote>
<p>查看效果执行</p>
</blockquote>
<pre><code class="language-css">@keyframes logo-button-bottom {
  0% {
    transform: translate(-50%, 80/75rem);
    opacity: 0;
  }
  20% {
    opacity: 1;
  }
  100% {
    opacity: 1;
    transform: translate(-50%, 0);
  }
}
</code></pre>
<p><img src="%E7%BD%91%E6%98%93%E4%BA%91APP%E5%90%AF%E5%8A%A8%E7%95%8C%E9%9D%A2%E3%80%90%E6%A8%A1%E4%BB%BF%E3%80%91/3.png" alt=""></p>
<blockquote>
<p>查看效果的动画曲线</p>
</blockquote>
<pre><code class="language-css">animation: logo-button-bottom 1.5s ease-out;
</code></pre>
<p>大概就是这么多了吧... ... 看了看 垃圾文章无疑了 2333</p>
<p>开了个Qq群，大家也可以进来互相交流~ iD 718639024</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[ShuffleanArray]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/20</link>
            <guid>https://github.com/xiaotiandada/blog/issues/20</guid>
            <pubDate>Tue, 19 Jan 2021 05:04:32 GMT</pubDate>
            <description><![CDATA[<p>2019-06-13 00:06:35</p>
<p>Shuffle an Array (carry)
<a href="http://www.jstips.co/en/javascript/shuffle-an-array/">Shuffle an Array</a></p>
<p>This snippet here uses Fisher-Yates Shuffling Algorithm to shuffle a given array.</p>
<p><a href="https://www.wikiwand.com/en/Fisher%E2%80%93Yates_shuffle">Fisher-Yates Shuffling</a>
<a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates Shuffling</a></p>
<!-- more -->
<h2>example</h2>
<pre><code class="language-js">function shuffle(arr) {
    var i,
        j,
        temp;
    for (i = arr.length - 1; i &gt; 0; i--) {
        j = Math.floor(Math.random() * (i + 1));
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    return arr;    
};

var a = [1, 2, 3, 4, 5, 6, 7, 8];
var b = shuffle(a);
console.log(b);
// [2, 7, 8, 6, 5, 3, 1, 4]

</code></pre>
<h2>self</h2>
<pre><code class="language-js">let arr = [1,2,3,4,5,6,7,8]
const shuffle = arr =&gt; {
  // 7 6 5 4 ... 2 1
  for(let i = arr.length - 1; i &gt; 0; i--) {
    let temp = null
    let j = null
    // 0-7 0-6 0-5 ... ... 0-1
    j = Math.floor(Math.random() * (i + 1))
    temp = arr[j]
    arr[j] = arr[i]
    arr[i] = temp
  }
  return arr
}

console.log(shuffle(arr))

// [8, 4, 2, 3, 6, 1, 5, 7]
// [5, 4, 7, 3, 1, 6, 8, 2]
// [4, 5, 6, 8, 1, 2, 3, 7]
// [7, 5, 3, 4, 6, 8, 1, 2]
// [5, 7, 6, 3, 2, 1, 8, 4]
// [7, 6, 5, 3, 1, 8, 2, 4]
// [5, 6, 7, 8, 3, 1, 4, 2]
// [8, 3, 1, 7, 4, 5, 6, 2]
// [5, 8, 1, 4, 6, 7, 3, 2]
// [6, 5, 4, 2, 8, 3, 7, 1]

</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[CodeNote]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/19</link>
            <guid>https://github.com/xiaotiandada/blog/issues/19</guid>
            <pubDate>Tue, 19 Jan 2021 05:04:09 GMT</pubDate>
            <description><![CDATA[<p>2019-04-14 16:49:16</p>
<h3>正则</h3>
<pre><code class="language-js">// 判断字符串是否为数字
reg = /^[0-9]*$/;

// 判断字符串是否为数字 开头为1-9
reg = /^\+?[1-9][0-9]*$/;
reg.test('12323123123213213213')

// 小数点后三位 如果后面需要解除限制修改正则  {0,3}
value.match(/^\d*(\.?\d{0,3})/g)[0] || null;

</code></pre>
<p><a href="http://www.runoob.com/regexp/regexp-syntax.html">正则表达式 - 语法</a>
<a href="https://c.runoob.com/front-end/854">正则表达式在线测试 常用正则表达式</a></p>
<p>记录一些 CodeNote</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Echarts系列之复制粘贴大法]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/18</link>
            <guid>https://github.com/xiaotiandada/blog/issues/18</guid>
            <pubDate>Tue, 19 Jan 2021 05:03:32 GMT</pubDate>
            <description><![CDATA[<p>2018-12-17 20:33:08</p>
<h1>Echarts 系列之复制粘贴大法</h1>
<blockquote>
<p>最近在耍 Echarts 稍微有点小经验，写(熬)篇文章记录一下下~</p>
<p>话不多说，直接开始(开始复制粘贴) hhhhh~~</p>
<p>开发中也有找类似的图表直接修改 附上链接
<a href="http://echarts.baidu.com/examples/#chart-type-pie">官方链接</a> &gt; <a href="http://gallery.echartsjs.com/explore.html#sort=rank~timeframe=all~author=all">社区-GALLERY</a></p>
<p><a href="https://github.com/xiaotiandada/Case">仓库地址</a> <a href="https://xiaotiandada.github.io/Case/Echarts/">预览地址</a> <a href="https://xiaotiandada.github.io/2018/12/17/Echarts%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%A4%A7%E6%B3%95/#more">文章地址</a></p>
</blockquote>
<!-- more -->
<h2>饼图</h2>
<h3>Doughnut Chart</h3>
<blockquote>
<p><a href="http://www.echartsjs.com/examples/editor.html?c=pie-doughnut">链接</a></p>
</blockquote>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart.png' />
</div>
<p>官方给出了 demo 其实也还挺好看的，只是不适合直接放在业务里面(需要变变色，变色大小什么的)</p>
<p>让我们一步步改造他吧。</p>
<pre><code class="language-js">let json = {
  ...
   legend: {
     ...
    icon: &quot;circle&quot;,  // legend icon形状 也可以自定义
  },
  series: [{
    name: &quot;甜甜圈&quot;,
    type: &quot;pie&quot;,
    radius: [&quot;30%&quot;, &quot;60%&quot;], // 'radius' 扇区圆心角展现数据的百分比，半径展现数据的大小。
    center: [&quot;50%&quot;, &quot;50%&quot;], // 饼图的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标。
    color: [&quot;#1976D2&quot;, &quot;#2196F3&quot;, &quot;#03A9F4&quot;], // 颜色
    ...
  }]
}
</code></pre>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart1.png' />
</div>
<blockquote>
<p>是不是很简单！感觉都没什么好写的 23333(继续改，后面使用上面的 json)。</p>
<p><a href="https://github.com/xiaotiandada/Case">仓库地址</a></p>
<p>有时候会遇到这种空心圆中间放 icon 图片的时候 于是就有下图</p>
</blockquote>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart2.png' />
</div>
<pre><code class="language-js">let json = {
  ...
    // graphic 是原生图形元素组件。可以支持的图形元素包括：
    // image, text, circle, sector, ring, polygon, polyline, rect, line, bezierCurve, arc, group,
   graphic: {
    type: &quot;image&quot;,
    left: &quot;center&quot;,  // 位置
    top: &quot;center&quot;,   // 位置
    style: {
      image: &quot;chartsGraphic.png&quot;,  // 路径
      width: 100,                  // 宽高
      height: 100
    }
  },
  ...
}
</code></pre>
<p><a href="http://www.echartsjs.com/option.html#graphic">文档地址</a></p>
<p>继续复制粘贴 emmmm</p>
<p>如果很多个标题，设计稿放在两边！ （xiaochangmian）</p>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart3.png' />
</div>
<pre><code class="language-js">let json = {
  ...
  // 将legend 变成数组形式，左右各一个
    legend: [{
      x: &quot;left&quot;,
      itemGap: 30,
      icon: &quot;circle&quot;,
      data: []      // 里面存放名字
    },
    {
      x: &quot;right&quot;,
      itemGap: 30,
      icon: &quot;circle&quot;,
      data: []   // 里面存放名字
    }
  ],
  ...
}

// 我自己写了一个方法存进去，可供参考
// 传入数据和 json 配置
// 数字可以抽离出来，大家可以自行改造(或者取长度/2 需要算上单数情况)
function setChartsAreaLength(areaName, json) {
let arr1 = [],
arr2 = [];
areaName.map((item, index) =&gt; {
index &lt; 8 ? (arr1 = [...arr1, item]) : (arr2 = [...arr2, item]);
});
json.legend[0].data = arr1;
json.legend[1].data = arr2;
}

</code></pre>
<h3>Referer of a website</h3>
<p>于是继续搞</p>
<p>这个同第一个 改改颜色就好了 然后隐藏标线和文字</p>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart4.png' />
</div>
<pre><code class="language-js">let json = {
  ...
   series: [{
    data: [],
    label: {
      show: false // 是否显示标示文字
    },
    labelLine: {
      show: false // 是否显示视觉引导线
    }
  }]
  ...
};
</code></pre>
<h3>Nested Pies</h3>
<blockquote>
<p>嵌套饼图</p>
</blockquote>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart5.png' />
</div>
<pre><code class="language-js">let json = {
  ...
  // 将legend 变成数组形式，左右各一个
    legend: [{
      data: ['白天', '晚上']
    },
    {
      data: ['上班', '游戏', '休息']
    }
  ],
   series: [{
      radius: [0, '36%'],    // 饼图大小  内饼图 从0-36%
      data: [{
          value: 12,
          name: '白天',
        },
        {
          value: 12,
          name: '晚上'
        }
      ]
    },
    {
      name: '分类',
      type: 'pie',
      radius: ['44%', '72%'],  // 饼图大小  内饼图 从44%-75%
      data: [{
          value: 335,
          name: '上班'
        },
        {
          value: 310,
          name: '游戏'
        }, {
          value: 300,
          name: '休息'
        }
      ]
    }
  ]
  ...
}
</code></pre>
<blockquote>
<p>2018-12-24 更</p>
</blockquote>
<p>嵌套饼图有时候可能文字需要在图表上面,让我们一起来改造改造</p>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart6.png' />
</div>
<pre><code class="language-js">let json = {
  ...
  // 配置和上一个饼图一模一样
   series: [{
     label: {
        show: true,            // 显示折线文字(好像默认显示)
        color: '#fff',        // 文字颜色
        position: 'inside'    // 显示位置
      },
      labelLine: {
        show: false          // 内饼图文字在图上方 不需要折线
      },
    },
    {
    label: {
          show: true,       // 同上
          color: '#fff'
        },
        labelLine: {
          show: true,       // 需要折线(可自行扩展)
        },
      }
  ]
  ...
}

</code></pre>
<blockquote>
<p>大家也可以自行发挥，我看社区里面的大佬发的饼图非常强大也很好看，开发中都可以直接拿过去用(节省开发时间)hhh,
后面我还会继续更新这篇文章的，目前在公司一直都是 jq 所以这些都是原生的，后面也会出 Vue Or React 里面使用的(hhh)</p>
</blockquote>
<p>如果阅读中，有什么不明白的 可以问我，也可以去群里交流</p>
<p>Qq：952822399</p>
<p>Qq 群 iD 718639024</p>
<p>大家也可以进来互相交流~</p>
<p>最后就是厚脸皮的一步(觉得不错可以点个 star 哦~~~) <a href="https://github.com/xiaotiandada/E-video">仓库地址</a></p>
<p>同时也欢迎 Pr 帮我修复不正确的地方！！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[ Echarts系列之复制粘贴大法]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/17</link>
            <guid>https://github.com/xiaotiandada/blog/issues/17</guid>
            <pubDate>Tue, 19 Jan 2021 05:02:53 GMT</pubDate>
            <description><![CDATA[<p>2018-12-17 20:33:08</p>
<h1>Echarts 系列之复制粘贴大法</h1>
<blockquote>
<p>最近在耍 Echarts 稍微有点小经验，写(熬)篇文章记录一下下~</p>
<p>话不多说，直接开始(开始复制粘贴) hhhhh~~</p>
<p>开发中也有找类似的图表直接修改 附上链接
<a href="http://echarts.baidu.com/examples/#chart-type-pie">官方链接</a> &gt; <a href="http://gallery.echartsjs.com/explore.html#sort=rank~timeframe=all~author=all">社区-GALLERY</a></p>
<p><a href="https://github.com/xiaotiandada/Case">仓库地址</a> <a href="https://xiaotiandada.github.io/Case/Echarts/">预览地址</a> <a href="https://xiaotiandada.github.io/2018/12/17/Echarts%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%A4%A7%E6%B3%95/#more">文章地址</a></p>
</blockquote>
<!-- more -->
<h2>饼图</h2>
<h3>Doughnut Chart</h3>
<blockquote>
<p><a href="http://www.echartsjs.com/examples/editor.html?c=pie-doughnut">链接</a></p>
</blockquote>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart.png' />
</div>
<p>官方给出了 demo 其实也还挺好看的，只是不适合直接放在业务里面(需要变变色，变色大小什么的)</p>
<p>让我们一步步改造他吧。</p>
<pre><code class="language-js">let json = {
  ...
   legend: {
     ...
    icon: &quot;circle&quot;,  // legend icon形状 也可以自定义
  },
  series: [{
    name: &quot;甜甜圈&quot;,
    type: &quot;pie&quot;,
    radius: [&quot;30%&quot;, &quot;60%&quot;], // 'radius' 扇区圆心角展现数据的百分比，半径展现数据的大小。
    center: [&quot;50%&quot;, &quot;50%&quot;], // 饼图的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标。
    color: [&quot;#1976D2&quot;, &quot;#2196F3&quot;, &quot;#03A9F4&quot;], // 颜色
    ...
  }]
}
</code></pre>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart1.png' />
</div>
<blockquote>
<p>是不是很简单！感觉都没什么好写的 23333(继续改，后面使用上面的 json)。</p>
<p><a href="https://github.com/xiaotiandada/Case">仓库地址</a></p>
<p>有时候会遇到这种空心圆中间放 icon 图片的时候 于是就有下图</p>
</blockquote>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart2.png' />
</div>
<pre><code class="language-js">let json = {
  ...
    // graphic 是原生图形元素组件。可以支持的图形元素包括：
    // image, text, circle, sector, ring, polygon, polyline, rect, line, bezierCurve, arc, group,
   graphic: {
    type: &quot;image&quot;,
    left: &quot;center&quot;,  // 位置
    top: &quot;center&quot;,   // 位置
    style: {
      image: &quot;chartsGraphic.png&quot;,  // 路径
      width: 100,                  // 宽高
      height: 100
    }
  },
  ...
}
</code></pre>
<p><a href="http://www.echartsjs.com/option.html#graphic">文档地址</a></p>
<p>继续复制粘贴 emmmm</p>
<p>如果很多个标题，设计稿放在两边！ （xiaochangmian）</p>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart3.png' />
</div>
<pre><code class="language-js">let json = {
  ...
  // 将legend 变成数组形式，左右各一个
    legend: [{
      x: &quot;left&quot;,
      itemGap: 30,
      icon: &quot;circle&quot;,
      data: []      // 里面存放名字
    },
    {
      x: &quot;right&quot;,
      itemGap: 30,
      icon: &quot;circle&quot;,
      data: []   // 里面存放名字
    }
  ],
  ...
}

// 我自己写了一个方法存进去，可供参考
// 传入数据和 json 配置
// 数字可以抽离出来，大家可以自行改造(或者取长度/2 需要算上单数情况)
function setChartsAreaLength(areaName, json) {
let arr1 = [],
arr2 = [];
areaName.map((item, index) =&gt; {
index &lt; 8 ? (arr1 = [...arr1, item]) : (arr2 = [...arr2, item]);
});
json.legend[0].data = arr1;
json.legend[1].data = arr2;
}

</code></pre>
<h3>Referer of a website</h3>
<p>于是继续搞</p>
<p>这个同第一个 改改颜色就好了 然后隐藏标线和文字</p>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart4.png' />
</div>
<pre><code class="language-js">let json = {
  ...
   series: [{
    data: [],
    label: {
      show: false // 是否显示标示文字
    },
    labelLine: {
      show: false // 是否显示视觉引导线
    }
  }]
  ...
};
</code></pre>
<h3>Nested Pies</h3>
<blockquote>
<p>嵌套饼图</p>
</blockquote>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart5.png' />
</div>
<pre><code class="language-js">let json = {
  ...
  // 将legend 变成数组形式，左右各一个
    legend: [{
      data: ['白天', '晚上']
    },
    {
      data: ['上班', '游戏', '休息']
    }
  ],
   series: [{
      radius: [0, '36%'],    // 饼图大小  内饼图 从0-36%
      data: [{
          value: 12,
          name: '白天',
        },
        {
          value: 12,
          name: '晚上'
        }
      ]
    },
    {
      name: '分类',
      type: 'pie',
      radius: ['44%', '72%'],  // 饼图大小  内饼图 从44%-75%
      data: [{
          value: 335,
          name: '上班'
        },
        {
          value: 310,
          name: '游戏'
        }, {
          value: 300,
          name: '休息'
        }
      ]
    }
  ]
  ...
}
</code></pre>
<blockquote>
<p>2018-12-24 更</p>
</blockquote>
<p>嵌套饼图有时候可能文字需要在图表上面,让我们一起来改造改造</p>
<div align='center'>
  <img width="360px" src='Echarts系列之复制粘贴大法/DoughnutChart6.png' />
</div>
<pre><code class="language-js">let json = {
  ...
  // 配置和上一个饼图一模一样
   series: [{
     label: {
        show: true,            // 显示折线文字(好像默认显示)
        color: '#fff',        // 文字颜色
        position: 'inside'    // 显示位置
      },
      labelLine: {
        show: false          // 内饼图文字在图上方 不需要折线
      },
    },
    {
    label: {
          show: true,       // 同上
          color: '#fff'
        },
        labelLine: {
          show: true,       // 需要折线(可自行扩展)
        },
      }
  ]
  ...
}

</code></pre>
<blockquote>
<p>大家也可以自行发挥，我看社区里面的大佬发的饼图非常强大也很好看，开发中都可以直接拿过去用(节省开发时间)hhh,
后面我还会继续更新这篇文章的，目前在公司一直都是 jq 所以这些都是原生的，后面也会出 Vue Or React 里面使用的(hhh)</p>
</blockquote>
<p>如果阅读中，有什么不明白的 可以问我，也可以去群里交流</p>
<p>Qq：952822399</p>
<p>Qq 群 iD 718639024</p>
<p>大家也可以进来互相交流~</p>
<p>最后就是厚脸皮的一步(觉得不错可以点个 star 哦~~~) <a href="https://github.com/xiaotiandada/E-video">仓库地址</a></p>
<p>同时也欢迎 Pr 帮我修复不正确的地方！！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[React案列]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/16</link>
            <guid>https://github.com/xiaotiandada/blog/issues/16</guid>
            <pubDate>Tue, 19 Jan 2021 05:02:25 GMT</pubDate>
            <description><![CDATA[<p>2018-11-23 17:47:51</p>
<h1>React案列</h1>
<p>React 做的小案列</p>
<blockquote>
<p>记录学习笔记什么的~</p>
</blockquote>
<p><a href="https://github.com/xiaotiandada/react-case">仓库地址</a></p>
<p><a href="https://xiaotiandada.github.io/">博客地址</a></p>
<p><a href="https://reactjs.org/">学习资料-reactjs</a></p>
<p><a href="https://www.imooc.com/">学习资料-imooc</a></p>
<!-- more -->
<h2>React案列一</h2>
<h3>简易版-todoList</h3>
<pre><code class="language-js">import React, { Component } from &quot;react&quot;;
// import logo from &quot;./logo.svg&quot;;
import &quot;./App.css&quot;;

class App extends Component {

  // 状态
  constructor(props){
    super(props)
    this.state = {
      list: [],  // 列表数据
      inputValue: ''  // 输入框数据
    }
  }
  
  // 添加列表数据
  addList(){
    // es6 语法
    this.setState({
      list: [...this.state.list, this.state.inputValue],
      inputValue: ''
    })
  }

  // 改变inputValue
  changeInput(e) {
    // 目标值
    let value = e.target.value
    this.setState({
      inputValue: value,
    })
  }

  // 删除列表数据
  delList(index) {
    // 拷贝值 删除
    let list = [...this.state.list]
    list.splice(index, 1)
    this.setState({
      list
    })
  }

  render() {
    return (
      &lt;div&gt;
      &lt;div&gt;
        // 数据绑定  改变事件绑定this
        &lt;input value={this.state.inputValue} onChange={this.changeInput.bind(this)} type=&quot;text&quot;/&gt;
        // 添加事件 绑定this
        &lt;button onClick={this.addList.bind(this)}&gt;添加&lt;/button&gt;
      &lt;/div&gt;
        &lt;ul&gt;
        {
          this.state.list.map((item,index) =&gt; {
            return (
              // 删除事件 绑定this 传index
              &lt;li key={index} onClick={this.delList.bind(this, index)}&gt;{item}&lt;/li&gt;
            )
          })
        }
        &lt;/ul&gt;
      &lt;/div&gt;
    );
  }
}

export default App;

</code></pre>
<ol>
<li>事件，需要state里面的值需要绑定this</li>
</ol>
<pre><code class="language-js">onClick={this.delList.bind(this, index)}
</code></pre>
<ol start="2">
<li>改变state 需要用 this.setState</li>
</ol>
<pre><code class="language-js">this.setState({})
</code></pre>
<ol start="3">
<li>input 双向绑定数据 不用改变事件 输入框内容不会改变 并且警告报错</li>
</ol>
<pre><code class="language-js">// 改变inputValue
changeInput(e) {
  // 目标值
  let value = e.target.value
  this.setState({
    inputValue: value,
  })
}

&lt;input value={this.state.inputValue} onChange={this.changeInput.bind(this)} type=&quot;text&quot;/&gt;

</code></pre>
<blockquote>
<p>刚刚搜了一下</p>
</blockquote>
<p><a href="https://blog.csdn.net/qq_39081974/article/details/81007576"> 参考文章 react中实现数据双向绑定</a></p>
<hr>
<h2>todoList 组件与通信</h2>
<pre><code class="language-js">// 父组件
import React, { Component, Fragment } from &quot;react&quot;;
import Item from './Item'
class App extends Component {
  constructor(props){
    // ...

    // 绑定this 代码优化
    this.addList = this.addList.bind(this)
    this.changeInput = this.changeInput.bind(this)
    this.delList = this.delList.bind(this)
  }
  
  // ...
  getHead() {
    return (
      &lt;div&gt;
        &lt;input value={this.state.inputValue} onChange={this.changeInput} type=&quot;text&quot;/&gt;
        &lt;button onClick={this.addList}&gt;添加&lt;/button&gt;
      &lt;/div&gt;
    ) 
  }

  getItem() {
    return (
      this.state.list.map((item,index) =&gt; {
        return (
          &lt;Item 
            delList={this.delList}    // 子组件调用父组件方法
            key={index}               // 父组件通过属性传递值
            content={item}            // 同
            index={index}             // 同
          /&gt;
        )
      })
    )
  }

  render() {
    return (
      &lt;Fragment&gt;                   // 忽略外层包裹的 div 页面不显示
        {this.getHead()}           // 函数返回 head
        &lt;ul&gt;{this.getItem()}&lt;/ul&gt;  // 函数返回 Item
      &lt;/Fragment&gt;
    );
  }
}

export default App;


// 子组件
import React, { Component } from &quot;react&quot;;  // ...

class Item extends Component {

  constructor(props){
    super(props)
    this.delItem = this.delItem.bind(this)  // 同上
  }

  delItem(){
    const {delList, index} = this.props  // 解构赋值
    delList(index)                       // 调用父级方法
  }

  render() {
    const { content } = this.props;     // 解构赋值
    return (
      &lt;li onClick={this.delItem}&gt;{content}&lt;/li&gt;  // 调用删除方法
    )
  }
}

export default Item

</code></pre>
<hr>
<h3>css 样式</h3>
<p>1.内样样式需要</p>
<pre><code class="language-js">style={{'background': 'red','color': '#fff'}}
</code></pre>
<ol start="2">
<li>定义类名不能用 class</li>
</ol>
<blockquote>
<p>因为 class 已经用来 定义React组件</p>
</blockquote>
<pre><code class="language-js">className='head-button'
</code></pre>
<p>Qq：952822399</p>
<p>Qq群 iD 718639024</p>
<p>大家也可以进来互相交流~</p>
<p>最后就是厚脸皮的一步(觉得不错可以点个star哦~~~) <a href="https://github.com/xiaotiandada/E-video">仓库地址</a></p>
<p>同时也欢迎Pr！！！</p>
<p>同时也欢迎Pr！！！</p>
<p>同时也欢迎Pr！！！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Electron]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/15</link>
            <guid>https://github.com/xiaotiandada/blog/issues/15</guid>
            <pubDate>Mon, 17 Jan 2022 17:25:14 GMT</pubDate>
            <description><![CDATA[<ul>
<li><a href="https://github.com/xiaotiandada/look-wallpapers">look-wallpapers</a></li>
<li><a href="https://github.com/xiaotiandada/E-video">E-video</a></li>
</ul>
<h3>本地存储</h3>
<pre><code class="language-javascript">import storage from 'electron-json-storage';

/**
 * storage Get
 * @returns {Promise&lt;unknown&gt;}
 */
export const storageGet = key =&gt; new Promise((resolve, reject) =&gt; {
  storage.get(key, (error, data) =&gt; {
    if (error) {
      reject(error);
    }

    console.log(data);
    resolve(data);
  });
});

/**
 * storage Set
 * @param data
 * @returns {Promise&lt;unknown&gt;}
 */
export const storageSet = (key, data) =&gt; new Promise((resolve, reject) =&gt; {
  storage.set(key, data, (error) =&gt; {
    if (error) {
      reject(error);
    }
    resolve('success');
  });
});
</code></pre>
<h3>下载图片</h3>
<pre><code class="language-javascript">/**
 * download image
 */
export const downloadImage = async ({
  name,
  url,
}) =&gt; {
  // path
  const imagePath = await 'path';
  const outputLocationPath = path.join(
    imagePath,
    name,
  );

  console.log('outputLocationPath', outputLocationPath);

  // download
  const response = await axios.get(url, {
    responseType: 'arraybuffer',
  });

  const base64Image = new Buffer.from(
    response.data,
    'binary',
  ).toString('base64');
  await util.promisify(fs.writeFile)(outputLocationPath, base64Image, 'base64');

  return outputLocationPath;
};
</code></pre>
<h3>设置壁纸</h3>
<pre><code class="language-javascript">import wallpaper from 'wallpaper';

/**
 * set wallpaper
 */
export const setWallpaper = async ({
  name,
  url,
}) =&gt; {
  const imagePath = await downloadImage({ name, url });
  await wallpaper.set(imagePath, { scale: 'auto' });
  console.log('set wallpaper success');
  new remote.Notification({
    title: 'Notification',
    body: 'Set Wallpaper Success',
  }).show();
};
</code></pre>
<h3>自定义状态栏</h3>
<p>因为win自带的状态栏太丑了，所以自己模拟了一个，electron-vue 通过 ipcMain 发送消息</p>
<p><a href="https://electronjs.org/docs/api/ipc-main#ipcmain">ipcMain</a> - 从主进程到渲染进程的异步通信。</p>
<blockquote>
<p>ipcMain模块是EventEmitter类的一个实例。 当在主进程中使用时，它处理从渲染器进程（网页）发送出来的异步和同步信息。 从渲染器进程发送的消息将被发送到该模块。</p>
</blockquote>
<p><a href="https://blog.csdn.net/liyangyang08/article/details/78608822?locationNum=7&amp;fps=1">参考文章</a></p>
<ol>
<li>在 index.js 修改窗口大小.</li>
</ol>
<p><a href="https://electronjs.org/docs/api/browser-window#winsetcontentsizewidth-height-animate">BrowserWindow</a> - 创建和控制浏览器窗口。</p>
<blockquote>
<p>里面的参数自己可以看文档哦~</p>
</blockquote>
<pre><code class="language-js"> mainWindow = new BrowserWindow({
    height: 710,
    width: 1200,
    useContentSize: true,
    frame: false
  })

</code></pre>
<p>设置之后，有一个细节需要了解一下.</p>
<p><a href="https://electronjs.org/docs/api/frameless-window">可拖拽区</a> - 默认情况下, 无框窗口是 non-draggable 的..... (总之就是，你需要设置一下)</p>
<p>要使整个窗口可拖拽, 您可以添加 -webkit-app-region: drag 作为 body 的样式:</p>
<pre><code class="language-css">&lt;body style=&quot;-webkit-app-region: drag&quot;&gt;&lt;/body&gt;
</code></pre>
<p>请注意, 如果您已使整个窗口draggable, 则必须将按钮标记为 non-draggable, 否则用户将无法单击它们:</p>
<pre><code class="language-css">button {
  -webkit-app-region: no-drag;
}
</code></pre>
<p>如果你设置自定义标题栏为 draggable, 你也需要标题栏中所有的按钮都设为 non-draggable。</p>
<ol start="2">
<li>模拟事件</li>
</ol>
<p>参考文章里面有介绍到，流程大概就是这样。</p>
<pre><code class="language-js">// 引入
const {ipcRenderer: ipc} = require('electron')

// 自定义事件
winMin () {
    ipc.send('window-min')
},
winEnlargeOrNarrow () {
    ipc.send('win-enlarge-or-narrow')
},
winClose () {
    ipc.send('window-close')
}

/**
 * 模拟 最小 放大 还原 关闭 事件
 * index.js 修改
 */
ipcMain.on('window-min', () =&gt; {
  mainWindow.minimize()
})
ipcMain.on('win-enlarge-or-narrow', () =&gt; {
  if (mainWindow.isMaximized()) {
    mainWindow.unmaximize()
  } else {
    mainWindow.maximize()
  }
})
ipcMain.on('window-close', () =&gt; {
  mainWindow.close()
})
</code></pre>
<h3>弹幕</h3>
<p>播放器提供了相应的接口，只需要获取评论转换相应的数据就可以了。</p>
<pre><code class="language-js">transformComments (commentsArr) {}

dp.danmaku.draw({
   text: 'DIYgod is amazing',
   color: '#fff',
   type: 'top'
});
</code></pre>
<p><a href="https://github.com/xiaotiandada/E-video/blob/master/src/renderer/view/index.vue">https://github.com/xiaotiandada/E-video/blob/master/src/renderer/view/index.vue</a></p>
<pre><code class="language-js">import axios from 'axios'

export default () =&gt; {
  return axios.create({
    baseURL: 'xxx',
    timeout: 1000
  })
}

-----------------

import Api from './Api'

export default {
  /**
   * 默认30条数据，可以自定义
   * @param limit
   * @returns {*}
   */
  getTopMv (limit = 30, offset = 0) {
    return Api().get(`/top/mv?limit=${limit}&amp;offset=${offset}`)
  },
  getMvId (id) {
    return Api().get(`/mv?mvid=${id}`)
  },
  getMvComments (id) {
    return Api().get(`/comment/mv?id=${id}`)
  }
}

</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[mpvue外卖小程序]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/14</link>
            <guid>https://github.com/xiaotiandada/blog/issues/14</guid>
            <pubDate>Tue, 10 May 2022 08:34:25 GMT</pubDate>
            <description><![CDATA[<p>2018-09-09 00:37:52</p>
<h1>前言</h1>
<p>首先说说为什么自己会想着写一个小程序emmmmmm 感觉没有为什么 就是想写了 我就干了~~~hhhhh</p>
<p>我就粗略看了一下小程序的官方文档和mpvue的文档 然后就开撸了。</p>
<p><a href="https://github.com/xiaotiandada/takeaway">项目仓库</a> 欢迎start和pr哦~~</p>
<p>为了节省大家的宝贵时间，不废话 直接进入正题；</p>
<hr>
<!-- more -->
<h1>技术栈</h1>
<h2>mpvue</h2>
<p><a href="http://mpvue.com/">mpvue</a> 是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js......(可以看官网介绍~).</p>
<h2>iview weapp</h2>
<p><a href="https://weapp.iviewui.com/">iview weapp </a> 一套高质量的
微信小程序 UI 组件库.</p>
<h1>界面展示</h1>
<p><img src="https://github.com/xiaotiandada/takeaway/raw/master/doc/mpvue1.png" alt="mpvue">
<img src="https://github.com/xiaotiandada/takeaway/raw/master/doc/mpvue2.png" alt="mpvue">
<img src="https://github.com/xiaotiandada/takeaway/raw/master/doc/mpvue3.png" alt="mpvue">
<img src="https://github.com/xiaotiandada/takeaway/raw/master/doc/mpvue4.png" alt="mpvue">
<img src="https://github.com/xiaotiandada/takeaway/raw/master/doc/mpvue5.png" alt="mpvue"></p>
<p>大概的界面就是这样(界面是模仿得饿了么 我也只会模仿点页面了hhhhh)</p>
<h1>完成进度</h1>
<ul>
<li>[x] 小程序的基本界面展示</li>
<li>[x] 简单的购买流程</li>
<li>[x] 使用全局状态保存部分数据</li>
<li>[x] 使用Fly请求数据</li>
<li>[x] 使用Easy-mock模拟数据</li>
<li>[x] ......</li>
<li>[ ] 没有数据库保存真实数据</li>
<li>[ ] 没有根据多个数据渲染店和商品</li>
<li>[ ] 没有做添加地址的数据校验等</li>
<li>[ ] 订单页面还需要优化 折叠显示等</li>
<li>[ ] 商家端还未开发</li>
<li>[ ] ......</li>
</ul>
<p>其实还有很多功能没写，因为这是刚开始上班没事做的时候撸的(所以兴趣才是最好的老师)，然后现在事情比较忙就可能先放下了 如果有大佬或者有时间的大佬可以帮忙完善或者pr emmm  你直接拿走再写也是可以的~</p>
<h1>技术实现</h1>
<p>技术实现过程和一些踩过的坑</p>
<h2>界面</h2>
<p>界面主要使用 iview weapp 组件库 然后 有一些组件库没有的自己原生写法来撸，这里还好没啥坑 但是在布局上面似乎有一个1px的问题 我好像没处理 不知道哪位大佬能发现 并且教我怎么解决~~ 单位主要使用小程序的rpx(很好用) 只需要根据iPhone6的尺寸来使用就可以了，详情可以看<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html">官方文档</a>.</p>
<p>iview weapp input 似乎不能使用双向数据绑定，需要自己重新撸.</p>
<p>底部的tabBar我是用的json来配置的 省得自己写 方便</p>
<pre><code class="language-json">tabBar: {
      color: '#6f6f6f',
      selectedColor: '#18a3ff',
      backgroundColor: '#ffffff',
      borderStyle: 'black',
      list: [
        {
          pagePath: 'pages/index/main',
          iconPath: 'static/img/wm.png',
          selectedIconPath: 'static/img/wms.png',
          text: '外卖'
        },
        {
          pagePath: 'pages/order/main',
          iconPath: 'static/img/dd.png',
          selectedIconPath: 'static/img/dds.png',
          text: '订单'
        },
        {
          pagePath: 'pages/shopp/main',
          iconPath: 'static/img/tj1.png',
          selectedIconPath: 'static/img/tj1s.png',
          text: '推荐'
        },
        {
          pagePath: 'pages/user/main',
          iconPath: 'static/img/user.png',
          selectedIconPath: 'static/img/users.png',
          text: '我的'
        }
      ]
    }
</code></pre>
<p>这块的话可能需要大家查看小程序的文档来配置，其实也简单 跟玩一样就配置的非常好看</p>
<p>可能最麻烦的也是很简单的一个坑 如何引入 其实iview weapp 官方文档写的很清楚了 但是只是大家不知道这么配置而已 我来扣个代码演示一下.</p>
<p>到 GitHub 下载 iView Weapp 的代码，将 dist 目录拷贝到自己的项目中。然后按照如下的方式使用组件，以 Button 为例，其它组件在对应的文档页查看：</p>
<pre><code class="language-json">1. 添加需要的组件 在页面的 json 中配置（路径根据自己项目位置配置）
// 添加 config json
export default {
  config: {
    // 这儿添加要用的小程序组件
    usingComponents: {
      'i-button': '../../dist/button/index'
    }
  }
}

</code></pre>
<pre><code class="language-html">2. 在 wxml 中使用组件
&lt;i-button type=&quot;primary&quot; bind:click=&quot;handleClick&quot;&gt;这是一个按钮&lt;/i-button&gt;
</code></pre>
<p>是不是很简单！！！ 没看明白的也可以看我的<a href="https://github.com/xiaotiandada/takeaway">github</a>仓库哦~</p>
<p>界面这块大概就是这么多 也可能我写掉了 后续想起来我会更一下的hhhh(懒)</p>
<h2>mpvue</h2>
<p>mpvue 新建页面需要重新 npm run dev 这个官方文档已经明确说明过了，由于一个页面只用重启一次 问题不大。</p>
<p>小程序的请求似乎不能用axios 所以使用了Fly 来代替，至于为什么 可以看github里面的<a href="https://github.com/Meituan-Dianping/mpvue/issues/109">issues</a></p>
<p>mpvue 支持小程序和vuejs的事件 详情可以<a href="http://mpvue.com/mpvue/#_13">查看文档</a></p>
<p>然后可能最坑的就是页面转跳了吧... 其实官方文档有写 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/ui-navigate.html#wxnavigatetoobject">目前页面路径最多只能十层。</a> 比如说我再添加地址的时候 使用了wx.navigateTo(OBJECT) 然后返回到地址的列表页面然后继续重复添加地址 到达一定的数量之后 就不会再跳转，而且返回的也是之前重复的页面 用户体验很不好 所以需要一个解决的办法。文字太多可能看不懂 我来画个图。</p>
<p><img src="mpvue%E5%A4%96%E5%8D%96%E5%B0%8F%E7%A8%8B%E5%BA%8F/mpvue6.png" alt="mpvue"></p>
<p>关于登录一块的话 我没有做什么处理 直接用新的用户信息接口就可以了</p>
<p><a href="https://developers.weixin.qq.com/blogdetail?action=get_post_info&amp;lang=zh_CN&amp;token=1894828834&amp;docid=0000a26e1aca6012e896a517556c01&amp;idescene=6&amp;devtools=1&amp;idescene=6">小程序与小游戏获取用户信息接口调整</a></p>
<pre><code class="language-html">&lt;open-data type=&quot;groupName&quot; open-gid=&quot;xxxxxx&quot;&gt;&lt;/open-data&gt;
&lt;open-data type=&quot;userAvatarUrl&quot;&gt;&lt;/open-data&gt;
&lt;open-data type=&quot;userGender&quot; lang=&quot;zh_CN&quot;&gt;&lt;/open-data&gt;
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[把AE动画转换成Web原生动画]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/13</link>
            <guid>https://github.com/xiaotiandada/blog/issues/13</guid>
            <pubDate>Tue, 19 Jan 2021 05:00:37 GMT</pubDate>
            <description><![CDATA[<p>2018-06-26 12:00:07</p>
<h1>把AE动画转换成Web原生动画</h1>
<blockquote>
<p>先贴效果图</p>
</blockquote>
<blockquote>
<p><a href="https://xiaotiandada.github.io/ife/%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%AD%A6%E9%99%A2/No.8/">预览地址 pc 端食用更佳</a></p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/5aff09ee6fb9a07a9b36365b">模仿san官网效果文章地址</a></p>
</blockquote>
<blockquote>
<p><a href="https://xiaotiandada.github.io/">博客地址</a></p>
</blockquote>
<!-- more -->
<p><img src="%E6%8A%8AAE%E5%8A%A8%E7%94%BB%E8%BD%AC%E6%8D%A2%E6%88%90Web%E5%8E%9F%E7%94%9F%E5%8A%A8%E7%94%BB/1.png" alt="img"></p>
<p><img src="%E6%8A%8AAE%E5%8A%A8%E7%94%BB%E8%BD%AC%E6%8D%A2%E6%88%90Web%E5%8E%9F%E7%94%9F%E5%8A%A8%E7%94%BB/2.png" alt="img"></p>
<blockquote>
<p>右边这个动画会一直动 在firefox可以直接打开 其他浏览器需要服务环境</p>
</blockquote>
<blockquote>
<p>正经分割线</p>
</blockquote>
<hr>
<ul>
<li><a href="http://ife.baidu.com/course/detail/id/35?t=1529985511134#learn">ife</a></li>
<li><a href="http://vis.baidu.com/">官网效果</a></li>
<li><a href="https://github.com/xiaotiandada/ife">仓库地址</a></li>
<li><a href="https://xiaotiandada.github.io/">lottie库</a>
<a href="https://github.com/airbnb/lottie-web">https://github.com/airbnb/lottie-web</a></li>
<li><a href="https://xiaotiandada.github.io/">博客地址</a></li>
</ul>
<p>大家其实看第一个就知道怎么弄了 这个我之前写过一个vue-lottie 的时候说过类似的实现方法</p>
<p><a href="https://juejin.im/post/5b180a706fb9a01e780a49d4">文章地址</a></p>
<hr>
<h2>页面布局</h2>
<pre><code class="language-html">&lt;div class=&quot;home-banner&quot;&gt;
    &lt;div class=&quot;home-banner-left&quot;&gt;
        &lt;h1&gt;
            &lt;b&gt;ECharts&lt;/b&gt;数据可视化实验室&lt;/h1&gt;
        &lt;p&gt;由百度 ECharts 团队创建，联合公司内外众多数据可视化从业人组成的技术研究虚拟组织，致力于数据可视化的相关研究、教育普及、产品研发及生态建设。&lt;/p&gt;
    &lt;/div&gt;
    &lt;div class=&quot;home-banner-right&quot;&gt;
        &lt;div id=&quot;bm&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h3>页面样式</h3>
<pre><code class="language-css">*,
*::after,
*::before {
    box-sizing: border-box;
}

body {
    padding: 0;
    margin: 0;

    background-color: #102131;

    min-height: 100%;
}

.home-banner {
    max-width: 1130px;
    margin: 0 auto;
    position: relative;

    padding-top: 8%;

}


.home-banner-left {
    width: 54%;
    vertical-align: top;
    display: inline-block;
    position: relative;

}

.home-banner-left h1 {
    font-size: 48px;
    line-height: 62px;
    color: #fff;
    font-weight: 800;
    margin: 0;
    margin-bottom: 30px;
}

.home-banner-left h1 b {
    font-size: 53px;
    margin-right: 5px;
}

.home-banner-left p {
    color: rgba(255, 255, 255, .7);
    font-size: 15px;
    padding-right: 47px;
    padding-left: 5px;
    font-weight: 200;
    line-height: 30px;
    letter-spacing: 2px;
}

.home-banner-right {
    width: 62%;
    margin-left: -8%;
    margin-right: -300px;
    vertical-align: top;
    display: inline-block;
    position: relative;
}

#bm {
    max-width: 700px;
    display: block;
}
@media screen and (max-width: 768px) {
    .home-banner {
        padding-top: 2%;
    }

    .home-banner-left {
        text-align: center;
        display: block;
        width: 100%;
        box-sizing: border-box;
        padding: 0 20px;
    }

        .home-banner-right {
        display: block;
        width: 100%;
        margin: 0;
    }
}

</code></pre>
<h2>功能实现</h2>
<pre><code class="language-js">&lt;script src=&quot;./lottie.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var animation = lottie.loadAnimation({
        container: document.getElementById('bm'), // the dom element that will contain the animation
        renderer: 'svg',
        loop: true,
        autoplay: true,
        path: 'test.json' // the path to the animation json
    });
&lt;/script&gt;
</code></pre>
<p>其实这里复制粘贴就好了2333</p>
<p><a href="https://xiaotiandada.github.io/ife/%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%AD%A6%E9%99%A2/No.8/">预览地址 pc 端食用更佳</a></p>
<p>ife No.8下面还有一个模仿san官网效果的 结果发现之前已经模仿了2333机缘啊哈哈哈</p>
<p>[模仿san官网效果文章地址](</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[ animation实现登录框]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/12</link>
            <guid>https://github.com/xiaotiandada/blog/issues/12</guid>
            <pubDate>Tue, 19 Jan 2021 05:00:12 GMT</pubDate>
            <description><![CDATA[<p>2018-06-25 22:37:45</p>
<h1>使用 animate.css 实现一个优雅的登录框</h1>
<blockquote>
<p><a href="http://ife.baidu.com/course/detail/id/34">资料地址</a></p>
</blockquote>
<blockquote>
<p><a href="https://xiaotiandada.github.io/ife/%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%AD%A6%E9%99%A2/No.7/">预览地址</a></p>
</blockquote>
<blockquote>
<p>下面的动画效果 css 样式是从 animate.css里面扣出来的2333</p>
</blockquote>
<!-- more -->
<p><img src="animation%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%A1%86/img.png" alt="img"></p>
<pre><code class="language-html">&lt;section class=&quot;site-container&quot;&gt;
    &lt;section class=&quot;card&quot;&gt;
        &lt;h3&gt;Login&lt;/h3&gt;
        &lt;form action=&quot;&quot;&gt;
            &lt;div class=&quot;form__wrapper&quot;&gt;
                &lt;input type=&quot;email&quot; class=&quot;form__input&quot; id=&quot;email&quot; name=&quot;email&quot;&gt;
                &lt;label id=&quot;form__label__email&quot; class=&quot;form__label&quot; for=&quot;email&quot;&gt;
                    &lt;span class=&quot;form__label__content&quot;&gt;Email&lt;/span&gt;
                &lt;/label&gt;
            &lt;/div&gt;

            &lt;div class=&quot;form__wrapper&quot;&gt;
                &lt;input type=&quot;password&quot; class=&quot;form__input&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;
                &lt;label id=&quot;form__label__password&quot; class=&quot;form__label&quot; for=&quot;password&quot;&gt;
                    &lt;span class=&quot;form__label__content&quot;&gt;Password&lt;/span&gt;
                &lt;/label&gt;
            &lt;/div&gt;

            &lt;div class=&quot;form__wrapper__submit&quot;&gt;
                &lt;div class=&quot;form__wrapper_submit__content&quot;&gt;
                    &lt;button id=&quot;btn&quot; type=&quot;submit&quot; name=&quot;submit&quot; class=&quot;btn&quot;&gt;Submit&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/form&gt;
    &lt;/section&gt;
&lt;/section&gt;
</code></pre>
<pre><code class="language-css"> /* label 文字上移效果 */
.active {
    -webkit-transform: scale(.9) translate(-14px, -14px);
    -moz-transform: scale(.9) translate(-14px, -14px);
    -ms-transform: scale(.9) translate(-14px, -14px);
    -o-transform: scale(.9) translate(-14px, -14px);
    transform: scale(.9) translate(-14px, -14px);
}

/* btn copy animation.css 效果 */
@keyframes bounceIn {
    from,
    25%,
    50%,
    75%,
    to {
        -webkit-animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
        animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
    }

    0% {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }

    25% {
        -webkit-transform: scale3d(1.01, 1.01, 1.01);
        transform: scale3d(1.01, 1.01, 1.01);
    }

    50% {
        -webkit-transform: scale3d(1.02, 1.02, 1.02);
        transform: scale3d(1.02, 1.02, 1.02);
    }

    75% {
        -webkit-transform: scale3d(1.01, 1.01, 1.01);
        transform: scale3d(1.01, 1.01, 1.01);
    }

    to {
        -webkit-transform: scale3d(1, 1, 1);
        transform: scale3d(1, 1, 1);
    }
}

.bounceIn {
    -webkit-animation-duration: 0.75s;
    animation-duration: 0.75s;
    -webkit-animation-name: bounceIn;
    animation-name: bounceIn;
    animation-iteration-count: infinite;
}
</code></pre>
<blockquote>
<p>详情查看[github地址](</p>
</blockquote>
]]></description>
        </item>
        <item>
            <title><![CDATA[利用animation制作slider]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/11</link>
            <guid>https://github.com/xiaotiandada/blog/issues/11</guid>
            <pubDate>Tue, 19 Jan 2021 04:59:00 GMT</pubDate>
            <description><![CDATA[<p>2018-06-25 19:02:53</p>
<h1>利用css animation制作slider</h1>
<blockquote>
<p><a href="http://ife.baidu.com/course/detail/id/33?t=1529924615098#learn">文章地址</a></p>
</blockquote>
<blockquote>
<p><a href="https://xiaotiandada.github.io/ife/%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%AD%A6%E9%99%A2/No.6/">预览地址</a></p>
</blockquote>
<!-- more -->
<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;img&quot;&gt;
        &lt;img src=&quot;./img/1.jpg&quot; alt=&quot;&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;img&quot;&gt;
        &lt;img src=&quot;./img/2.jpg&quot; alt=&quot;&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;img&quot;&gt;
        &lt;img src=&quot;./img/3.png&quot; alt=&quot;&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;img&quot;&gt;
        &lt;img src=&quot;./img/4.jpg&quot; alt=&quot;&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;img&quot;&gt;
        &lt;img src=&quot;./img/5.jpg&quot; alt=&quot;&quot;&gt;
    &lt;/div&gt;

    &lt;div class=&quot;bottom&quot;&gt;
        &lt;div class=&quot;img-bottom&quot;&gt;
            &lt;img src=&quot;./img/1.jpg&quot; alt=&quot;&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;img-bottom&quot;&gt;
            &lt;img src=&quot;./img/2.jpg&quot; alt=&quot;&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;img-bottom&quot;&gt;
            &lt;img src=&quot;./img/3.png&quot; alt=&quot;&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;img-bottom&quot;&gt;
            &lt;img src=&quot;./img/4.jpg&quot; alt=&quot;&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;img-bottom&quot;&gt;
            &lt;img src=&quot;./img/5.jpg&quot; alt=&quot;&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">*,
*::after,
*::before {
    box-sizing: border-box;
}
html,
body {
    height: 100%;
}
body {
    padding: 0;
    margin: 0;
}
.container {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
}
div.img {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: hidden;
}
div.img img {
    width: 100%;
    height: 100%;
}
div.img:nth-child(1) {
    left: -100%;
    -webkit-transition: .5s;
    -moz-transition: .5s;
    -ms-transition: .5s;
    -o-transition: .5s;
    transition: .5s;
    -webkit-transition-timing-function: ease-out;
    -moz-transition-timing-function: ease-out;
    -ms-transition-timing-function: ease-out;
    -o-transition-timing-function: ease-out;
    transition-timing-function: ease-out;
}
div.img:nth-child(2) {
    top: 100%;
    -webkit-transition: .5s;
    -moz-transition: .5s;
    -ms-transition: .5s;
    -o-transition: .5s;
    transition: .5s;
    -webkit-transition-timing-function: ease-out;
    -moz-transition-timing-function: ease-out;
    -ms-transition-timing-function: ease-out;
    -o-transition-timing-function: ease-out;
    transition-timing-function: ease-out;
}
div.img:nth-child(3) {
    transform: scale(0.1);
    -webkit-transition: 1s;
    -moz-transition: 1s;
    -ms-transition: 1s;
    -o-transition: 1s;
    transition: 1s;
    -webkit-transition-timing-function: ease-in;
    -moz-transition-timing-function: ease-in;
    -ms-transition-timing-function: ease-in;
    -o-transition-timing-function: ease-in;
    transition-timing-function: ease-in;
}
div.img:nth-child(4) {
    transform: scale(2.0);
    -webkit-transition: 1s;
    -moz-transition: 1s;
    -ms-transition: 1s;
    -o-transition: 1s;
    transition: 1s;
    -webkit-transition-timing-function: ease-out;
    -moz-transition-timing-function: ease-out;
    -ms-transition-timing-function: ease-out;
    -o-transition-timing-function: ease-out;
    transition-timing-function: ease-out;
    z-index: 1;
}
div.img:nth-child(5) {
    transform: rotate(-360deg) scale(0.1);
    -webkit-transition: .7s;
    -moz-transition: .7s;
    -ms-transition: .7s;
    -o-transition: .7s;
    transition: .7s;
    -webkit-transition-timing-function: ease-in-out;
    -moz-transition-timing-function: ease-in-out;
    -ms-transition-timing-function: ease-in-out;
    -o-transition-timing-function: ease-in-out;
    transition-timing-function: ease-in-out;
}
div.bottom {
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 850px;
    z-index: 10;
}
div.bottom div.img-bottom {
    float: left;
    margin: 0 10px;
}
div.bottom div.img-bottom img {
    width: 150px;
    height: 100px;
}
div.active {
    left: 0 !important;
}
div.active {
    top: 0 !important;
}
div.active {
    transform: scale(1.0) !important;
}
div.active {
    transform: scale(1.0) !important;
}
div.active {
    transform: rotate(0deg) scale(1.0) !important;
}
</code></pre>
<pre><code class="language-js">window.onload = function () {
    var imgBottom = document.getElementsByClassName('img-bottom')
    var imgToggle = document.getElementsByClassName('img')

    var attrArr = [
        'leftImg', 'topImg', 'scaleImg', 'scaleImgs', 'scaleRotateImg'
    ]

    var getCls = function (element) {
        return element.getAttribute('class')
    }
    var setCls = function (element, cls) {
        return element.setAttribute('class', cls)
    }
    var addCls = function (element, cls) {
        var baseCls = getCls(element)
        if (baseCls.indexOf(cls) == -1) {
            setCls(element, baseCls + ' ' + cls)
        }
    }

    var delCls = function(element, cls) {
        var baseCls = getCls(element)
        if(baseCls.indexOf(cls) != -1){
            setCls(element, baseCls.split(cls).join(' ').replace(/\s+/g, ' '))
        }
    }

    var toggleImg = function (i) {
        return function () {
            ImgAddIndex(i)
        }
    }
    for (var i = 0; i &lt; imgBottom.length; i++) {
        imgBottom[i].onclick = toggleImg(i)
    }

    function ImgAddIndex (i) {
        for(var j = 0;j&lt;imgToggle.length;j++) {
            imgToggle[j].style.zIndex = 0
            delCls(imgToggle[j], 'active')
        }

        addCls(imgToggle[i], 'active')
        imgToggle[i].style.zIndex = 9;
    }
}
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[css旋转立方体]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/10</link>
            <guid>https://github.com/xiaotiandada/blog/issues/10</guid>
            <pubDate>Tue, 19 Jan 2021 04:58:35 GMT</pubDate>
            <description><![CDATA[<p>2018-06-24 23:30:56</p>
<h2>纯 CSS 制作绕中轴旋转的立方体</h2>
<ul>
<li><a href="http://ife.baidu.com/course/detail/id/32">http://ife.baidu.com/course/detail/id/32</a></li>
<li><a href="https://codepen.io/jordizle/pen/haIdo">https://codepen.io/jordizle/pen/haIdo</a></li>
<li>文章已经给了很多资料了</li>
</ul>
<blockquote>
<p><a href="https://xiaotiandada.github.io/ife/%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%AD%A6%E9%99%A2/No.5%20/">预览地址</a></p>
</blockquote>
<!-- more -->
<pre><code class="language-html">&lt;div id=&quot;wrapper&quot;&gt;
    &lt;div class=&quot;viewport&quot;&gt;
        &lt;div class=&quot;cube&quot;&gt;
            &lt;div class=&quot;side&quot;&gt;
                &lt;div class=&quot;cube-image&quot;&gt;1&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;side&quot;&gt;
                &lt;div class=&quot;cube-image&quot;&gt;2&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;side&quot;&gt;
                &lt;div class=&quot;cube-image&quot;&gt;3&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;side&quot;&gt;
                &lt;div class=&quot;cube-image&quot;&gt;4&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;side&quot;&gt;
                &lt;div class=&quot;cube-image&quot;&gt;5&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;side&quot;&gt;
                &lt;div class=&quot;cube-image active&quot;&gt;6&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-css">*,
*::before,
*::after {
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}

body {
    background: #1b1b1b;
    font-family: 'HelveticaNeue-Light', 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, 'Lucida Grande', sans-serif;
    font-weight: 300;
}


#wrapper {
    padding-top: 20%;
}

.viewport {
    -webkit-perspective: 800px;
    -moz-perspective: 800px;
    -ms-perspective: 800px;
    -o-perspective: 800px;
    perspective: 800px;


    -webkit-perspective-origin: 50% 50%;
    -moz-perspective-origin: 50% 50%;
    -ms-perspective-origin: 50% 50%;
    -o-perspective-origin: 50% 50%;
    perspective-origin: 50% 50%;

    -webkit-transform: scale(0.8, 0.8);
    -moz-transform: scale(0.8, 0.8);
    -ms-transform: scale(0.8, 0.8);
    -o-transform: scale(0.8, 0.8);
    transform: scale(0.8, 0.8);

        -webkit-transition: .28s;
    -moz-transition: .28s;
    -ms-transition: .28s;
    -o-transition: .28s;
    transition: .28s;

}

.cube {
    position: relative;
    margin: 0 auto;
    height: 200px;
    width: 200px;

    -webkit-transform-style: preserve-3d;
    -moz-transform-style: preserve-3d;
    -ms-transform-style: preserve-3d;
    -o-transform-style: preserve-3d;
    transform-style: preserve-3d;

    -webkit-transform: rotate(180deg) rotateY(0deg);
    -moz-transform: rotate(180deg) rotateY(0deg);
    -ms-transform: rotate(180deg) rotateY(0deg);
    -o-transform: rotate(180deg) rotateY(0deg);
    transform: rotate(180deg) rotateY(0deg);


    -webkit-transition: 5s;
    -moz-transition: 5s;
    -ms-transition: 5s;
    -o-transition: 5s;
    transition: 5s;
}

.cube&gt;div {
    overflow: hidden;
    position: absolute;
    opacity: .5;
    height: 200px;
    width: 200px;
    background: rgba(0, 191, 255, 0.07);
    border: 2px solid rgb(0, 170, 255);

    -webkit-touch-callout: none;
    -moz-touch-callout: none;
    -ms-touch-callout: none;
    -o-touch-callout: none;
    touch-callout: none;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    -o-user-select: none;
    user-select: none;
}

.cube&gt;div&gt;div.cube-image {
    height: 200px;
    width: 200px;

    -webkit-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    transform: rotate(180deg);

    line-height: 200px;
    font-size: 80px;
    text-align: center;
    color: #1b9bd8;

    -webkit-transition: color 600ms;
    -moz-transition: color 600ms;
    -ms-transition: color 600ms;
    -o-transition: color 600ms;
    transition: color 600ms;
}


.cube&gt;div:hover {
    cursor: pointer;
}

.cube&gt;div:active {
    cursor: pointer;
}

.cube:hover {
    -webkit-transform: rotate(180deg) rotateY(360deg);
    -moz-transform: rotate(180deg) rotateY(360deg);
    -ms-transform: rotate(180deg) rotateY(360deg);
    -o-transform: rotate(180deg) rotateY(360deg);
    transform: rotate(180deg) rotateY(360deg);
}

.cube&gt;div:first-child {
    -webkit-transform: rotateX(90deg) translateZ(100px);
    -moz-transform: rotateX(90deg) translateZ(100px);
    -ms-transform: rotateX(90deg) translateZ(100px);
    -o-transform: rotateX(90deg) translateZ(100px);
    transform: rotateX(90deg) translateZ(100px);
    outline: 1px solid transparent;
}

.cube&gt;div:nth-child(2) {
    -webkit-transform: translateZ(100px);
    -moz-transform: translateZ(100px);
    -ms-transform: translateZ(100px);
    -o-transform: translateZ(100px);
    transform: translateZ(100px);
    outline: 1px solid transparent;
}

.cube&gt;div:nth-child(3) {
    -webkit-transform: rotateY(90deg) translateZ(100px);
    -moz-transform: rotateY(90deg) translateZ(100px);
    -ms-transform: rotateY(90deg) translateZ(100px);
    -o-transform: rotateY(90deg) translateZ(100px);
    transform: rotateY(90deg) translateZ(100px);
    outline: 1px solid transparent;
}

.cube&gt;div:nth-child(4) {
    -webkit-transform: rotateY(180deg) translateZ(100px);
    -moz-transform: rotateY(180deg) translateZ(100px);
    -ms-transform: rotateY(180deg) translateZ(100px);
    -o-transform: rotateY(180deg) translateZ(100px);
    transform: rotateY(180deg) translateZ(100px);
    outline: 1px solid transparent;
}

.cube&gt;div:nth-child(5) {
    -webkit-transform: rotateY(-90deg) translateZ(100px);
    -moz-transform: rotateY(-90deg) translateZ(100px);
    -ms-transform: rotateY(-90deg) translateZ(100px);
    -o-transform: rotateY(-90deg) translateZ(100px);
    transform: rotateY(-90deg) translateZ(100px);
    outline: 1px solid transparent;
}

.cube&gt;div:nth-child(6) {
    -webkit-transform: rotateX(-90deg) rotate(180deg) translateZ(100px);
    -moz-transform: rotateX(-90deg) rotate(180deg) translateZ(100px);
    -ms-transform: rotateX(-90deg) rotate(180deg) translateZ(100px);
    -o-transform: rotateX(-90deg) rotate(180deg) translateZ(100px);
    transform: rotateX(-90deg) rotate(180deg) translateZ(100px);
    outline: 1px solid transparent;
}


@media (max-width: 640px) {
    .viewport {
        -webkit-transform: scale(0.6, 0.6);
        -moz-transform: scale(0.6, 0.6);
        -ms-transform: scale(0.6, 0.6);
        -o-transform: scale(0.6, 0.6);
        transform: scale(0.6, 0.6);
    }
}
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[vue个人小项目总结]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/9</link>
            <guid>https://github.com/xiaotiandada/blog/issues/9</guid>
            <pubDate>Tue, 19 Jan 2021 04:58:16 GMT</pubDate>
            <description><![CDATA[<p>2018-06-22 13:14:50</p>
<h2>简介</h2>
<p>自己写了一个vue小项目总结总结(为了节省篇幅和大家阅读的时间直接进入正题 认真脸！)</p>
<hr>
<blockquote>
<p>项目详情可以查看的我Github仓库<a href="https://github.com/xiaotiandada/My-music">地址</a></p>
</blockquote>
<blockquote>
<p><a href="http://123.207.60.132:8081/">项目预览地址</a></p>
</blockquote>
<ul>
<li>用户登录帐号密码都是11</li>
<li>后台管理登录也是11</li>
<li>(其实还有别的帐号密码,如果您有心情可以查看api自己用Postman注册,用户注册自己可以直接在页面上注册)</li>
</ul>
<blockquote>
<p>github描述文档写了使用了写技术栈 和 界面截图</p>
</blockquote>
<!-- more -->
<h2>功能总结</h2>
<blockquote>
<h3>前端api调用</h3>
</blockquote>
<pre><code class="language-bash"># api
import axios from 'axios'
import store from '@/store/store'

export default () =&gt; {
  return axios.create({
    baseURL: `http://123.207.60.132:8081/`,
    headers: {
      Authorization: `Bearer ${store.state.token}`
    }
  })
}

import Api from '@/services/Api'

export default {
  userLogin(credentials) {
    return Api().post('/userLogin', credentials)
  }
}

# music api

import axios from 'axios'
export default () =&gt; {
  return axios.create({
    baseURL: `http://123.207.60.132:3000/`
  })
}

import Api from '@/services/musicApi'

export default {
  getTopList() {
    return Api().get('/top/list?idx=3')
  }
}
</code></pre>
<ul>
<li>更多内容<a href="https://github.com/xiaotiandada/My-music/tree/master/client/src/services">地址</a></li>
</ul>
<blockquote>
<h3>前端vuex状态管理</h3>
</blockquote>
<pre><code class="language-bash">import Vue from 'vue'
import Vuex from 'vuex'
import createPersistedState from 'vuex-persistedstate'

Vue.use(Vuex)

export default new Vuex.Store({
  strict: true,
  plugins: [createPersistedState()],
  state: {
    token: null,
    user: null,
    isUserLoggedIn: false
  },

  mutations: {
    setToken(state, token) {
      state.token = token
      state.isUserLoggedIn = !!(token)
    },
    setUser(state, user) {
      state.user = user
    }
  },

  actions: {
    setToken({ commit }, token) {
      commit('setToken', token)
    },
    setUser({ commit }, user) {
      commit('setUser', user)
    }
  }
})
</code></pre>
<ul>
<li>更多内容<a href="https://github.com/xiaotiandada/My-music/tree/master/client/src/store">地址</a></li>
</ul>
<blockquote>
<h3>前端界面</h3>
</blockquote>
<pre><code class="language-bash"># 组件使用
&lt;v-slider :sliderImg=&quot;sliderImg&quot;&gt;&lt;/v-slider&gt;

# 组件引入
 import VSlider from './Slider/Index'

export default {
    # 声明组件
    components: {
        VSlider
    },
    data() {
        return {
            sliderImg: [
                {
                src: 'item1'
                },
                {
                src: 'item2'
                },
                {
                src: 'item3'
                },
                {
                src: 'item4'
                }
            ]
        }
    }
}
</code></pre>
<ul>
<li>前端页面基本都是按照这样的方式写的 更多内容<a href="https://github.com/xiaotiandada/My-music/tree/master/client/src/views">地址</a></li>
</ul>
<blockquote>
<h3>后台界面</h3>
</blockquote>
<ul>
<li>
<p>后台界面除了按照前端页面写的以外还用了<a href="https://github.com/PanJiaChen/vue-element-admin">vue-element-admin</a>后台界面的写法</p>
</li>
<li>
<p>其中侧边栏是根据 router.js 配置的路由并且根据权限动态生成的，这样就省去了写一遍路由还要手动再写一次侧边栏这种麻烦事，但也遇到了一个问题，路由可能会有多层嵌套，很多人反馈自己的侧边栏会有三级，甚至还有五级的。所以重构了一下侧边栏，使用了递归组件，这样不管你多少级，都能愉快的显示了。<a href="https://juejin.im/post/593121aa0ce4630057f70d35#heading-3">文章地址</a> 复制的hhhh</p>
</li>
<li>
<p>页面还用了icon<a href="https://juejin.im/post/59bb864b5188257e7a427c09">文章地址</a></p>
</li>
<li>
<p>主页显示用了<a href="https://github.com/ElemeFE/v-charts">v-charts图表组件</a> 这个基本的使用挺简单的看看文档就ok了 不用另外写文章了</p>
</li>
<li>
<p>更多内容<a href="https://github.com/xiaotiandada/My-music/tree/master/client/src/views">地址</a></p>
</li>
</ul>
<blockquote>
<h3>前端router</h3>
</blockquote>
<pre><code class="language-bash">import Vue from 'vue'
import Router from 'vue-router'
Vue.use(Router)

export const constantRouterMap = [
  { path: '*', redirect: '/404', hidden: true }
]

export default new Router({
  mode: 'history', // require service support
  scrollBehavior: () =&gt; ({ y: 0 }),
  routes: constantRouterMap
})
</code></pre>
<ul>
<li>更多内容<a href="https://github.com/xiaotiandada/My-music/tree/master/client/src/router">地址</a></li>
</ul>
<blockquote>
<h3>后端基本服务</h3>
</blockquote>
<pre><code class="language-bash">const express = require('express')
const app = express()
const config = require('./config/config')

const fs = require('fs')
const path = require('path')
require('./router/index.js')(app)
app.use(express.static(path.resolve(__dirname, './dist')))

app.get('*', function(req, res) {
    const html = fs.readFileSync(path.resolve(__dirname, './dist/index.html'), 'utf-8')
    res.send(html)
})

app.listen(config.port, function () {
  console.log(`server run ${config.port} port`)
})
</code></pre>
<ul>
<li>
<p>后台主要使用nodejs express mongodb提供服务</p>
</li>
<li>
<p>功能 用户登录注册</p>
</li>
<li>
<p>功能 管理员登录注册</p>
</li>
<li>
<p>用户的密码加密</p>
</li>
<li>
<p>更多内容<a href="https://github.com/xiaotiandada/My-music/blob/master/service/app.js">地址</a></p>
</li>
</ul>
<blockquote>
<h3>后端model</h3>
</blockquote>
<pre><code class="language-bash">const mongoose = require('mongoose')
const Schema = mongoose.Schema
const bcrypt =require('bcryptjs')  // 密码加密
let SALT_WORK_FACTOR = 10
const config = require('../config/config')
mongoose.connect(config.database)


var UserSchema = new Schema({
  userName: {
    type: String,
    unique: true,  // 不重复
    require: true  // 不为空
  }
})

// 在保存密码之前用bcrypt加密保证密码只有用户知道
UserSchema.pre('save', function (next){
  // 保存this指向
  let _this = this
  // 判断是否为最新
  if(!_this.isModified('password')){
      return next()
  }
  // 加密EMMM 产生一个salt
  bcrypt.genSalt(SALT_WORK_FACTOR, function (err, salt){
    if(err){
      return next(err)
    }

    // 结合salt 生成 hash
    bcrypt.hash(_this.password, salt, function (err, hash) {
      if(err){
        return next(err)
      }

      // 用hash覆盖明文密码
      _this.password = hash
      next()
    })
  })
})

// 通过bcrypt的compare方法，对再次传入的密码和数据库中保存的加密后的密码进行比较，如果匹配，则登录成功 isMatch 为布尔值
// mongoose 模型扩展 在 methods 对象上扩展
UserSchema.methods.comparePassword = function (candidatePassword, cb) {
  bcrypt.compare(candidatePassword, this.password, function (err, isMatch) {
    if (err) {
      return cb(err);
    }

    cb(null, isMatch);
  });
};
module.exports = mongoose.model('User', UserSchema)
</code></pre>
<ul>
<li>
<p>使用mongoose Schema定义数据模型</p>
</li>
<li>
<p>通过bcrypt密码加密</p>
</li>
<li>
<p>扩展方法 对密码加密</p>
</li>
<li>
<p>更多内容<a href="https://github.com/xiaotiandada/My-music/tree/master/service/model">地址</a></p>
</li>
</ul>
<blockquote>
<h3>后端controllers</h3>
</blockquote>
<pre><code class="language-bash">const User = require('../model/User')
const AdminUser = require('../model/AdminUser')
const jwt = require('jsonwebtoken')
const config = require('../config/config')


// token
function jwtSignUser(user) {
  const ONE_WEEK = 60 * 60 * 24 * 7
  return jwt.sign(user, config.authentication.jwtSecret, {
    expiresIn: ONE_WEEK
  })
}

module.exports = {
  async userLogin(req, res) {
    try {
      await User.findOne({
        userName: req.body.userName
      }, function (err, user) {
        .........
      })
    }
  }
}
</code></pre>
<ul>
<li>登录成功返回</li>
</ul>
<pre><code class="language-bash">success: true,
message: '登录成功',
token: 'token值'
</code></pre>
<ul>
<li>登录成功返回</li>
</ul>
<pre><code class="language-bash">success: false,
message: '登录失败', (或其他信息详情看文件)
token: ''
</code></pre>
<ul>
<li>对用户的密码判断</li>
</ul>
<pre><code class="language-bash"> user.comparePassword(req.body.pass, (err, isMatch) =&gt; {
     ...
 }
</code></pre>
<ul>
<li>更多内容<a href="https://github.com/xiaotiandada/My-music/tree/master/service/controllers">地址</a></li>
</ul>
<hr>
<blockquote>
<h3>总结</h3>
</blockquote>
<ul>
<li>
<p>通过上面的练习学习了更多新知识</p>
</li>
<li>
<p>更加理解前后端的交互</p>
</li>
<li>
<p>加强了技术掌握程度</p>
</li>
<li>
<p>还有很多不符合现在开发的规范</p>
</li>
<li>
<p>代码不够精简干练</p>
</li>
<li>
<p>基础知识掌握不牢固</p>
</li>
<li>
<p>设计审美水平需要提升</p>
</li>
<li>
<p>......</p>
</li>
</ul>
<p>大概就是这么多吧, 项目还有很多部规范的地方以后会慢慢改正, 虽然是个人里练习的项目, 自己还是话了很多时间和心血</p>
<p>最后 最后 最后 说一个厚脸皮的话 小哥哥小姐姐如果觉得不错的话可以给小生点一个 <a href="https://github.com/xiaotiandada/My-music">Star</a> 嘛 谢谢哇QAQ~~</p>
<p>自己马上就要实习了 有大佬看上带走的吗！QAQ</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[css布局]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/8</link>
            <guid>https://github.com/xiaotiandada/blog/issues/8</guid>
            <pubDate>Tue, 19 Jan 2021 04:57:44 GMT</pubDate>
            <description><![CDATA[<p>2018-06-20 16:50:52</p>
<blockquote>
<p>更多信息可以查看我的github仓库</p>
</blockquote>
<h3>MDN 定位</h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/%E5%AE%9A%E4%BD%8D">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/定位</a></p>
<h3>MDN 定位实战</h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Practical_positioning_examples">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Practical_positioning_examples</a></p>
<h3>MDN Flexbox</h3>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox</a></p>
<!-- more -->
<h3>布局</h3>
<blockquote>
<p>这个基础需要恶补</p>
</blockquote>
<blockquote>
<p>圣杯布局</p>
</blockquote>
<pre><code class="language-bash"># css
body {
    margin: 0;
    padding: 0;
}

.header,
.footer {
    background: red;
    padding: 20px 0;
}

.container {
    padding-left: 200px;
    padding-right: 200px;
    /* min-width: 600px; */
}

.content,
.left,
.right {
    height: 200px;
    float: left;
    position: relative;
}


.content {
    width: 100%;
    background: gold;
}

.left {
    width: 200px;
    height: 200px;
    background: #333;
    margin-left: -100%;
    right: 200px;
}

.right {
    width: 200px;
    height: 200px;
    background: #eee;
    margin-right: -200px;
}

.footer {
    clear: both;
}

* html .left {
    left: 200px;
}
# html
&lt;div class=&quot;header&quot;&gt;
    header
&lt;/div&gt;

&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;content&quot;&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Obcaecati iusto cumque quibusdam quis qui sit quisquam iure repellat perferendis. Tempora accusantium dignissimos, magnam est placeat enim dicta dolores nam distinctio!&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;footer&quot;&gt;
    footer
&lt;/div&gt;
</code></pre>
<blockquote>
<p>双飞翼布局</p>
</blockquote>
<pre><code class="language-bash">#css 

.left,
.main,
.right {
    float: left;
    min-height: 200px;
}
.left {
    background: gray;
    width: 200px;
    margin-left: -100%;
}
.main {
    background: rgb(252, 102, 102);
    width: 100%;
}
.right {
    background: #333;
    width: 200px;
    margin-left: -200px;
}
.content {
    margin: 0 200px;
    overflow: hidden;
}

#html 
&lt;div class=&quot;container&quot;&gt;

    &lt;div class=&quot;main&quot;&gt;
        &lt;div class=&quot;content&quot;&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Culpa quos labore, ad officiis animi libero ipsam dolorum explicabo placeat facere fuga ex suscipit porro nesciunt quod mollitia corrupti voluptatem a?&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>圣杯布局和双飞翼布局的作用和区别</p>
<blockquote>
<p><a href="http://www.cnblogs.com/woodk/p/5147085.html">http://www.cnblogs.com/woodk/p/5147085.html</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.cnblogs.com/imwtr/p/4441741.html">http://www.cnblogs.com/imwtr/p/4441741.html</a></p>
</blockquote>
<p>flex 布局</p>
<pre><code class="language-bash">#css
.container {
    -webkit-display:flex;
    display: flex;
    min-height: 200px;
}
.left {
    order: -1;
    background: red;
    flex-basis: 200px;
}
.main {
    background: forestgreen;
    flex-grow: 1;
}
.right{
    background: gold;
    flex-basis: 300px;
}
#html
&lt;div class=&quot;container&quot;&gt;

    &lt;div class=&quot;main&quot;&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Eaque quae, veritatis dignissimos laborum debitis id accusantium dolore inventore odit sed! Sunt officiis temporibus esse eum ab fuga ad sequi officia?&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<blockquote>
<p>绝对定位布局</p>
</blockquote>
<pre><code class="language-bash"># css 

.container {
    position: relative;
}

.main,
.right,
.left {
    top: 0;
    height: 130px;
}

.main {
    background: gray;
    margin: 0 300px 0 200px;
}

.right {
    position: absolute;
    width: 300px;
    right: 0;
    background: red;
}

.left {
    width: 200px;
    position: absolute;
    left: 0;
    background: green;
}

#html
&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;main&quot;&gt;man&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;
&lt;/div&gt;

</code></pre>
<blockquote>
<p>实现布局还原</p>
</blockquote>
<pre><code class="language-bash">#css 
body{
    margin: 0;
    padding: 0;
}

* {
    box-sizing: border-box;
}
.fl{
    float: left;
}
.ri {
    float: right;
}

.header{
    width: 100%;
    min-width: 960px;
    height: 100px;
    background: #333;
}

.header-content{
    width: 960px;
    height: 100%;
    margin: 0 auto;
}
.header-content .logo{
    width: 100px;
    height: 100%;
}
.header-content .logo h1 {
    margin: 0;
    padding: 0;
    font-size: 40px;
    color: #fff;
    line-height: 100px;
    text-align: center;
}
.header-content .about a{
    display: inline-block;
    padding: 0 4px;
    color: #fff;
    font-size: 16px;
    line-height: 100px;
}


.banner{
    width: 100%;
    height: 400px;
    background: rgb(77, 206, 77);
    position: relative;
}

.list{
    position: absolute;
    bottom: 10px;
    right: 10%;
    -webkit-display: flex;
    display: flex;
}

.list span {
    display: block;
    width: 30px;
    height: 40px;
    line-height: 40px;
    background: rgba(238, 238, 238, 0.7);
    border: 1px solid #333;
    float: left;
    text-align: center;
    align-self: flex-end;
    margin: 0 2px;

}
/* .list span:hover{
    height: 50px;
    line-height: 60px;    
} */
.list span.active{
    height: 50px;
    line-height: 60px;    
}

.nav{
    width: 100%;
    height: 80px;
    background: #fff;
    border-bottom: 1px solid #eee;
}

.nav-content {
    width: 960px;
    height: 100%;
    margin: 0 auto;
}

.nav-content a{
    display: block;
    float: left;
    width: 140px;
    height: 50px;
    line-height: 50PX;
    text-align: center;
    text-decoration: none;
    color: #000;
    border-left: 1px solid #c5c5c5;
    border-top: 1px solid #c5c5c5;
    border-right: 1px solid #c5c5c5;
    border-bottom: 1px solid #c5c5c5;
    background: #eee;
    border-radius: 20px 20px 0 0;
    margin-top: 30px;
}
.nav-content a.active{
    background: #fff;
    border-bottom: 1px solid #fff;
}


.main{
    width: 960px;
    overflow: hidden;
    margin: 10px auto 0;
}

.main .row{
    -webkit-display: flex;
    display: flex;
}

.main .row .row-content {
    flex: 1;
    height: 200px;
    text-align: center;
    border: 1px solid #bfbfbf;
    /* padding: 80px; */
    margin: 4px;
    align-items: center;
    justify-content: center;
    -webkit-display: flex;
    display: flex;
}


.footer{
    width: 100%;
    height: 100px;
    background: #404040;
    text-align: center;
    line-height: 100px;
    font-size: 16px;
    color: #fff;
}

# html

&lt;div class=&quot;header&quot;&gt;
    &lt;div class=&quot;header-content&quot;&gt;
        &lt;div class=&quot;logo fl&quot;&gt;
            &lt;h1&gt;logo&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div class=&quot;about ri&quot;&gt;
            &lt;a href=&quot;#&quot;&gt;Github&lt;/a&gt;
            &lt;a href=&quot;#&quot;&gt;Register&lt;/a&gt;
            &lt;a href=&quot;#&quot;&gt;Login&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;banner&quot;&gt;
    &lt;div class=&quot;list&quot;&gt;
        &lt;span&gt;1&lt;/span&gt;
        &lt;span class=&quot;active&quot;&gt;2&lt;/span&gt;
        &lt;span&gt;3&lt;/span&gt;
        &lt;span&gt;4&lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;nav&quot;&gt;
    &lt;div class=&quot;nav-content&quot;&gt;
        &lt;a href=&quot;#&quot; class=&quot;active&quot;&gt;HOME&lt;/a&gt;
        &lt;a href=&quot;#&quot;&gt;PROFLE&lt;/a&gt;
        &lt;a href=&quot;#&quot;&gt;ABOUT&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;main&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;row-content&quot;&gt;content&lt;/div&gt;
        &lt;div class=&quot;row-content&quot;&gt;content&lt;/div&gt;
        &lt;div class=&quot;row-content&quot;&gt;content&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;row-content&quot;&gt;content&lt;/div&gt;
        &lt;div class=&quot;row-content&quot;&gt;content&lt;/div&gt;
        &lt;div class=&quot;row-content&quot;&gt;content&lt;/div&gt;
        &lt;div class=&quot;row-content&quot;&gt;content&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;row-content&quot;&gt;content&lt;/div&gt;
        &lt;div class=&quot;row-content&quot;&gt;content&lt;/div&gt;
        &lt;div class=&quot;row-content&quot;&gt;content&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;footer&quot;&gt;
    &lt;p&gt;&amp;copy; 2018 ife.baidu.com&lt;/p&gt;
&lt;/div&gt;

</code></pre>
<p>[预览地址](</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[CSS3图片旋转木马效果]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/7</link>
            <guid>https://github.com/xiaotiandada/blog/issues/7</guid>
            <pubDate>Tue, 19 Jan 2021 04:57:15 GMT</pubDate>
            <description><![CDATA[<p>2018-06-08 23:48:48</p>
<h3>CSS3图片旋转木马效果</h3>
<p><a href="https://xiaotiandada.github.io/Case/Anime/CSS3%E5%9B%BE%E7%89%87%E6%97%8B%E8%BD%AC%E6%9C%A8%E9%A9%AC%E6%95%88%E6%9E%9C/">模仿demo</a></p>
<p><a href="http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/">资料</a></p>
<p><a href="http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/">资料demo</a></p>
<hr>
<!-- more -->
<p><img src="CSS3%E5%9B%BE%E7%89%87%E6%97%8B%E8%BD%AC%E6%9C%A8%E9%A9%AC%E6%95%88%E6%9E%9C/img.png" alt="img"></p>
<pre><code class="language-bash"># html

&lt;div class=&quot;stage_area&quot;&gt;
  &lt;div class=&quot;container&quot; id=&quot;container&quot;&gt;
    &lt;img src=&quot;http://image.zhangxinxu.com/image/study/s/s128/mm1.jpg&quot; alt=&quot;&quot;&gt;
    &lt;img src=&quot;http://image.zhangxinxu.com/image/study/s/s128/mm1.jpg&quot; alt=&quot;&quot;&gt;
    &lt;img src=&quot;http://image.zhangxinxu.com/image/study/s/s128/mm1.jpg&quot; alt=&quot;&quot;&gt;
    &lt;img src=&quot;http://image.zhangxinxu.com/image/study/s/s128/mm1.jpg&quot; alt=&quot;&quot;&gt;
    &lt;img src=&quot;http://image.zhangxinxu.com/image/study/s/s128/mm1.jpg&quot; alt=&quot;&quot;&gt;
    &lt;img src=&quot;http://image.zhangxinxu.com/image/study/s/s128/mm1.jpg&quot; alt=&quot;&quot;&gt;
    &lt;img src=&quot;http://image.zhangxinxu.com/image/study/s/s128/mm1.jpg&quot; alt=&quot;&quot;&gt;
    &lt;img src=&quot;http://image.zhangxinxu.com/image/study/s/s128/mm1.jpg&quot; alt=&quot;&quot;&gt;
    &lt;img src=&quot;http://image.zhangxinxu.com/image/study/s/s128/mm1.jpg&quot; alt=&quot;&quot;&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;stage_button&quot;&gt;
  &lt;button id=&quot;prev&quot;&gt;上滑&lt;/button&gt;
  &lt;button id=&quot;next&quot;&gt;下滑&lt;/button&gt;
&lt;/div&gt;

# css

.stage_area {
  width: 900px;
  margin-left: auto;
  margin-right: auto;
  background: #f0f0f0;
  -webkit-perspective: 800px;
  -moz-perspective: 800px;
  perspective: 800px;
  position: relative;
  padding: 100px 50px;
  min-height: 100px;
}

.container {
  -webkit-transform-style: preserve-3d;
  -moz-transform-style: preserve-3d;
  transform-style: preserve-3d;

  width: 128px;
  height: 100px;
  left: 50%;
  margin-left: -64px;
  position: absolute;

  /* transform: rotateY(40deg); */

  -webkit-transition: transform 1s;
  -moz-transition: transform 1s;
  transition: transform 1s;
}

.container img {
  position: absolute;
}

.container img:nth-child(1) {
  transform: rotateY(0deg) translateZ(195.839px);
}

.container img:nth-child(2) {
  transform: rotateY(40deg) translateZ(195.839px);
}

.container img:nth-child(3) {
  transform: rotateY(80deg) translateZ(195.839px);
}

.container img:nth-child(4) {
  transform: rotateY(120deg) translateZ(195.839px);
}

.container img:nth-child(5) {
  transform: rotateY(160deg) translateZ(195.839px);
}

.container img:nth-child(6) {
  transform: rotateY(200deg) translateZ(195.839px);
}

.container img:nth-child(7) {
  transform: rotateY(240deg) translateZ(195.839px);
}

.container img:nth-child(8) {
  transform: rotateY(280deg) translateZ(195.839px);
}

.container img:nth-child(9) {
  transform: rotateY(320deg) translateZ(195.839px);
}

# js

window.onload = init
function init(){
  var prev = document.querySelector('#prev')
  var next = document.querySelector('#next')
  var container = document.querySelector('#container')
  var len = 0

  var transform = function(element, value, key) {
    key = key || &quot;Transform&quot;;
    [&quot;Moz&quot;, &quot;O&quot;, &quot;Ms&quot;, &quot;Webkit&quot;, &quot;&quot;].forEach(function(prefix) {
      element.style[prefix + key] = value;	
    });	
    
    return element;
  }

  prev.addEventListener('click', function(){
    var _this = this
    len-=40

    transform(container, 'rotateY('+ len +'deg)');
    
  })

  next.addEventListener('click', function(){
    var _this = this
    len+=40

    transform(container, 'rotateY('+ len +'deg)');
  })
}
</code></pre>
<hr>
<p>js部分用了大佬demo的js方法（就是赞！！</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[卡片翻转动效]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/6</link>
            <guid>https://github.com/xiaotiandada/blog/issues/6</guid>
            <pubDate>Tue, 19 Jan 2021 04:56:49 GMT</pubDate>
            <description><![CDATA[<p>2018-06-07 22:34:02</p>
<h3>卡片翻转动效</h3>
<p><a href="http://ife.baidu.com/course/all">地址</a></p>
<p><a href="https://xiaotiandada.github.io/ife/%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%AD%A6%E9%99%A2/No.4/">预览地址</a></p>
<p><a href="http://www.zhangxinxu.com/study/201209/pictures-3d-slide-view.html">资料</a></p>
<p><a href="http://ife.baidu.com/course/detail/id/31?t=1528373270979#learn">资料</a></p>
<p><a href="http://jadyoap.bj.bcebos.com/ife%2F%E4%BB%BB%E5%8A%A1%E5%9B%9B.mov">视频地址</a></p>
<!-- more -->
<h3>效果图</h3>
<p><img src="%E5%8D%A1%E7%89%87%E7%BF%BB%E8%BD%AC%E5%8A%A8%E6%95%88/one.png" alt="截图"></p>
<p><img src="%E5%8D%A1%E7%89%87%E7%BF%BB%E8%BD%AC%E5%8A%A8%E6%95%88/two.png" alt="截图"></p>
<pre><code class="language-bash"># html
&lt;div class=&quot;container&quot;&gt;
&lt;div class=&quot;box&quot;&gt;
&lt;div class=&quot;positive&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;negative&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
# css

.box{
    position: relative;
    width: 250px;
    height: 380px;
    margin-left: auto;
    margin-right: auto;
    transform: rotateY(0deg);
    -webkit-transform-style: preserve-3d;
    -moz-transform-style: preserve-3d;
    transform-style: preserve-3d;
    -webkit-transition: transform .8s ease-in-out;
    -moz-transition: transform .8s ease-in-out;
    transition: transform .8s ease-in-out;

    -webkit-perspective: 800px;
    -moz-perspective: 800px;
    perspective: 800px;
}
.positive,
.negative{
    width: 250px;
    height: 380px;
    background-size: cover;
    position: absolute;
    backface-visibility: hidden;
    
}

.positive{
    transform: rotateY(0deg);
    background-image: url(../img/正面.jpg);
}
.negative{
    background-image: url(../img/反面.jpg);
    transform: rotateY(180deg);
}

.box:hover{
    transform: rotateY(180deg);        
}
</code></pre>
]]></description>
        </item>
        <item>
            <title><![CDATA[vue-lottie动画效果]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/5</link>
            <guid>https://github.com/xiaotiandada/blog/issues/5</guid>
            <pubDate>Tue, 19 Jan 2021 04:56:23 GMT</pubDate>
            <description><![CDATA[<p>2018-06-06 18:45:38</p>
<h3>vue-lottie动画效果</h3>
<p><a href="https://github.com/xiaotiandada/Case/tree/master/Anime/sanDemo">仓库地址</a></p>
<p><a href="https://xiaotiandada.github.io/Case/Anime/sanDemo/app/">模仿demo</a></p>
<p><a href="https://xiaotiandada.github.io/">blog</a></p>
<p><a href="https://juejin.im/post/5aff09ee6fb9a07a9b36365b">掘金</a></p>
<p>用lottie的好处有很多(.......此处省略ｎ字) 简单来说就是简单高效的还原设计的动画效果</p>
<p>然后在个人项目使用vue-lottie　分享一些小小经验吧</p>
<p>废话不多说～～～ (正经分割线)</p>
<!-- more -->
<hr>
<h3>分析官方demo</h3>
<p>先来一个简单的尝尝鲜</p>
<p><a href="https://github.com/chenqingspring/vue-lottie">vue-lottie仓库</a></p>
<p><a href="https://chenqingspring.github.io/vue-lottie/">vue-lottie demo</a></p>
<p>打开仓库可以看见很多很棒的效果（nice</p>
<h4>Installation</h4>
<pre><code class="language-bash">npm install --save vue-lottie
</code></pre>
<h4>Usage</h4>
<pre><code class="language-bash">&lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;lottie :options=&quot;defaultOptions&quot; :height=&quot;400&quot; :width=&quot;400&quot; v-on:animCreated=&quot;handleAnimation&quot;/&gt;
        &lt;div&gt;
            &lt;p&gt;Speed: x{{animationSpeed}}&lt;/p&gt;
            &lt;input type=&quot;range&quot; value=&quot;1&quot; min=&quot;0&quot; max=&quot;3&quot; step=&quot;0.5&quot;
                   v-on:change=&quot;onSpeedChange&quot; v-model=&quot;animationSpeed&quot;&gt;
        &lt;/div&gt;
        &lt;button v-on:click=&quot;stop&quot;&gt;stop&lt;/button&gt;
        &lt;button v-on:click=&quot;pause&quot;&gt;pause&lt;/button&gt;
        &lt;button v-on:click=&quot;play&quot;&gt;play&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import Lottie from './lottie.vue';
  import * as animationData from './assets/pinjump.json';

  export default {
    name: 'app',
    components: {
      'lottie': Lottie
    },
    data() {
      return {
        defaultOptions: {animationData: animationData},
        animationSpeed: 1
      }
    },
    methods: {
      handleAnimation: function (anim) {
        this.anim = anim;
      },

      stop: function () {
        this.anim.stop();
      },

      play: function () {
        this.anim.play();
      },

      pause: function () {
        this.anim.pause();
      },

      onSpeedChange: function () {
        this.anim.setSpeed(this.animationSpeed);
      }
    }
  }
&lt;/script&gt;
</code></pre>
<p>这是之前官方给的demo代码　基本上和平时使用没啥不一样(所以只需要复制粘贴就ok了)</p>
<pre><code class="language-bash"># json 动画效果AE转json后的文件
import * as animationData from './assets/pinjump.json';
</code></pre>
<p>引入的json需要改！！！</p>
<pre><code class="language-bash"># 这里引入了　lottie组件
import Lottie from './lottie.vue';
</code></pre>
<pre><code class="language-bash"># lottie.vue
&lt;template&gt;
    &lt;div :style=&quot;style&quot; ref=&quot;lavContainer&quot;&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import lottie from 'lottie-web'
export default {
    props: {
      options: {
        type: Object,
        required: true
      },
      height: Number,
      width: Number
    },
    data() {
      return {
        style: {
          width: this.width ? `${this.width}px` : '100%',
          height: this.height ? `${this.height}px` : '100%',
          overflow: 'hidden',
          margin: '0 auto'
        }
      }
    },
    mounted() {
      this.anim = lottie.loadAnimation({
        container: this.$refs.lavContainer,
        renderer: 'svg',
        loop: this.options.loop !== false,
        autoplay: this.options.autoplay !== false,
        animationData: this.options.animationData,
        rendererSettings: this.options.rendererSettings
      }
      )
      this.$emit('animCreated', this.anim)
    }
  }
&lt;/script&gt;
</code></pre>
<p>然后会发现还是有错误(缺少组件！)　其实很简单啦，打开仓库进入src然后打开lottle组件然后复制过去就ok啦hhh(简单)</p>
<p><img src="vue-lottie%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/one.png" alt="效果图"></p>
<p>这是效果图（是不是很简单２３３</p>
<h3>使用别的json文件</h3>
<p>官方给给了一个很好的效果网站　<a href="https://www.lottiefiles.com/">地址</a></p>
<p>下载json文件　然后更换引入的json</p>
<pre><code class="language-bash"># json 动画效果AE转json后的文件
import * as animationData from './assets/blood_transfusion_kawaii.json.json';

</code></pre>
<p><img src="vue-lottie%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/two.png" alt="效果图"></p>
<p>是不是也很简单！！！</p>
<h3>使用vue-lottie模仿san官网的动画效果</h3>
<p>先来效果图～～～</p>
<p><img src="vue-lottie%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/three.png" alt="效果图"></p>
<p>因为有多个需要用到lottie动画，想了半天不知道怎么解决调用方法的问题　最后想了一个简单的方法</p>
<p>直接将每一个动画抽到一个组件　组件内依然用之前的方法（稍微改造一下就行</p>
<p>然后利用父子组件传数据的形式传递json文件　子组件props接收</p>
<pre><code class="language-bash"># html
&lt;template&gt;
  &lt;div class=&quot;card-panel&quot; @mouseenter=&quot;lottiePlay&quot; @mouseleave=&quot;lottieStop&quot;&gt;
    &lt;div class=&quot;card-panel-icon-wrapper icon-shoppingCard&quot;&gt;
      &lt;lottie :options=&quot;defaultOptions&quot; :height=&quot;80&quot; :width=&quot;80&quot; v-on:animCreated=&quot;handleAnimation&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;card-panel-description&quot;&gt;
      &lt;div class=&quot;card-panel-text&quot;&gt;今日活跃&lt;/div&gt;
      &lt;div class=&quot;card-panel-num&quot;&gt;2600&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="language-bash"># props
props: {
    animationDataPath: {
      type: Object,
      default: null
    }
  },
  data() {
  return {
    defaultOptions: {
      // animationData: animationDataPath,
      animationData: this.animationDataPath,
      autoplay: false,  # 不自动播放
      loop: false　　　　　# 不循环
    }
  }
}
</code></pre>
<pre><code class="language-bash"># 事件调用
@mouseenter=&quot;lottiePlay&quot; @mouseleave=&quot;lottieStop&quot;

lottiePlay: function() {
  this.anim.play()
},
lottieStop: function() {
  this.anim.stop()
}
</code></pre>
<p>然后就到了父组件传数据</p>
<pre><code class="language-bash"># 父组件
&lt;panel-lottie :animationDataPath=&quot;animationDataPathOne&quot;&gt;&lt;/panel-lottie&gt;

animationDataPathOne: require('../../../public/json/compass.json')
</code></pre>
<p>自己用到了require引入json　然后打包出来　一样可以正常运行　如果大家有很好的方法可以教我！我好学习学习</p>
<hr>
<p>emmmmm　大概就是这么多吧～</p>
<p>如果实在需要这个的源码可以打开我的github仓库　由于项目还是一个半成品　所以地址就放在最后面了</p>
<p><a href="https://github.com/xiaotiandada/My-music/tree/master/client/src/views/admin/About">vue-lottie源码</a></p>
<p><a href="https://github.com/xiaotiandada/My-music">项目地址</a></p>
<blockquote>
<p>如果大家觉得不错的话　可以点star哦（厚脸皮２３３</p>
</blockquote>
]]></description>
        </item>
        <item>
            <title><![CDATA[css小猫笑起来的动画]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/4</link>
            <guid>https://github.com/xiaotiandada/blog/issues/4</guid>
            <pubDate>Tue, 19 Jan 2021 04:55:50 GMT</pubDate>
            <description><![CDATA[<p>2018-06-05 13:39:54</p>
<h3>No.3 - CSS transition 和 CSS transform 配合制作动画</h3>
<p><a href="http://ife.baidu.com/course/all">仓库地址</a></p>
<p><a href="https://xiaotiandada.github.io/ife/%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%AD%A6%E9%99%A2/No.3/index.html">预览地址</a></p>
<p><a href="http://ife.baidu.com/note/detail/id/418#">资料</a></p>
<p><a href="http://ife.baidu.com/course/detail/id/30">文章地址</a></p>
<p>其实文章地址里面提供的资料已经很不错了！！！（偷懒～</p>
<!-- more -->
<h3>效果</h3>
<p><img src="css%E5%B0%8F%E7%8C%AB%E7%AC%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E5%8A%A8%E7%94%BB/cat.png" alt="截图"></p>
<p><img src="css%E5%B0%8F%E7%8C%AB%E7%AC%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E5%8A%A8%E7%94%BB/cats.png" alt="截图"></p>
<h3>代码实现</h3>
<pre><code class="language-bash"># html
&lt;div class=&quot;container&quot;&gt;
  &lt;!-- 脸 --&gt;
  &lt;div class=&quot;face&quot;&gt;
    &lt;!-- 头发 --&gt;
    &lt;div class=&quot;hair&quot;&gt;&lt;/div&gt;
    &lt;!-- 眼睛 --&gt;
    &lt;div class=&quot;eye-wrap&quot;&gt;
      &lt;div class=&quot;eye left&quot;&gt;
        &lt;div class=&quot;eye-circle&quot;&gt;
          &lt;div class=&quot;eye-core&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;eye-bottom&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;face-red&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;eye right&quot;&gt;
        &lt;div class=&quot;eye-circle&quot;&gt;
          &lt;div class=&quot;eye-core&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;eye-bottom&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;face-red&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 鼻子 --&gt;
    &lt;div class=&quot;nose&quot;&gt;&lt;/div&gt;
    &lt;!-- 嘴巴 --&gt;
    &lt;div class=&quot;mouth-wrap&quot;&gt;
      &lt;div class=&quot;mouth left&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;mouth right&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;!-- 耳朵 --&gt;
  &lt;div class=&quot;ear-wrap&quot;&gt;
    &lt;div class=&quot;ear left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;ear right&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-bash"># css 动画部分样式
.face,
.hair,
.face-red,
.eye-bottom,
.ear,
.eye-core,
.mouth{
    transition: transform 1s;    
}
.face-red{
    transition: opacity 1s;
}
.mouth{
    transition: border-radius 1s;
}

.face:hover~.ear-wrap .left{
    transform-origin: 50%, 100%;
    transform: rotate(-30deg);
}
.face:hover~.ear-wrap .right{
    transform-origin: 50%, 100%;
    transform: rotate(30deg);
}
.face:hover .eye-wrap .eye-bottom{
    transform: translateY(-15px);
}

.face:hover .eye-wrap .face-red{
    opacity: 1;
}
.face:hover .eye-wrap .eye-core{
    transform: scaleX(.8);
}
.face:hover .mouth-wrap .left{
    border-radius: 0% 40% 50% 50%;
}
.face:hover .mouth-wrap .right{
    border-radius: 0% 40% 50% 50%;
}
.face:hover{
    transform: scaleX(.99);
    transform: translateY(-6px);
}
.face:hover .hair{
    transform: scaleX(.9);
}
</code></pre>
<p>Qq: 952822399</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[掘金头像旋转动画]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/3</link>
            <guid>https://github.com/xiaotiandada/blog/issues/3</guid>
            <pubDate>Tue, 19 Jan 2021 04:55:18 GMT</pubDate>
            <description><![CDATA[<p>2018-06-04 00:19:54</p>
<h3>掘金头像旋转动画</h3>
<hr>
<p>参考文章或者地址</p>
<p><a href="https://juejin.im/post/5a9bc63f6fb9a028be357720">文章</a></p>
<p><a href="https://juejin.im/user/58ce984d1b69e6006b82ff71">掘金头像地址</a></p>
<p><a href="https://xiaotiandada.github.io/Case/Anime/%E6%8E%98%E9%87%91%E5%A4%B4%E5%83%8F%E6%97%8B%E8%BD%AC%E5%8A%A8%E7%94%BB/">模仿地址</a></p>
 <!-- more -->
<h4>代码实现</h4>
<pre><code class="language-bash"># 结构
&lt;div class=&quot;avatar&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-bash"># 样式
.avatar {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  overflow: hidden;
  margin: 0 auto;
  background-image: url(https://avatars2.githubusercontent.com/u/24250627?s=460&amp;v=4);
  background-size: cover;
}

.avatar:hover {
  -webkit-transform: rotate(666turn);
  transform: rotate(666turn);
  transition-delay: 1s;
  transition-property: all;
  transition-duration: 59s;
  transition-timing-function: cubic-bezier(.34, 0, .84, 1)
}
</code></pre>
<h3>资料参考</h3>
<p><a href="http://www.css88.com/book/css/values/angle/turn.htm">turn</a></p>
<p>转、圈（Turns）。一个圆共1圈</p>
<p>90deg = 100grad = 0.25turn ≈ 1.570796326794897rad</p>
<p>资料有兼容说明</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[模仿san的hover动画]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/2</link>
            <guid>https://github.com/xiaotiandada/blog/issues/2</guid>
            <pubDate>Tue, 19 Jan 2021 04:54:17 GMT</pubDate>
            <description><![CDATA[<p>2018-05-19 01:10:14</p>
<p>在百度前端技术学院学习 设计师学院 绿(大佬)的课程 (第一课QAQ) <a href="http://ife.baidu.com/course/detail/id/18">传送门</a></p>
<p>然后模仿san官网的动画效果 <a href="https://baidu.github.io/san/">san</a></p>
<p>这是我模仿的效果 <a href="https://xiaotiandada.github.io/Case/Anime/sanDemo/app/">传送们</a> pc端食用更佳！</p>
<p>大佬的实现已经很棒了 个人只让部分动画变得平滑 比如说鼠标移出的时候增加了</p>
<!-- more -->
<pre><code class="language-bash">transition: transform .3s;
</code></pre>
<p>这样可以让鼠标移出Div的时候更加平滑</p>
<p>分界线～～～</p>
<hr>
<p>首先贴出资料和大佬的教程</p>
<ul>
<li><a href="http://ife.baidu.com/course/detail/id/18">http://ife.baidu.com/course/detail/id/18</a></li>
<li><a href="https://zhuanlan.zhihu.com/uxelement">https://zhuanlan.zhihu.com/uxelement</a></li>
<li><a href="https://baidu.github.io/san/">https://baidu.github.io/san/</a></li>
<li><a href="https://github.com/airbnb/lottie-web">https://github.com/airbnb/lottie-web</a></li>
<li><a href="https://codepen.io/airnan/project/editor/ZeNONO/">https://codepen.io/airnan/project/editor/ZeNONO/</a></li>
<li><a href="https://www.youtube.com/watch?v=5XMUJdjI0L8">https://www.youtube.com/watch?v=5XMUJdjI0L8</a></li>
<li>......</li>
</ul>
<p>大概就是这么写 大家可以去Google搜教程 官方案例很不错</p>
<p>首先布局 结构和样式都可以借鉴san官网 利用控制台(so easy~)</p>
<pre><code class="language-bash">&lt;div class=&quot;resource-block&quot;&gt;
  &lt;a href=&quot;&quot; class=&quot;resource-item&quot;&gt;
    &lt;div class=&quot;resource-item-top resource-item-top-two&quot;&gt;
        &lt;div
        id=&quot;bm&quot;
        class=&quot;bodymovin&quot;
        data-movpath=&quot;js/compass.json&quot;&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;resource-item-bottom&quot;&gt;
      &lt;h5&gt;教程&lt;/h5&gt;
      &lt;p&gt;教程是入门的捷径，请从这里开始了解San&lt;/p&gt;
    &lt;/div&gt;
  &lt;/a&gt;
&lt;/div&gt;
</code></pre>
<p>这是结构 具体样式可以查看我的github文件 <a href="https://github.com/xiaotiandada/Case/tree/master/Anime">传送门</a></p>
<p>然后就是js 控制动画效果了</p>
<p>引入jquery (方便～)</p>
<ul>
<li>在github上的build/player获取最新版本的lottie.js文件 或者 从AE的插件导出</li>
<li>在HTML引入文件</li>
</ul>
<pre><code class="language-bash">&lt;script src=&quot;js/lottie.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>调用lottie.loadAnimation()启动一个动画。将一个对象作为参数</li>
</ul>
<pre><code class="language-bash">var animData = {
  container: bodymovinLayer,
  renderer: 'svg',
  prerender: true,
  loop: false,
  autoplay: false,
  path: bodymovinLayer.getAttribute('data-movpath')
}

# animData 导出的动画数据的Object
# container 渲染动画的dom元素
# renderer 'svg'/'canvas'/'html'来设置渲染器
# prerender 这个根据英文应该是预渲染
# loop 是否循环播放
# autoplay 是否自动播放
# path 路径


</code></pre>
<ul>
<li>while循环绑定事件 将上面封装进一个方法</li>
</ul>
<pre><code class="language-bash">setBodymovin = function (cards, len) {
  while (len--) {
    var bodymovinLayer = cards[len].getElementsByClassName('bodymovin')[0]

    var animData = {
      container: bodymovinLayer,
      renderer: 'svg',
      prerender: true,
      loop: false,
      autoplay: false,
      path: bodymovinLayer.getAttribute('data-movpath')
    }

    anim = lottie.loadAnimation(animData);

    (function (anim) {
      var card = cards[len]

      $(card).on('mouseenter', function () {
        anim.play()
      })

      $(card).on('mouseleave', function (e) {
        anim.stop()
      })
    })(anim)

  }

}
</code></pre>
<ul>
<li>最后获取元素调用</li>
</ul>
<pre><code class="language-bash">var resourceCards = document.querySelectorAll('.resource-block')
var facilityCards = document.querySelectorAll('.facility-block')
var len = resourceCards.length

setBodymovin(resourceCards, len)
setBodymovin(facilityCards, len)

</code></pre>
<p>最后贴 gulp 任务</p>
<pre><code class="language-bash">const gulp = require('gulp')
const connect = require('gulp-connect')

gulp.task('connect', function(){
  connect.server({
    root: 'app',
    port: 8000,
    livereload: true
  })
})

gulp.task('html', function(){
  gulp.src('./app/*.html')
    .pipe(connect.reload())
})

gulp.task('css', function(){
  gulp.src('./app/css/*.css')
    .pipe(connect.reload())
})

gulp.task('watch', function () {
  gulp.watch(['./app/*.html'], ['html'])
  gulp.watch(['./app/css/*.css'], ['css'])
})

gulp.task('default', ['connect','watch'])
</code></pre>
<p>具体代码见github源码</p>
<p>大佬多给给意见哦～～～</p>
<p>Qq： 952822399</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[lolSix周年活动页面]]></title>
            <link>https://github.com/xiaotiandada/blog/issues/1</link>
            <guid>https://github.com/xiaotiandada/blog/issues/1</guid>
            <pubDate>Tue, 19 Jan 2021 04:52:11 GMT</pubDate>
            <description><![CDATA[<h1>前言</h1>
<p>2018-03-19 12:27:36</p>
<p>在掘金看到了一个大佬发的 <a href="https://juejin.im/entry/59ad11f3f265da247158203d">LOL六周年里的按钮动画</a> 的文章, 觉得很有意思</p>
<p>于是进 <a href="http://lol.qq.com/act/a20170810sixyears/index.html?ADTAG=lolweb.index">lolSix周年活动页面</a> 看看效果 只剩下哇塞!哇塞!哇塞!</p>
<p>于是自己决定试试,参考首页写一部分效果</p>
<p>ps: <a href="https://xiaotiandada.github.io/lolSix/">demo</a> <a href="https://github.com/xiaotiandada/lolSix">demo仓库</a></p>
<p>两个动画都是通过改变class来完成的效果</p>
<pre><code class="language-bash">(function () {
    // 定义所需要的变量
    let navBtns = $('#nav-ul i')
    let navBtnli = $('#nav-ul li')
    let navhs = $('#nav li')
    let navhem = $('#nav em')
    // 两个改变class的计数变量
    let numLi = {
        numi: 1,
        numh: 1
    }
    // 清楚定时器的变量
    let time = null

    // 鼠标经过和移除 触发run方法
    navBtnli.on('mouseover', function () {
        let navI = $(this).children('i')
        run(navI, 'ans2_btn', numLi.numi)
    })
    navBtnli.on('mouseout', function () {
        let target = $(this).children('i')
        stop(target)
    })

    navhs.on('mouseover', function () {
        $(this).removeClass('ligb')
        let navh = $(this).children('em')
        run(navh, 'ans_btn', numLi.numh)
    })

    navhs.on('mouseout', function () {
        let target = $(this).children('em')
        stop(target)
        $(this).addClass('ligb')
    })

    // 接受三个参数, 需要改变的对象, 需要改变的名字, 需要改变的数
    function run(obj, name, num) {
        // js定时器setTimeout 无法调用局部变量的解决办法
        function runs() {
            if (num &gt; 25) {
                num = 1
            }
            obj.css('display', 'block')
            obj.removeClass()
            obj.addClass(nameNav + num)
            num++
            time = setTimeout(function () {
                clearTimeout(time)
                runs()
            }, 30)
        }
        runs()
    }
    // 停止动画
    function stop(target) {
        clearTimeout(time)
        target.css('display', 'none')
    }

})()
</code></pre>
<p>html结构请参考 官方页面或者我的仓库里面的html文件</p>
<p>然后就是中间的 flash 动画,使用了html object标签,</p>
<p>但是我在Ubuntu上面chrome测试的时候正常没有问题,(自己在Ubuntu开虚拟机上win测试,IE11,360有效果,chrome,firefox就没有了,懵逼 希望有大佬可以跟我提点一二)</p>
<p>但是在Firefox测试的时候不会显示,</p>
<p>于是用了兼容的处理方法,先贴一个通用的处理方法(自己也研究了一会儿,第一次接触2333~~),</p>
<pre><code class="language-bash">    // 这是活动页面的解决办法
    // 大家也可以看看这个文档 https://github.com/swfobject/swfobject 
    // An open source Javascript framework for detecting the Adobe Flash Player plugin and embedding Flash (swf) files.
    // 自己英文比较垃圾 chrome 翻译过来就是
    // 用于检测Adobe Flash Player插件并嵌入Flash（swf）文件的开源Javascript框架。

    // 这个文件可以引用腾讯的,也可以下载,也可以新建文件复制粘贴
    &lt;script src=&quot;./public/js/swfobject.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;index.swf&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        var params = {
            scale: &quot;noscale&quot;,
            wmode: &quot;transparent&quot;,
            align: &quot;middle&quot;,
            allowFullscreen: &quot;true&quot;,
            allowScriptAccess: &quot;always&quot;,
            FlashVars: &quot;timer=1480586966506&amp;endtimer=1481094000000&quot;
        }
        swfobject.embedSWF(&quot;index.swf&quot;, &quot;mymovie&quot;, &quot;100%&quot;, &quot;670&quot;, &quot;8.0.0&quot;,&quot;expressInstall.swf&quot;, null, params);
    &lt;/script&gt;
</code></pre>
<p>虽然解决了引入swf动画的兼容问题,但是在firefox上面根本不显示啊 23333~~~</p>
<p>大佬的解决办法非常简单 请继续细心观看文章!</p>
<pre><code class="language-bash">// 提前在html结构上面写一个静态的替代图片,然后隐藏
&lt;div class=&quot;logob&quot;&gt;英雄联盟6周年盛典&lt;/div&gt;

// 这里是swf文件的位置
&lt;div id=&quot;mymovie&quot; class=&quot;mymovie&quot;&gt;&lt;/div&gt;

// 通过判断 来显示静态图片(虽然没有了swf动画,但是总不不显示比较好 赞 学习了~!)
 setTimeout(function () {
    if ($(&quot;.mymovie&quot;).length &gt; 0) {
        $(&quot;.logob&quot;).css({
            &quot;display&quot;: &quot;block&quot;
        });
    }
}, 1000)
</code></pre>
]]></description>
        </item>
    </channel>
</rss>